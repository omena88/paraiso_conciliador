<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conciliador Bancario</title>
    <!-- 
    ======================================================
    CONCILIADOR BANCARIO - VERSI√ìN WORDPRESS
    ======================================================
    
    Esta versi√≥n est√° optimizada para integrarse en WordPress:
    
    ‚úÖ Todos los estilos est√°n encapsulados con la clase .conciliador-bancario-app
    ‚úÖ Se usa !important para prevenir conflictos con temas de WordPress
    ‚úÖ Tailwind CSS configurado con selector important
    ‚úÖ Reset de estilos para elementos cr√≠ticos
    ‚úÖ Isolation CSS para crear contexto de stacking independiente
    
    INTEGRACI√ìN EN WORDPRESS:
    - Insertar el contenido del <body> en una p√°gina/post
    - Asegurar que las librer√≠as CDN est√°n cargadas
    - El contenedor .conciliador-bancario-app a√≠sla los estilos
    
    ====================================================== 
    -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- Cache buster v2 -->
    
<!-- CDN Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/preline@2.0.3/dist/preline.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha512-Kc323vGBEqzTmouAECnVceyQqyqdsSiqLQISBL29aUW4U/M7pSPA/gEUZQqv1cwx4OnYxTxve5UMg5GT6L4JJg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <script>
        tailwind.config = {
            important: '.conciliador-bancario-app',
            theme: {
                extend: {
                    fontFamily: {
                        'sans': ['Inter', 'ui-sans-serif', 'system-ui', 'sans-serif'],
                    },
                    colors: {
                        primary: {
                            50: '#eff6ff',
                            100: '#dbeafe',
                            200: '#bfdbfe',
                            300: '#93c5fd',
                            400: '#60a5fa',
                            500: '#3b82f6',
                            600: '#2563eb',
                            700: '#1d4ed8',
                            800: '#1e40af',
                            900: '#1e3a8a',
                        }
                    }
                }
            }
        }
    </script>
    
    <style>
        /* Conciliador Bancario - Estilos aislados para WordPress */
        .conciliador-bancario-app [x-cloak] { display: none !important; }
        .conciliador-bancario-app .file-input-area {
            transition: all 0.2s ease !important;
        }
        .conciliador-bancario-app .file-input-area:hover {
            border-color: #3b82f6 !important;
            background-color: #eff6ff !important;
        }
        .conciliador-bancario-app .file-input-area.has-file {
            border-color: #10b981 !important;
            background-color: #ecfdf5 !important;
        }
        
        /* Reset de estilos WordPress que podr√≠an interferir */
        .conciliador-bancario-app * {
            box-sizing: border-box !important;
        }
        
        .conciliador-bancario-app {
            line-height: 1.5 !important;
            font-family: 'Inter', ui-sans-serif, system-ui, sans-serif !important;
            min-height: 100vh !important;
            isolation: isolate !important;
        }
        
        /* Prevenir que los estilos de WordPress afecten los botones y formularios */
        .conciliador-bancario-app button,
        .conciliador-bancario-app input,
        .conciliador-bancario-app select,
        .conciliador-bancario-app textarea {
            font-family: inherit !important;
            font-size: inherit !important;
            line-height: inherit !important;
        }
        
        /* Espaciado espec√≠fico para la lista de archivos */
        .conciliador-bancario-app .space-y-1 > * + * {
            margin-top: 0.25rem !important;
            margin-bottom: 0 !important;
        }
        
        .conciliador-bancario-app .file-item {
            padding: 0.5rem !important;
            margin-top: 0.25rem !important;
            margin-bottom: 0 !important;
        }
        
        .conciliador-bancario-app .space-y-1 {
            gap: 0.25rem !important;
        }
        
        .conciliador-bancario-app .space-y-1 > *:first-child {
            margin-top: 0 !important;
        }
        
        .conciliador-bancario-app .files-container {
            display: flex !important;
            flex-direction: column !important;
            gap: 0.25rem !important;
        }
        
        .conciliador-bancario-app .files-container .file-item {
            margin: 0 !important;
        }
        
        /* Reset de margin-bottom de p√°rrafos que causa el espaciado extra */
        .conciliador-bancario-app .files-container p {
            margin-bottom: 0 !important;
            margin-top: 0 !important;
        }
        
        .conciliador-bancario-app p {
            margin-bottom: 0 !important;
        }
    </style>
</head>

<body>
<div class="conciliador-bancario-app bg-gray-50" x-data="bancarioConciliador()">
    <!-- Header -->
    <div class="max-w-4xl mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold text-gray-900 mb-8">Conciliador Bancario</h1>

        <!-- Upload Area -->
        <div class="mb-8">
            <div class="flex flex-col md:flex-row md:space-x-8 md:items-start">

                <!-- Columna Izquierda: √Årea de Carga -->
                <div class="w-full md:w-1/3">
                    <div class="border-2 border-dashed border-gray-300 rounded-lg bg-white hover:border-blue-500 transition-colors duration-200 cursor-pointer h-full flex flex-col justify-center"
                 :class="{ 'border-blue-500 bg-blue-50': isDragOver }"
                 @dragover.prevent="isDragOver = true"
                 @dragleave.prevent="isDragOver = false"
                 @drop.prevent="handleDrop($event)"
                 @click="$refs.fileInput.click()">
                
                        <div class="p-8 text-center">
                    <input type="file" 
                           x-ref="fileInput" 
                           multiple 
                           accept=".xlsx,.xls,.csv"
                           @change="handleFileSelect($event)"
                           class="hidden">
                    
                    <div class="mx-auto h-12 w-12 text-gray-400 mb-4">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M7 16a4 4 0 01-4-4V7a4 4 0 014-4h10a4 4 0 014 4v5a4 4 0 01-4 4H7z" />
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 11v6m0 0l-3-3m3 3l3-3" />
                                </svg>
                    </div>

                            <div class="text-lg text-gray-700 font-medium mb-2">
                                Cargar archivos
                    </div>
                    
                    <p class="text-sm text-gray-500">
                                Haz clic o arrastra los documentos aqu√≠
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Columna Derecha: Archivos Cargados -->
                <div class="w-full md:w-2/3 mt-6 md:mt-0">
                    <div x-show="files.length > 0" x-cloak>
                        <div class="bg-gray-50 rounded-lg p-4 border border-gray-200">
                            <h2 class="text-lg font-semibold text-gray-900 mb-4 flex items-center">
                                <i class="fas fa-folder-open text-blue-600 mr-2"></i>
                                Archivos Cargados
                            </h2>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                <template x-for="file in sortedFiles" :key="file.id">
                                    <div class="bg-white border border-gray-200 rounded-lg p-4 hover:shadow-md transition-shadow duration-200">
                                        <div class="flex items-start justify-between">
                                            <!-- Informaci√≥n del archivo -->
                                            <div class="flex-grow min-w-0 pr-3">
                                                <h3 class="text-sm font-medium truncate mb-1" 
                                                    :class="getFileIcon(file.category).textColor" 
                                                    x-text="file.name"></h3>
                                                <div class="flex items-center text-xs text-gray-500 space-x-2">
                                                    <span x-text="formatFileSize(file.size)"></span>
                                                    <span>‚Ä¢</span>
                                                    <span class="px-2 py-1 rounded-full text-xs font-medium"
                                                          :class="getFileIcon(file.category).bgColor + ' ' + getFileIcon(file.category).textColor"
                                                          x-text="getFileCategoryLabel(file.category)">
                                                    </span>
                                                </div>
                                            </div>
                                            
                                            <!-- Bot√≥n eliminar -->
                                            <button @click="deleteFile(file.id)"
                                                    class="flex-shrink-0 p-1.5 text-gray-400 hover:text-red-500 hover:bg-red-50 rounded-md transition-colors duration-200"
                                                    title="Eliminar archivo">
                                                <i class="fas fa-times text-sm"></i>
                                            </button>
                                        </div>
                                    </div>
                                </template>
                            </div>
                        </div>
                    </div>
                     <div x-show="files.length === 0" x-cloak class="text-center p-8 bg-gray-100 rounded-lg h-full flex flex-col justify-center">
                        <div class="mx-auto h-12 w-12 text-gray-400 mb-4">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-12 w-12" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                            </svg>
                        </div>
                        <p class="text-gray-600">Los archivos cargados aparecer√°n aqu√≠.</p>
                    </div>
                                    </div>
                                </div>
                            </div>

        <!-- Loading Spinner -->
        <div x-show="isLoading" x-cloak class="text-center py-8">
            <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mb-2"></div>
            <p class="text-gray-600">Procesando archivos de conciliaci√≥n...</p>
                                    </div>

        <!-- Status Message -->
        <div x-show="statusMessage.show" 
             x-cloak
             class="mb-6 p-4 rounded-md"
             :class="statusMessage.type === 'success' ? 'bg-green-50 text-green-800 border border-green-200' : 'bg-red-50 text-red-800 border border-red-200'">
            <span x-text="statusMessage.text"></span>
                                </div>

        <!-- Files Section -->
        <div x-show="files.length > 0" x-cloak class="mb-8">
            <div class="flex justify-center space-x-4">
                <button x-show="canProcessConciliation()"
                        @click="realizarConciliacion()"
                        class="inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors duration-200 shadow-sm">
                    <i class="fas fa-balance-scale mr-2"></i>
                    Iniciar conciliaci√≥n bancaria
                </button>
                
                <button x-show="!canProcessConciliation() && files.length > 0"
                        disabled
                        class="inline-flex items-center px-6 py-3 border border-gray-300 text-base font-medium rounded-md text-gray-400 bg-gray-100 cursor-not-allowed">
                    <i class="fas fa-exclamation-triangle mr-2"></i>
                    <span x-text="getMissingFilesMessage()"></span>
                </button>
                
                <button x-show="conciliationResult"
                        @click="descargarConciliacion()"
                        class="inline-flex items-center px-6 py-3 border border-gray-300 text-base font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors duration-200 shadow-sm">
                    <i class="fas fa-download mr-2"></i>
                    Descargar conciliaci√≥n
                </button>
                
                                <!-- Bot√≥n para cargar archivos de prueba -->
                <button x-show="files.length === 0"
                        @click="loadTestFiles()"
                        class="inline-flex items-center px-4 py-3 border border-green-300 text-base font-medium rounded-md text-green-600 bg-white hover:bg-green-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-colors duration-200 shadow-sm"
                        title="Cargar archivos de prueba simulados">
                    <i class="fas fa-flask mr-2"></i>
                    Cargar Archivos de Prueba
                </button>

                <!-- Bot√≥n para limpiar cache -->
                <button x-show="files.length > 0"
                        @click="clearStoredFiles()"
                        class="inline-flex items-center px-4 py-3 border border-red-300 text-base font-medium rounded-md text-red-600 bg-white hover:bg-red-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors duration-200 shadow-sm"
                        title="Limpiar archivos guardados y empezar de nuevo">
                    <i class="fas fa-trash-alt mr-2"></i>
                    Limpiar Todo
                </button>
            </div>
        </div>

        <!-- Results Section -->
        <div x-show="conciliationResult" x-cloak class="bg-white border border-gray-200 rounded-lg p-6 mb-8">
            <h3 class="text-lg font-semibold text-gray-900 mb-4">Resultado de Conciliaci√≥n Bancaria</h3>
                        
                        <!-- Stats Cards -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                <div class="bg-gray-50 rounded-xl p-6 text-center">
                    <div class="text-2xl font-bold text-gray-900 mb-1" x-text="conciliationResult?.totalProcesados || '-'"></div>
                    <div class="text-gray-600 text-sm">REGISTROS PROCESADOS</div>
                            </div>
                <div class="bg-green-50 rounded-xl p-6 text-center">
                    <div class="text-2xl font-bold text-green-600 mb-1" x-text="conciliationResult?.conciliados || '-'"></div>
                    <div class="text-gray-600 text-sm">REGISTROS CONCILIADOS</div>
                            </div>
                <div class="bg-red-50 rounded-xl p-6 text-center">
                    <div class="text-2xl font-bold text-red-600 mb-1" x-text="conciliationResult?.noConciliados || '-'"></div>
                    <div class="text-gray-600 text-sm">PENDIENTES</div>
                            </div>
                        </div>

            <div class="space-y-3">
                <template x-for="(value, key) in (conciliationResult?.detalles || {})" :key="key">
                    <div class="flex justify-between py-2 border-b border-gray-100 last:border-b-0">
                        <span class="text-sm font-medium text-gray-700" x-text="formatResultKey(key)"></span>
                        <span class="text-sm text-gray-900" x-text="formatResultValue(key, value)"></span>
                        </div>
                </template>
            </div>
    </div>
</div>

<script>
    function bancarioConciliador() {
        return {
            files: [],
            isDragOver: false,
            isLoading: false,
            statusMessage: {
                show: false,
                text: '',
                type: 'success'
            },
            conciliationResult: null,
            requiredFileTypes: ['mayor', 'extracto', 'resumen'],

            // Nomenclatura de archivos
            filePrefixes: {
                mayor: 'MAYOR',
                saldo: 'SALDO',
                extractos: [
                    'BCP.01.PEN', 'BCP.02.PEN', 'SANT.PEN', 'BBVA.PEN',
                    'SBP.PEN', 'IBK.PEN', 'DET.PEN', 'BN.PEN'
                ]
            },

            // Mapa de prefijos de extracto a cuentas contables
            extractoAccountMap: {
                'BCP.01.PEN': '1041501', 'BCP.02.PEN': '1041505', 'SANT.PEN': '1041401',
                'BBVA.PEN': '1041201', 'SBP.PEN': '1041301', 'IBK.PEN': '1041101',
                'DET.PEN': '1042101', 'BN.PEN': '1041601'
            },

            init() {
                // // console.log("üèÅ Inicializando Conciliador Bancario");
                this.loadStoredFiles();
            },

            // Cargar archivos guardados en localStorage
            loadStoredFiles() {
                try {
                    const storedFiles = localStorage.getItem('bancarioConciliador_files');
                    if (storedFiles) {
                        const filesData = JSON.parse(storedFiles);
                        this.files = filesData.map(fileData => ({
                            ...fileData,
                            file: this.base64ToFile(fileData.base64Data, fileData.name, fileData.type)
                        }));
                        // // console.log(`üìÅ Cargados ${this.files.length} archivos desde localStorage`);
                        if (this.files.length > 0) {
                            this.showStatus(`${this.files.length} archivo(s) cargado(s) desde la sesi√≥n anterior`, 'success');
                        }
                    }
                } catch (error) {
                    console.error('Error cargando archivos guardados:', error);
                }
            },

            // Guardar archivos en localStorage
            saveFilesToStorage() {
                try {
                    const filesToStore = this.files.map(file => ({
                        id: file.id,
                        name: file.name,
                        size: file.size,
                        category: file.category,
                        type: file.file.type,
                        base64Data: null // Se llenar√° despu√©s
                    }));

                    // Convertir archivos a base64 y guardar
                    Promise.all(filesToStore.map((fileInfo, index) => 
                        this.fileToBase64(this.files[index].file).then(base64 => {
                            fileInfo.base64Data = base64;
                            return fileInfo;
                        })
                    )).then(filesWithBase64 => {
                        localStorage.setItem('bancarioConciliador_files', JSON.stringify(filesWithBase64));
                        // // console.log('üìÅ Archivos guardados en localStorage');
                    }).catch(error => {
                        console.error('Error guardando archivos:', error);
                    });
                } catch (error) {
                    console.error('Error en saveFilesToStorage:', error);
                }
            },

            // Convertir archivo a base64
            fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            },

            // Convertir base64 a archivo
            base64ToFile(base64String, fileName, fileType) {
                const byteCharacters = atob(base64String.split(',')[1]);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                return new File([byteArray], fileName, { type: fileType });
            },

            // Limpiar archivos guardados
            clearStoredFiles() {
                localStorage.removeItem('bancarioConciliador_files');
                this.files = [];
                this.conciliationResult = null;
                this.showStatus('Archivos guardados eliminados', 'success');
                // // console.log('üóëÔ∏è Cache de archivos limpiado');
            },

            handleDrop(event) {
                this.isDragOver = false;
                const files = Array.from(event.dataTransfer.files);
                this.processFiles(files);
            },

            handleFileSelect(event) {
                const files = Array.from(event.target.files);
                this.processFiles(files);
            },

            processFiles(files) {
                const validFiles = files.filter(file => {
                    const extension = file.name.split('.').pop().toLowerCase();
                    const allowedExtensions = ['xlsx', 'xls', 'csv'];
                    return allowedExtensions.includes(extension);
                });

                if (validFiles.length > 0) {
                    this.addFiles(validFiles);
        } else {
                    this.showStatus('Por favor selecciona archivos v√°lidos (XLSX, XLS, CSV)', 'error');
                }
            },

            addFiles(files) {
                files.forEach(file => {
                    const fileObj = {
                        id: Date.now() + Math.random(),
                        name: file.name,
                        size: file.size,
                        file: file,
                        category: this.categorizeFile(file.name)
                    };
                    this.files.push(fileObj);
                });
                this.showStatus(`${files.length} archivo(s) agregado(s) correctamente`, 'success');
                
                // Guardar autom√°ticamente en localStorage
                this.saveFilesToStorage();
            },

            categorizeFile(fileName) {
                const name = this.normalizeFileName(fileName);
                if (name.startsWith(this.filePrefixes.mayor)) {
                    return 'mayor';
                } else if (name.startsWith(this.filePrefixes.saldo)) {
                    return 'saldo';
                } else if (this.filePrefixes.extractos.some(prefix => name.startsWith(prefix))) {
                    return 'extracto';
        } else {
                    return 'otro';
                }
            },

            normalizeFileName(fileName) {
                return fileName.toUpperCase();
            },

            getFileCategoryLabel(category) {
                switch(category) {
                    case 'mayor': return 'Mayor';
                    case 'extracto': return 'Bancos';
                    case 'saldo': return 'Saldos';
                    default: return 'Archivo General';
                }
            },

            get sortedFiles() {
                const orderPriority = { 'mayor': 1, 'saldo': 2, 'extracto': 3 };
                return [...this.files].sort((a, b) => {
                    const priorityA = orderPriority[a.category] || 99;
                    const priorityB = orderPriority[b.category] || 99;
                    if (priorityA !== priorityB) {
                        return priorityA - priorityB;
                    }
                    return a.name.localeCompare(b.name);
                });
            },

            getFileIcon(category) {
                switch(category) {
                    case 'mayor': return { icon: 'fa-book', bgColor: 'bg-blue-100', textColor: 'text-blue-600' };
                    case 'extracto': return { icon: 'fa-university', bgColor: 'bg-green-100', textColor: 'text-green-600' };
                    case 'saldo': return { icon: 'fa-chart-pie', bgColor: 'bg-purple-100', textColor: 'text-purple-600' };
                    default: return { icon: 'fa-file-excel', bgColor: 'bg-gray-100', textColor: 'text-gray-600' };
                }
            },

            deleteFile(fileId) {
                if (confirm('¬øEst√°s seguro de que quieres eliminar este archivo?')) {
                    this.files = this.files.filter(file => file.id !== fileId);
                    this.showStatus('Archivo eliminado correctamente', 'success');
                    
                    // Actualizar localStorage
                    this.saveFilesToStorage();
                }
            },

            canProcessConciliation() {
                const hasMayor = this.files.some(f => f.category === 'mayor');
                const hasExtracto = this.files.some(f => f.category === 'extracto');
                return hasMayor && hasExtracto;
            },

            getMissingFilesMessage() {
                const hasMayor = this.files.some(f => f.category === 'mayor');
                const hasExtracto = this.files.some(f => f.category === 'extracto');
                
                if (!hasMayor && !hasExtracto) {
                    return 'Faltan Mayor y Extractos';
                } else if (!hasMayor) {
                    return 'Falta el archivo Mayor';
                } else if (!hasExtracto) {
                    return 'Falta al menos un Extracto Bancario';
                }
                return 'Archivos incompletos';
            },

            async realizarConciliacion() {
                if (!this.canProcessConciliation()) {
                    this.showStatus('Se necesitan al menos el Mayor Anal√≠tico y Extractos Bancarios', 'error');
                    return;
                }

                this.isLoading = true;
                this.statusMessage.show = false;
                this.conciliationResult = null;

                const fileData = {};
                const promises = this.files.map(fileObj => {
                    return new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                const data = new Uint8Array(e.target.result);
                                const workbook = XLSX.read(data, { type: 'array' });
                                const sheetName = workbook.SheetNames[0];
                                const worksheet = workbook.Sheets[sheetName];
                                const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: "" });
                                
                                if (fileObj.category === 'extracto') {
                                    if (!fileData.extractos) {
                                        fileData.extractos = [];
                                    }
                                    
                                    // Identificar la cuenta de origen
                                    const fileNameUpper = fileObj.name.toUpperCase();
                                    const prefix = this.filePrefixes.extractos.find(p => fileNameUpper.startsWith(p));
                                    const cuentaOrigen = this.extractoAccountMap[prefix] || 'DESCONOCIDA';
                                    
                                    // A√±adir la columna CUENTA_ORIGEN a los datos del extracto
                                    // Configuraci√≥n espec√≠fica por banco para headers
                                    const headerRowConfigCarga = {
                                        '1041501': 4, '1041505': 4, '1041401': 7, '1041201': 4,
                                        '1041301': 4, '1041101': 4, '1042101': 4, '1041601': 4
                                    };
                                    
                                    const headerRowIndexCarga = headerRowConfigCarga[cuentaOrigen] || 4;
                                    
                                    console.log(`üîç CARGA DEBUG: Archivo ${fileObj.name}, cuenta=${cuentaOrigen}, headerRowIndex=${headerRowIndexCarga}`);
                                    
                                    if (jsonData.length > headerRowIndexCarga) {
                                        // A√±adir CUENTA_ORIGEN al header espec√≠fico del banco
                                        if (jsonData[headerRowIndexCarga]) {
                                            jsonData[headerRowIndexCarga].push('CUENTA_ORIGEN');
                                            console.log(`‚úÖ CARGA: Header CUENTA_ORIGEN a√±adido en fila ${headerRowIndexCarga + 1} para ${cuentaOrigen}`);
                                        }
                                        
                                        // A√±adir cuenta a todas las filas de datos desde la correcta
                                        const dataStartIndexCarga = headerRowIndexCarga + 1;
                                        for (let i = dataStartIndexCarga; i < jsonData.length; i++) {
                                            if (jsonData[i]) {
                                            jsonData[i].push(cuentaOrigen);
                                        }
                                        }
                                        console.log(`‚úÖ CARGA: CUENTA_ORIGEN ${cuentaOrigen} a√±adida a ${jsonData.length - dataStartIndexCarga} filas de datos`);
                                    }
                                    
                                    fileData.extractos.push({ name: fileObj.name, data: jsonData });
                                } else {
                                    fileData[fileObj.category] = jsonData;
                                }
                                resolve();
                            } catch (err) {
                                reject(new Error(`Error procesando ${fileObj.name}: ${err.message}`));
                            }
                        };
                        reader.onerror = reject;
                        reader.readAsArrayBuffer(fileObj.file);
                    });
                });

                try {
                    await Promise.all(promises);

                    // Consolidar todos los extractos en uno solo Y organizar por cuenta
                    let datosExtractoConsolidado = [];
                    let extractosPorCuenta = {};
                    
                    if (fileData.extractos && fileData.extractos.length > 0) {
                        // Tomar la cabecera del primer extracto
                        const header = fileData.extractos[0].data.slice(0, 5);
                        datosExtractoConsolidado.push(...header);

                        // Concatenar los datos (a partir de la fila 6) de todos los extractos
                        fileData.extractos.forEach(extracto => {
                            datosExtractoConsolidado.push(...extracto.data.slice(5));
                            
                            // Tambi√©n organizar por cuenta para el Excel con configuraci√≥n espec√≠fica por banco
                            if (extracto.data.length > 4) {
                                // Detectar cuenta del extracto para usar configuraci√≥n espec√≠fica
                                let cuentaExtracto = '';
                                if (extracto.data.length > 4) {
                                    // Buscar en m√∫ltiples filas para m√°xima compatibilidad
                                    for (let i = 4; i < Math.min(extracto.data.length, 10); i++) {
                                        const fila = extracto.data[i];
                                        if (fila && fila.length > 0) {
                                            const ultimaColumna = fila[fila.length - 1];
                                            if (ultimaColumna && typeof ultimaColumna === 'string' && ultimaColumna.match(/^104\d{4}$/)) {
                                                cuentaExtracto = ultimaColumna;
                                                console.log(`üîç DEBUG: Cuenta detectada ${cuentaExtracto} en fila ${i + 1}`);
                                                break;
                                            }
                                        }
                                    }
                                }
                                
                                // Si no se detect√≥ cuenta, intentar buscar en toda la estructura
                                if (!cuentaExtracto) {
                                    console.warn(`‚ö†Ô∏è Intento alternativo de detecci√≥n de cuenta...`);
                                    for (let i = 0; i < Math.min(extracto.data.length, 15); i++) {
                                        const fila = extracto.data[i];
                                        if (fila && fila.length > 0) {
                                            for (let j = 0; j < fila.length; j++) {
                                                const celda = fila[j];
                                                if (celda && typeof celda === 'string' && celda.match(/^104\d{4}$/)) {
                                                    cuentaExtracto = celda;
                                                    console.log(`üîç DEBUG ALTERNATIVO: Cuenta ${cuentaExtracto} encontrada en fila ${i + 1}, columna ${j + 1}`);
                                                    break;
                                                }
                                            }
                                            if (cuentaExtracto) break;
                                        }
                                    }
                                }
                                
                                if (!cuentaExtracto) {
                                    console.error(`‚ùå No se pudo detectar cuenta del extracto en ninguna parte`);
                                    // Mostrar primeras filas para debug
                                    console.log(`üîç DEBUG: Primeras 5 filas del extracto:`, extracto.data.slice(0, 5));
                                }
                                
                                // Configuraci√≥n espec√≠fica de headers por banco
                                const headerRowConfigLocal = {
                                    '1041501': 4, '1041505': 4, '1041401': 7, '1041201': 4,
                                    '1041301': 4, '1041101': 4, '1042101': 4, '1041601': 4
                                };
                                
                                const headerRowIndex = headerRowConfigLocal[cuentaExtracto] || 4;
                                const dataStartIndex = headerRowIndex + 1;
                                
                                // Header del extracto (usando configuraci√≥n espec√≠fica) SIN CUENTA_ORIGEN + columnas ESTADO y #REF
                                const headerOriginal = extracto.data[headerRowIndex] || [];
                                const headerSinCuentaOrigen = headerOriginal.filter((col, idx) => col !== 'CUENTA_ORIGEN');
                                const headerConEstados = [...headerSinCuentaOrigen, 'ESTADO', '#REF'];
                                
                                console.log(`üîç HEADER DEBUG: Detectando cuenta principal del extracto...`);
                                
                                // Datos del extracto (desde fila espec√≠fica seg√∫n banco)
                                const extractoData = extracto.data.slice(dataStartIndex);
                                const cuentaOrigenIndex = headerOriginal.indexOf('CUENTA_ORIGEN');
                                
                                console.log(`üîç DEBUG: Procesando extracto cuenta ${cuentaExtracto}, headerRowIndex=${headerRowIndex}, dataStartIndex=${dataStartIndex}`);
                                console.log(`üîç DEBUG: cuentaOrigenIndex=${cuentaOrigenIndex}, extractoData.length=${extractoData.length}`);
                                console.log(`üîç DEBUG: headerOriginal:`, headerOriginal);
                                console.log(`üîç DEBUG: headerConEstados:`, headerConEstados);
                                
                                if (cuentaOrigenIndex !== -1 && extractoData.length > 0) {
                                    extractoData.forEach((fila, idx) => {
                                        const cuenta = fila[cuentaOrigenIndex];
                                        if (cuenta && cuenta !== 'DESCONOCIDA') {
                                            if (!extractosPorCuenta[cuenta]) {
                                                extractosPorCuenta[cuenta] = [headerConEstados]; // Header con ESTADO y #REF
                                                console.log(`‚úÖ DEBUG: Creada pesta√±a para cuenta ${cuenta}`);
                                                
                                                // Log espec√≠fico para SANT
                                                if (cuenta === '1041401') {
                                                    console.log(`üéØ SANT DEBUG: Creando pesta√±a para SANT (1041401)`);
                                                    console.log(`üéØ SANT HEADER:`, headerConEstados);
                                                }
                                            }
                                            
                                            // Fila SIN CUENTA_ORIGEN + ESTADO y #REF (todas las columnas)
                                            const filaSinCuentaOrigen = fila.filter((col, idx) => idx !== cuentaOrigenIndex);
                                            const filaConEstados = [...filaSinCuentaOrigen, 'Pendiente', ''];
                                            extractosPorCuenta[cuenta].push(filaConEstados);
                                            
                                            // Log solo para las primeras filas de SANT
                                            if (cuenta === '1041401' && idx < 3) {
                                                console.log(`üîç DEBUG SANT fila ${idx + 1}:`, filaSinCuentaOrigen.slice(0, 5));
                                            }
                                        }
                                    });
                                } else {
                                    console.warn(`‚ö†Ô∏è No se pudieron procesar datos para cuenta ${cuentaExtracto}: cuentaOrigenIndex=${cuentaOrigenIndex}, extractoData.length=${extractoData.length}`);
                                }
                            }
                        });
                    }

                    // DEBUG: Mostrar pesta√±as creadas
                    console.log(`üìä DEBUG: Pesta√±as creadas:`, Object.keys(extractosPorCuenta));
                    Object.keys(extractosPorCuenta).forEach(cuenta => {
                        const filas = extractosPorCuenta[cuenta].length;
                        console.log(`   ${cuenta}: ${filas} filas (incluyendo header)`);
                        
                        // Debug espec√≠fico para SANT
                        if (cuenta === '1041401') {
                            console.log(`üéØ SANT FINAL: ${filas} filas encontradas para SANT`);
                            if (filas > 1) {
                                console.log(`üéØ SANT SAMPLE:`, extractosPorCuenta[cuenta][1]?.slice(0, 5));
                            }
                        }
                    });

                    const result = this.procesarConciliacion(
                        datosExtractoConsolidado,
                        fileData.mayor, 
                        fileData.saldo
                    );

                    // Agregar extractos organizados por cuenta al resultado Y aplicar estados
                    if (result) {
                        // Aplicar estados de conciliaci√≥n a los extractos por cuenta
                        if (result.estadosExtracto && extractosPorCuenta) {
                            this.aplicarEstadosAExtractosPorCuenta(extractosPorCuenta, result.estadosExtracto, datosExtractoConsolidado);
                        }
                        result.extractosPorCuenta = extractosPorCuenta;
                        
                        // DEBUG: Verificar transferencia de extractosPorCuenta a result
                        console.log(`üîÑ TRANSFER DEBUG: Asignando extractosPorCuenta a result`);
                        console.log(`üîç DEBUG FINAL: extractosPorCuenta keys:`, Object.keys(extractosPorCuenta));
                        console.log(`üîç DEBUG RESULT: result.extractosPorCuenta keys:`, Object.keys(result.extractosPorCuenta));
                        
                        if (extractosPorCuenta['1041401']) {
                            console.log(`‚úÖ SANT encontrado en extractosPorCuenta original: ${extractosPorCuenta['1041401'].length} filas`);
                        } else {
                            console.log(`‚ùå SANT NO encontrado en extractosPorCuenta original`);
                        }
                        
                        if (result.extractosPorCuenta['1041401']) {
                            console.log(`‚úÖ SANT encontrado en result.extractosPorCuenta: ${result.extractosPorCuenta['1041401'].length} filas`);
                        } else {
                            console.log(`‚ùå SANT NO encontrado en result.extractosPorCuenta`);
                        }
                    }
                    
                    this.conciliationResult = result;
                    this.showStatus('Conciliaci√≥n completada exitosamente', 'success');
                 } catch (error) {
                    console.error("Error en la conciliaci√≥n:", error);
                    this.showStatus(error.message, 'error');
                } finally {
                    this.isLoading = false;
                }
            },



            readExcelFile(file) {
         return new Promise((resolve, reject) => {
             const reader = new FileReader();
             reader.onload = function(e) {
                 try {
                     const data = new Uint8Array(e.target.result);
                     const workbook = XLSX.read(data, { type: 'array' });
                     const sheetName = workbook.SheetNames[0];
                     const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: "" });
                     resolve(jsonData);
                 } catch (error) {
                     reject(error);
                 }
             };
             reader.onerror = () => reject(new Error('Error al leer el archivo'));
             reader.readAsArrayBuffer(file);
         });
            },



            getFileType(fileName) {
                const extension = fileName.split('.').pop().toLowerCase();
                return extension.toUpperCase();
            },

            getFileCategory(fileName) {
                const name = fileName.toLowerCase();
                if (name.includes('mayor') || name.includes('analitico')) {
                    return 'Mayor Anal√≠tico';
                } else if (name.includes('extracto') || name.includes('banco')) {
                    return 'Extractos Bancarios';
                } else if (name.includes('resumen') || name.includes('saldo')) {
                    return 'Resumen de Saldos';
                } else {
                    return 'Archivo General';
                }
            },

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            },

            formatResultKey(key) {
                const labels = {
                    fecha: 'Fecha de Conciliaci√≥n',
                    archivo_generado: 'Archivo Generado',
                    registros_procesados: 'Registros Procesados'
                };
                return labels[key] || key.replace(/_/g, ' ').toUpperCase();
            },

            formatResultValue(key, value) {
                if (key === 'fecha') {
                    return new Date(value).toLocaleString();
                }
                return value;
            },

            showStatus(message, type) {
                this.statusMessage = {
                    show: true,
                    text: message,
                    type: type
                };

                setTimeout(() => {
                    this.statusMessage.show = false;
                }, 5000);
            },

            async descargarConciliacion() {
                if (!this.conciliationResult) return;
                const fileName = `conciliacion_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.xlsx`;
                this.generateExcelFile(this.conciliationResult, fileName);
            },

            aplicarEstadosAExtractosPorCuenta(extractosPorCuenta, estadosExtracto, datosExtractoConsolidado) {
                /*
                CORREGIDO: Aplica los estados de conciliaci√≥n del extracto consolidado a los extractos por cuenta individual.
                SOLUCI√ìN: Transferencia directa por √≠ndice en lugar de comparaci√≥n compleja de filas.
                */
                
                if (!estadosExtracto || estadosExtracto.size === 0) {
                    console.log(`üîß APLICAR ESTADOS: No hay estados disponibles para aplicar`);
                    return;
                }
                
                console.log(`üîß APLICAR ESTADOS: Iniciando transferencia para ${Object.keys(extractosPorCuenta).length} cuentas`);
                console.log(`üîß Estados disponibles: ${estadosExtracto.size}`);
                
                // SOLUCI√ìN: Transferencia directa por √≠ndice
                for (const cuenta in extractosPorCuenta) {
                    const extractoCuenta = extractosPorCuenta[cuenta];
                    if (!extractoCuenta || extractoCuenta.length <= 1) continue; // Solo header
                    
                    let estadosAplicados = 0;
                    console.log(`üîß Procesando cuenta ${cuenta} con ${extractoCuenta.length - 1} filas de datos`);
                    
                    // Aplicar estados directamente por √≠ndice (saltando header)
                    estadosExtracto.forEach((estadoInfo, idxExtracto) => {
                        const indiceFilaDatos = idxExtracto + 1; // +1 para saltar header
                        
                        if (indiceFilaDatos < extractoCuenta.length) {
                            const fila = extractoCuenta[indiceFilaDatos];
                            
                            // Verificar que la fila pertenece a esta cuenta
                            if (fila && fila.length > 0) {
                                // Actualizar ESTADO y #REF (√∫ltimas 2 columnas)
                                const ultimaCol = fila.length - 1;
                                fila[ultimaCol - 1] = estadoInfo.estado; // ESTADO
                                fila[ultimaCol] = estadoInfo.ref; // #REF
                                estadosAplicados++;
                                
                                // Debug espec√≠fico para BCP.01 y BCP.02
                                if (cuenta === '1041501' || cuenta === '1041505') {
                                    console.log(`‚úÖ ${cuenta}: Estado aplicado en fila ${indiceFilaDatos} - ${estadoInfo.estado} | ${estadoInfo.ref}`);
                                }
                            }
                        }
                    });
                    
                    console.log(`‚úÖ Cuenta ${cuenta}: ${estadosAplicados} estados aplicados exitosamente`);
                    
                    // Debug espec√≠fico para BCP.01 y BCP.02
                    if (cuenta === '1041501' || cuenta === '1041505') {
                        if (estadosAplicados === 0) {
                            console.log(`‚ö†Ô∏è ${cuenta}: No se pudieron aplicar estados. Verificar estructura de datos.`);
                        } else {
                            console.log(`üéØ ${cuenta}: Estados aplicados correctamente. Proceso exitoso.`);
                        }
                    }
                }
            },

            compararFilasExtracto(filaConsolidada, filaExtractoCuenta, cuentaOrigenIndex) {
                /*
                Compara si dos filas de extracto son la misma (excluyendo CUENTA_ORIGEN y columnas de estado)
                MEJORADO: Comparaci√≥n m√°s robusta para BCP.01 y BCP.02
                */
                if (!filaConsolidada || !filaExtractoCuenta) return false;
                
                // Comparar las primeras columnas principales (fecha, monto, descripci√≥n, etc.)
                const columnasAComparar = Math.min(filaConsolidada.length - 1, filaExtractoCuenta.length - 2); // Excluir estado/ref
                
                // Para BCP.01 y BCP.02, usar comparaci√≥n m√°s flexible
                let coincidencias = 0;
                let totalColumnas = 0;
                
                for (let i = 0; i < columnasAComparar; i++) {
                    if (i === cuentaOrigenIndex) continue; // Saltar CUENTA_ORIGEN
                    
                    const val1 = (filaConsolidada[i] || '').toString().trim();
                    const val2 = (filaExtractoCuenta[i] || '').toString().trim();
                    
                    totalColumnas++;
                    
                    // Comparaci√≥n exacta para columnas cr√≠ticas (fecha, monto)
                    if (i === 0 || i === 3) { // Fecha (col 0) y Monto (col 3)
                        if (val1 === val2) {
                            coincidencias++;
                        }
                    } else {
                        // Para otras columnas, permitir variaciones menores
                        if (val1 === val2 || val1.includes(val2) || val2.includes(val1)) {
                            coincidencias++;
                        }
                    }
                }
                
                // Requerir al menos 80% de coincidencias para considerar filas iguales
                const porcentajeCoincidencia = totalColumnas > 0 ? (coincidencias / totalColumnas) * 100 : 0;
                const esCoincidencia = porcentajeCoincidencia >= 80;
                
                // Debug para BCP.01 y BCP.02
                if (esCoincidencia && (filaConsolidada[cuentaOrigenIndex] === '1041501' || filaConsolidada[cuentaOrigenIndex] === '1041505')) {
                    console.log(`üîç COMPARACI√ìN BCP: ${coincidencias}/${totalColumnas} columnas coinciden (${porcentajeCoincidencia.toFixed(1)}%)`);
                }
                
                return esCoincidencia;
            },

            getCuentaSheetName(cuenta) {
                // Mapear n√∫meros de cuenta a nombres de hojas (orden seg√∫n nomenclatura_archivos.md)
                const mapaCuentas = {
                    '1041501': 'BCP.01',  // BCO DE CREDITO M/N
                    '1041505': 'BCP.02',  // BCO DE CREDITO M/N
                    '1041401': 'SANT',    // BCO. SANTANDER M/N
                    '1041201': 'BBVA',    // CONTINENTAL M/N
                    '1041301': 'SBP',     // SCOTIABANK MN
                    '1041101': 'IBK',     // INTERBANK M/N
                    '1042101': 'DET',     // BCO. DE LA NACION DET M/N
                    '1041601': 'BN'       // BCO. DE LA NACION M/N
                };
                return mapaCuentas[cuenta] || `CUENTA_${cuenta}`;
            },

            generateExcelFile(datosCompletos, fileName) {
                try {
                    const wb = XLSX.utils.book_new();

                    // HOJA 1: MAYOR
                    if (datosCompletos.datosMayor && datosCompletos.datosMayor.length > 0) {
                        const wsMayor = XLSX.utils.aoa_to_sheet(datosCompletos.datosMayor);
                        XLSX.utils.book_append_sheet(wb, wsMayor, "MAYOR");
                    }

                    // HOJAS DE EXTRACTOS (UNA POR CUENTA) - En orden espec√≠fico seg√∫n nomenclatura_archivos.md
                    if (datosCompletos.extractosPorCuenta) {
                        // Orden espec√≠fico de cuentas seg√∫n nomenclatura_archivos.md
                        const ordenCuentas = [
                            '1041501', // BCP.01
                            '1041505', // BCP.02  
                            '1041401', // SANT
                            '1041201', // BBVA
                            '1041301', // SBP
                            '1041101', // IBK
                            '1042101', // DET
                            '1041601'  // BN
                        ];
                        
                        // Agregar pesta√±as en orden espec√≠fico
                        for (const cuenta of ordenCuentas) {
                            console.log(`üîç EXCEL DEBUG: Procesando cuenta ${cuenta}`);
                            
                            if (datosCompletos.extractosPorCuenta[cuenta]) {
                                const sheetName = this.getCuentaSheetName(cuenta);
                                const datosHoja = datosCompletos.extractosPorCuenta[cuenta];
                                
                                console.log(`‚úÖ EXCEL: Cuenta ${cuenta} encontrada, sheetName=${sheetName}, filas=${datosHoja ? datosHoja.length : 0}`);
                                
                                if (datosHoja && datosHoja.length > 0) {
                                    const ws = XLSX.utils.aoa_to_sheet(datosHoja);
                                    XLSX.utils.book_append_sheet(wb, ws, sheetName);
                                    console.log(`üìä EXCEL: Pesta√±a "${sheetName}" creada con ${datosHoja.length} filas`);
                                } else {
                                    console.log(`‚ùå EXCEL: Cuenta ${cuenta} sin datos (length=${datosHoja ? datosHoja.length : 'null'})`);
                                }
                            } else {
                                console.log(`‚ùå EXCEL: Cuenta ${cuenta} NO encontrada en extractosPorCuenta`);
                                
                                // Debug espec√≠fico para SANT
                                if (cuenta === '1041401') {
                                    console.log(`üîç DEBUG SANT: Keys disponibles:`, Object.keys(datosCompletos.extractosPorCuenta || {}));
                                }
                            }
                        }
                    }
                    
                    // HOJA FINAL: SALDO
                    if (datosCompletos.datosSaldo && datosCompletos.datosSaldo.length > 0) {
                        const wsSaldo = XLSX.utils.aoa_to_sheet(datosCompletos.datosSaldo);
                        XLSX.utils.book_append_sheet(wb, wsSaldo, "SALDO");
                    }
                    
                    const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
                    const blob = new Blob([wbout], { type: 'application/octet-stream' });
                    const url = window.URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = fileName;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    
                    window.URL.revokeObjectURL(url);
                    this.showStatus(`Archivo ${fileName} generado correctamente.`, 'success');

                } catch (error) {
                    console.error('Error generando Excel:', error);
                    this.showStatus(`Error al generar el archivo Excel: ${error.message}`, 'error');
                }
            },

    // --- L√≥gica de Conciliaci√≥n Principal (mantenida del c√≥digo original) ---
            procesarConciliacion(datosExtracto, datosMayor, datosSaldo = null) {
        // // console.log("=== INICIANDO CONCILIACI√ìN ===");
        // // console.log(`üìä Extracto: ${datosExtracto.length} filas | Mayor: ${datosMayor.length} filas`);

        // --- MAPEO DE √çNDICES ---
        const headersMayorRow = datosMayor.length > 1 ? datosMayor[1] : [];
        
        // // console.log(`üìã HEADERS MAYOR (fila 2):`, headersMayorRow);
        // // console.log(`   Total de columnas en header: ${headersMayorRow.length}`);
                const indicesMayor = this.buscarIndicesColumnas(headersMayorRow, {
            cuenta: ['CUENTA'], glosa: ['GLOSA'], paso: ['PASO'], fdoc: ['FDOC', 'FECHA'],
            debe: ['DEBE'], haber: ['HABER'], numdoc: ['NUMDOC'], libro: ['LIBRO'], 
            desTdop: ['DES_TDOP'], comprob: ['COMPROB']
        });

        // Configuraci√≥n espec√≠fica de fila de headers por banco
        const headerRowConfig = {
            '1041501': 4, // BCP.01 - header en fila 5 (√≠ndice 4)
            '1041505': 4, // BCP.02 - header en fila 5 (√≠ndice 4)
            '1041401': 7, // SANT - header en fila 8 (√≠ndice 7)
            '1041201': 4, // BBVA - header en fila 5 (√≠ndice 4)
            '1041301': 4, // SBP - header en fila 5 (√≠ndice 4)
            '1041101': 4, // IBK - header en fila 5 (√≠ndice 4)
            '1042101': 4, // DET - header en fila 5 (√≠ndice 4)
            '1041601': 4  // BN - header en fila 5 (√≠ndice 4)
        };
        
        // Determinar la cuenta del extracto para obtener la fila de headers correcta
        // Buscar en las filas de datos (despu√©s del header) para encontrar CUENTA_ORIGEN
        let cuentaExtracto = '';
        if (datosExtracto.length > 5) {
            // Buscar CUENTA_ORIGEN en las filas de datos (√≠ndice 5 en adelante)
            for (let i = 5; i < Math.min(datosExtracto.length, 10); i++) {
                const fila = datosExtracto[i];
                if (fila && fila.length > 0) {
                    const ultimaColumna = fila[fila.length - 1];
                    if (ultimaColumna && typeof ultimaColumna === 'string' && ultimaColumna.match(/^104\d{4}$/)) {
                        cuentaExtracto = ultimaColumna;
                        break;
                    }
                }
            }
        }
        
        const headerRowIndex = headerRowConfig[cuentaExtracto] || 4; // Default a fila 5 (√≠ndice 4)
        
        console.log(`üîç DEBUG SANT - Cuenta detectada: "${cuentaExtracto}", Header row index: ${headerRowIndex}`);
        
        const headersExtracto = datosExtracto.length > headerRowIndex ? datosExtracto[headerRowIndex] : [];
                // MATRIZ FIJA - BCP como referencia, otros bancos homologados a BCP
                // Estructura BCP base: fecha=0, descripcion=2, monto=3, operacion=6
                const indicesMatrizFija = {
                    // BCP.01 y BCP.02 (estructura base)
                    '1041501': { fecha: 0, descripcion: 2, monto: 3, operacion: 6 },
                    '1041505': { fecha: 0, descripcion: 2, monto: 3, operacion: 6 },
                    
                    // SANT - Homologado a estructura BCP (headers en fila 8)
                    '1041401': { fecha: 0, descripcion: 2, monto: 6, operacion: 9 },
                    
                    // Otros bancos - Homologados a estructura BCP  
                    '1041201': { fecha: 0, descripcion: 2, monto: 3, operacion: 6 }, // BBVA
                    '1041301': { fecha: 0, descripcion: 2, monto: 3, operacion: 6 }, // SBP
                    '1041101': { fecha: 0, descripcion: 2, monto: 3, operacion: 6 }, // IBK
                    '1042101': { fecha: 0, descripcion: 2, monto: 3, operacion: 6 }, // DET
                    '1041601': { fecha: 0, descripcion: 2, monto: 3, operacion: 6 }  // BN
                };
                
                // Usar √≠ndices fijos en lugar de b√∫squeda din√°mica
                const indicesExtracto = indicesMatrizFija[cuentaExtracto] || indicesMatrizFija['1041501']; // Default a BCP
                
                console.log(`üîß MATRIZ FIJA - Cuenta: ${cuentaExtracto}`);
                console.log(`üîß √çndices asignados:`, indicesExtracto);
        
        // DEBUG: Mostrar headers detectados y mapeo de columnas
        console.log(`üîç DEBUG MAPEO - Cuenta detectada: "${cuentaExtracto}"`);
        console.log(`üîç DEBUG MAPEO - Headers extra√≠dos:`, headersExtracto);
        console.log(`üîç DEBUG MAPEO - √çndices Mayor:`, indicesMayor);
        console.log(`üìã Archivo Saldo disponible: ${datosSaldo ? 'S√ç' : 'NO'} ${datosSaldo ? '(' + datosSaldo.length + ' filas)' : ''}`);
        
        // Verificar si los √≠ndices cr√≠ticos est√°n mapeados correctamente
        const indiceCriticos = ['fecha', 'monto', 'operacion', 'descripcion'];
        const indicesValidos = indiceCriticos.every(key => indicesExtracto[key] !== undefined && indicesExtracto[key] !== -1);
        console.log(`üîç DEBUG MAPEO - ¬ø√çndices cr√≠ticos v√°lidos? ${indicesValidos ? '‚úÖ S√ç' : '‚ùå NO'}`);
        if (!indicesValidos) {
            indiceCriticos.forEach(key => {
                const valor = indicesExtracto[key];
                console.log(`   ${key}: ${valor} ${valor === undefined || valor === -1 ? '‚ùå' : '‚úÖ'}`);
            });
        }
        
        // --- ESTRUCTURA GLOBAL PARA ESTADOS DEL SALDO ---
        let estadosSaldo = new Map();
        // Inicializar estados del saldo si hay datos
        if (datosSaldo && datosSaldo.length > 1) {
            const filasSaldo = datosSaldo.slice(1);
            for (let i = 0; i < filasSaldo.length; i++) {
                estadosSaldo.set(i, { estado: 'Pendiente', ref: '' });
            }
            // // console.log(`üìä Inicializado estadosSaldo con ${estadosSaldo.size} entradas`);
        }
        
        // VERIFICAR QUE LOS √çNDICES CR√çTICOS EST√âN BIEN MAPEADOS
        const indicesCriticos = ['numdoc', 'glosa', 'debe', 'haber', 'comprob'];
        indicesCriticos.forEach(campo => {
            if (indicesMayor[campo] === -1) {
                // // console.log(`‚ùå ERROR: No se encontr√≥ √≠ndice para ${campo.toUpperCase()}`);
            } else {
                // // console.log(`‚úÖ ${campo.toUpperCase()} mapeado en √≠ndice ${indicesMayor[campo]}`);
            }
        });
        
        // --- FILTROS APLICADOS ---
        let dataRowsMayor = datosMayor.slice(2);
        
        // PASO 1: Filtro por Cuenta Espec√≠fica - Cuentas BCP.01 y BCP.02
        // NOTA: Procesamiento para ambas cuentas BCP siguiendo l√≥gica estable
        const cuentasBCP = ['1041501', '1041505']; // BCP.01 y BCP.02
        const totalAntesFiltro = dataRowsMayor.length;
        if (indicesMayor.cuenta !== -1) {
            dataRowsMayor = dataRowsMayor.filter(row => {
                const cuenta = String(row[indicesMayor.cuenta] || '');
                return cuentasBCP.includes(cuenta);
            });
        }
        
        // DEBUG: Mostrar resultado del filtro PASO 1
        console.log(`üîç DEBUG PASO 1 - Filtro por cuentas BCP.01 y BCP.02:`);
        console.log(`   üìä Total filas antes del filtro: ${totalAntesFiltro}`);
        console.log(`   üìä Total filas despu√©s del filtro: ${dataRowsMayor.length}`);
        console.log(`   üìã Cuentas procesadas: ${cuentasBCP.join(', ')} (BCP.01 y BCP.02)`);
        
        // Contar por cuenta
        const cuentasPorTipo = {};
        dataRowsMayor.forEach(row => {
            const cuenta = String(row[indicesMayor.cuenta] || '');
            cuentasPorTipo[cuenta] = (cuentasPorTipo[cuenta] || 0) + 1;
        });
        console.log(`   üìã Distribuci√≥n por cuenta:`, cuentasPorTipo);

        // PASO 2: Omisiones globales
        const omisiones = ['AMERICAN EXP', 'CALIDDA', 'DINERS', 'MASTER CARD', 'MERCADOPAGO', 'VISANET'];
        
        // // console.log(`üîç VERIFICACI√ìN PASO 2 - GLOSA √≠ndice: ${indicesMayor.glosa}`);
        
        if (indicesMayor.glosa !== -1) {
            const countAntesFiltro = dataRowsMayor.length;
            
            // Debug: Mostrar muestra de valores GLOSA
            // // console.log(`üîç Primeras 3 filas GLOSA antes del filtro:`);
            dataRowsMayor.slice(0, 3).forEach((fila, idx) => {
                const glosa = fila[indicesMayor.glosa] || '';
                // // console.log(`  Fila ${idx}: "${glosa}"`);
            });
            
            let filasExcluidas = 0;
            let filasOmitidasAgrupadas = {}; // Para el nuevo resumen
            const filasParaProcesar = [];

            dataRowsMayor.forEach(fila => {
                const glosa = (fila[indicesMayor.glosa] || '').toString().toUpperCase();
                const terminoCoincidente = omisiones.find(termino => glosa.startsWith(termino.toUpperCase()));

                if (terminoCoincidente) {
                    if (!filasOmitidasAgrupadas[terminoCoincidente]) {
                        filasOmitidasAgrupadas[terminoCoincidente] = { debe: 0, haber: 0, count: 0 };
                    }
                    filasOmitidasAgrupadas[terminoCoincidente].debe += this.normalizarMonto(fila[indicesMayor.debe]);
                    filasOmitidasAgrupadas[terminoCoincidente].haber += this.normalizarMonto(fila[indicesMayor.haber]);
                    filasOmitidasAgrupadas[terminoCoincidente].count++;
                    filasExcluidas++;
                } else {
                    filasParaProcesar.push(fila);
                }
            });
            
            dataRowsMayor = filasParaProcesar;

            // A√±adir las filas de resumen al final
            for (const termino in filasOmitidasAgrupadas) {
                const resumen = new Array(headersMayorRow.length).fill('');
                resumen[indicesMayor.glosa] = `RESUMEN ${termino}`;
                resumen[indicesMayor.debe] = filasOmitidasAgrupadas[termino].debe;
                resumen[indicesMayor.haber] = filasOmitidasAgrupadas[termino].haber;
                resumen[indicesMayor.libro] = 'OMISION'; // Marcar para evitar procesamiento futuro
                dataRowsMayor.push(resumen);
            }

            // // console.log(`üîß PASO 2 - Omisiones Globales: ${countAntesFiltro} ‚Üí Excluidas ${filasExcluidas} ‚Üí ${dataRowsMayor.length} filas (con res√∫menes)`);
        } else {
            // // console.log(`‚ùå PASO 2 - ERROR: Columna GLOSA no encontrada en √≠ndice ${indicesMayor.glosa}`);
            // // console.log(`üìã Headers disponibles:`, headersMayorRow);
        }
        
        // // console.log(`‚úÖ FILTROS COMPLETADOS: ${dataRowsMayor.length} ‚Üí ${dataRowsMayor.length} filas finales`)

        // Preparar extracto para conciliaci√≥n (datos empiezan despu√©s del header configurado)
        const dataStartIndex = headerRowIndex + 1; // Fila siguiente al header
        let extractoProcesable = datosExtracto.length > dataStartIndex ? 
            datosExtracto.slice(dataStartIndex).map(fila => ({ fila, conciliado: false })) : [];
        
        // DEBUG: Mostrar informaci√≥n del extracto procesable
        console.log(`üîç DEBUG EXTRACTO - Data start index: ${dataStartIndex}`);
        console.log(`üîç DEBUG EXTRACTO - Total filas procesables: ${extractoProcesable.length}`);
        if (extractoProcesable.length > 0) {
            const primeraFila = extractoProcesable[0];
            console.log(`üîç DEBUG EXTRACTO - Primera fila ejemplo:`, primeraFila.fila);
            console.log(`üîç DEBUG EXTRACTO - Cuenta de esta fila: ${primeraFila.fila[primeraFila.fila.length - 1]}`);
            console.log(`üîç DEBUG EXTRACTO - Fecha: "${primeraFila.fila[indicesExtracto.fecha]}", Monto: "${primeraFila.fila[indicesExtracto.monto]}", Operaci√≥n: "${primeraFila.fila[indicesExtracto.operacion]}"`);
        }

        // VERIFICAR CU√ÅNTAS ANULACIONES HAY EN TOTAL
        const anulacionesEncontradas = dataRowsMayor.filter(fila => {
            const glosa = fila[indicesMayor.glosa] || '';
            return glosa.toUpperCase().includes('ANULADO');
        });
        
        // // console.log(`üîç ANULACIONES DETECTADAS EN FILTRADO: ${anulacionesEncontradas.length} de ${dataRowsMayor.length} filas totales`);
        
        // Mostrar primeras 3 anulaciones como muestra
        anulacionesEncontradas.slice(0, 3).forEach((fila, idx) => {
            const numdoc = fila[indicesMayor.numdoc] || '';
            const glosa = fila[indicesMayor.glosa] || '';
            const debe = fila[indicesMayor.debe] || '';
            const haber = fila[indicesMayor.haber] || '';
            // // console.log(`   Anulaci√≥n ${idx + 1}: NUMDOC=${numdoc}, DEBE=${debe}, HABER=${haber}, GLOSA="${glosa}"`);
        });

        // --- PROCESO DE CONCILIACI√ìN ---
        const resultados = [];
        let paso3Procesados = 0;
        let paso3Conciliados = 0;
        let paso3Etapa2 = 0; // Etapa 3b: Anulado Saldo
        let paso3Etapa3 = 0; // Etapa 3c: Anulaciones en Mayor
        
        // NUEVO ENFOQUE: Mapear estados para todas las filas primero
        const estadosFilas = new Map(); // √≠ndice ‚Üí {estado, ref}
        
        for (let i = 0; i < dataRowsMayor.length; i++) {
            const filaMayor = dataRowsMayor[i];
            const glosa = filaMayor[indicesMayor.glosa] || '';
            const numdoc = filaMayor[indicesMayor.numdoc] || '';
            
            // Si ya fue procesada como parte de un par, continuar
            if (estadosFilas.has(i)) continue;
            
            // Verificar si es anulaci√≥n por GLOSA
            const esAnulacion = glosa.toUpperCase().includes('ANULADO');

            // DEBUG: Log para las primeras 3 filas de anulaciones solamente
            if (esAnulacion && paso3Procesados < 3) {
                // // console.log(`üîç DEBUG Anulaci√≥n ${paso3Procesados + 1}:`);
                // // console.log(`   NUMDOC: "${numdoc}"`);
                // // console.log(`   GLOSA: "${glosa}"`);
                // // console.log(`   √çndice en array: ${i}`);
            }
            
            if (esAnulacion) {
                paso3Procesados++;
                const resultadoPaso3 = this.procesarPaso3(filaMayor, extractoProcesable, indicesMayor, indicesExtracto, dataRowsMayor, datosSaldo, i);
                
                if (resultadoPaso3.estado) {
                    // Asignar estado a la fila actual
                    estadosFilas.set(i, {
                        estado: resultadoPaso3.estado,
                        ref: resultadoPaso3.ref || ''
                    });
                    
                    paso3Conciliados++;
                    
                    // Si hay pareja interna (ETAPA 3c), asignar estado tambi√©n a la pareja
                    if (resultadoPaso3.etapa === 3 && resultadoPaso3.indiceParejaEncontrada !== -1) {
                        const indicePareja = resultadoPaso3.indiceParejaEncontrada;
                        estadosFilas.set(indicePareja, {
                            estado: resultadoPaso3.estadoPareja,
                            ref: resultadoPaso3.refPareja
                        });
                        
                        // // console.log(`‚úÖ PASO 3c - PAR PROCESADO:`);
                        // // console.log(`   Fila ${i + 1}: ESTADO="${resultadoPaso3.estado}", REF="${resultadoPaso3.ref}"`);
                        // // console.log(`   Fila ${indicePareja + 1}: ESTADO="${resultadoPaso3.estadoPareja}", REF="${resultadoPaso3.refPareja}"`);
                        
                        paso3Conciliados++; // Contar tambi√©n la pareja
                    }
                    
                    // Contar por etapa
                    if (resultadoPaso3.etapa === 2) {
                        paso3Etapa2++; // Etapa 3b: Anulado Saldo
                        
                        // Actualizar estado del saldo si hay un match encontrado (ETAPA 3b)
                        if (resultadoPaso3.indiceParejaEncontrada !== -1 && datosSaldo && datosSaldo.length > 1) {
                            // Actualizar estado de la fila correspondiente en saldo
                            estadosSaldo.set(resultadoPaso3.indiceParejaEncontrada, {
                                estado: resultadoPaso3.estadoPareja,
                                ref: resultadoPaso3.refPareja
                            });
                            
                            // // console.log(`‚úÖ PASO 3b - SALDO ACTUALIZADO:`);
                            // // console.log(`   Saldo fila ${resultadoPaso3.indiceParejaEncontrada + 1}: ESTADO="${resultadoPaso3.estadoPareja}", REF="${resultadoPaso3.refPareja}"`);
                        }
                        
                    } else if (resultadoPaso3.etapa === 3) {
                        paso3Etapa3++; // Etapa 3c: Anulaciones en Mayor
                    }
                } else {
                    // Caso por defecto para anulados no procesados
                    estadosFilas.set(i, {
                        estado: 'Anulado Sin Procesar',
                        ref: numdoc
                    });
                }
            }
        }
        
        // PASO 4: Operaciones BNA (Banco de la Naci√≥n)
        // // console.log(`\nüè¶ INICIANDO PASO 4: Operaciones BNA`);
        // // console.log(`   üìã Extracto procesable: ${extractoProcesable.length} filas disponibles`);
        const estadosExtracto = new Map(); // Para rastrear estados del extracto
        
        const resultadosPaso4 = this.procesarPaso4(dataRowsMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto);
        // // console.log(`üìä PASO 4 COMPLETADO: ${resultadosPaso4.conciliados} conciliaciones BNA procesadas`);
        
        // PASO 5: Operaciones PROT y DEV (Agrupaci√≥n por totales diarios)
        // // console.log(`\nüìà INICIANDO PASO 5: Operaciones PROT y DEV`);
        // // console.log(`   üìã Extracto procesable: ${extractoProcesable.length} filas disponibles`);
        
        const resultadosPaso5 = this.procesarPaso5(dataRowsMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto);
        // // console.log(`üìä PASO 5 COMPLETADO: ${resultadosPaso5.conciliados} conciliaciones PROT/DEV procesadas`);
        
        // // console.log(`\nüè¶ INICIANDO PASO 6: Dep√≥sitos Bancarios`);
        // // console.log(`   üìã Extracto procesable: ${extractoProcesable.length} filas disponibles`);
        
        const resultadosPaso6 = this.procesarPaso6(dataRowsMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto);
        // // console.log(`üìä PASO 6 COMPLETADO: ${resultadosPaso6.conciliados} conciliaciones DEP√ìSITOS procesadas`);
        
        // // console.log(`\nüìã INICIANDO PASO 7: Operaciones Libro 3`);
        // // console.log(`   üìã Extracto procesable: ${extractoProcesable.length} filas disponibles`);
        
        const resultadosPaso7 = this.procesarPaso7(dataRowsMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto);
        // // console.log(`üìä PASO 7 COMPLETADO: ${resultadosPaso7.conciliados} conciliaciones LIBRO 3 procesadas`);
        
        // // console.log(`\nüìö INICIANDO PASO 8: Operaciones M√∫ltiples Libros`);
        // // console.log(`   üìã Extracto procesable: ${extractoProcesable.length} filas disponibles`);
        
        const resultadosPaso8 = this.procesarPaso8(dataRowsMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto);
        // // console.log(`üìä PASO 8 COMPLETADO: ${resultadosPaso8.conciliados} conciliaciones M√öLTIPLES LIBROS procesadas`);
        
        // // console.log(`\nüîó INICIANDO PASO 9: Operaciones M√∫ltiples Libros Agrupadas`);
        // // console.log(`   üìã Extracto procesable: ${extractoProcesable.length} filas disponibles`);
        
        const resultadosPaso9 = this.procesarPaso9(dataRowsMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto);
        // // console.log(`üìä PASO 9 COMPLETADO: ${resultadosPaso9.conciliados} conciliaciones AGRUPADAS procesadas`);
        
        // // console.log(`\nüìù INICIANDO PASO 10: Operaciones de Cheques`);
        // // console.log(`   üìã Extracto procesable: ${extractoProcesable.length} filas disponibles`);
        
        const resultadosPaso10 = this.procesarPaso10(dataRowsMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, datosSaldo, estadosSaldo);
        // // console.log(`üìä PASO 10 COMPLETADO: ${resultadosPaso10.conciliados} conciliaciones CHEQUES procesadas`);
        
        // // console.log(`\nüí∞ INICIANDO PASO 11: ITF (Impuesto a las Transacciones Financieras)`);
        // // console.log(`   üìã Extracto procesable: ${extractoProcesable.length} filas disponibles`);
        
        const resultadosPaso11 = this.procesarPaso11(dataRowsMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto);
        // // console.log(`üìä PASO 11 COMPLETADO: ${resultadosPaso11.conciliados} conciliaciones ITF procesadas`);
        
        // // console.log(`\nüéØ INICIANDO PASO 12: Conciliaci√≥n Multi-Criterio Progresiva`);
        // // console.log(`   üìã Extracto procesable: ${extractoProcesable.length} filas disponibles`);
        
        // const resultadosPaso12 = this.procesarPaso12(dataRowsMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto);
        const resultadosPaso12 = { candidatos: 0, totalConciliados: 0, etapa12a: 0, etapa12b: 0, etapa12c: 0 }; // Paso 12 desactivado
        // // console.log(`üìä PASO 12 COMPLETADO: ${resultadosPaso12.totalConciliados} conciliaciones MULTI-CRITERIO procesadas`);
        
        // Crear resultados finales con estados asignados
        for (let i = 0; i < dataRowsMayor.length; i++) {
            const filaMayor = dataRowsMayor[i];
            const estadoInfo = estadosFilas.get(i);
            
            const estadoAsignado = estadoInfo ? estadoInfo.estado : 'Pendiente';
            const refAsignada = estadoInfo ? estadoInfo.ref : '';

            // DEBUG: Para registros P5, mostrar el proceso
            if (estadoInfo && estadoInfo.estado === 'P5 - Conciliada') {
                // // console.log(`   üîß DEBUG LECTURA: √çndice ${i} ‚Üí estadoInfo.estado="${estadoInfo.estado}", estadoInfo.ref="${estadoInfo.ref}"`);
                // // console.log(`   üîß DEBUG ASIGNACI√ìN: estadoAsignado="${estadoAsignado}", refAsignada="${refAsignada}"`);
            }

            // Agregar estado y referencia a la fila
            const filaCompleta = [...filaMayor, estadoAsignado, refAsignada];
            resultados.push(filaCompleta);
            
            // LOG PARA PRIMERA FILA (solo para verificaci√≥n)
            if (resultados.length === 1) {
                // // console.log(`üîç VERIFICACI√ìN PRIMERA FILA (antes del filtrado):`);
                // // console.log(`   üìã Fila original mayor: ${filaMayor.length} columnas (ser√° filtrada a 14)`);
                // // console.log(`   üìã Fila completa: ${filaCompleta.length} columnas (se filtrar√° a 16)`);
                // // console.log(`   üìã ESTADO (pen√∫ltima): "${filaCompleta[filaCompleta.length - 2]}"`);
                // // console.log(`   üìã #REF (√∫ltima): "${filaCompleta[filaCompleta.length - 1]}"`);
                // // console.log(`   üìã Nota: Solo las primeras 14 columnas del mayor + ESTADO + #REF ir√°n al Excel final`);
            }
        }

        // USAR SOLO LAS PRIMERAS 14 COLUMNAS EST√ÅNDAR DEL MAYOR
        const columnasEstandar = [
            'DES_TDOP', 'NUMDOC', 'FDOC', 'CUO', 'LIBRO', 'COMPROB', 
            'FECHCON', 'CUENTA', 'DESCRIP', 'CODAUX', 'RAZON SOCI', 
            'GLOSA', 'DEBE', 'HABER'
        ];
        
        // Agregar las nuevas columnas al final (columnas O y P)
        const cabeceraFinal = [...columnasEstandar, 'ESTADO', '#REF'];
        
        // Filtrar solo las primeras 14 columnas de cada fila + las 2 nuevas
        const resultadosFiltrados = resultados.map(fila => {
            const filaBase = fila.slice(0, 14); // Solo primeras 14 columnas
            const estado = fila[fila.length - 2]; // ESTADO (pen√∫ltima)
            const ref = fila[fila.length - 1]; // #REF (√∫ltima)
            return [...filaBase, estado, ref];
        });
        
        const datosFinales = [cabeceraFinal, ...resultadosFiltrados];
        
        // LOG PARA VERIFICACI√ìN COMPLETA
        // // console.log(`üîç VERIFICACI√ìN DE COLUMNAS (FILTRADAS):`);
        // // console.log(`   üìã Columnas est√°ndar del mayor: ${columnasEstandar.length} columnas`);
        // // console.log(`   üìã Headers finales: ${cabeceraFinal.length} columnas (A-N + O,P)`);
        // // console.log(`   üìã Primera fila filtrada: ${resultadosFiltrados[0] ? resultadosFiltrados[0].length : 0} columnas`);
        // // console.log(`   üìã Columnas O y P del header: ["${cabeceraFinal.slice(-2).join('", "')}"]`);
        if (resultadosFiltrados[0]) {
            // // console.log(`   üìã Columnas O y P de datos: ["${resultadosFiltrados[0].slice(-2).join('", "')}"]`);
        }
        
        // MUESTRA DE PRIMERAS 3 FILAS PARA VERIFICACI√ìN
        // // console.log(`üìã MUESTRA DE DATOS FILTRADOS (primeras 3 filas):`);
        datosFinales.slice(0, 3).forEach((fila, index) => {
            if (index === 0) {
                // // console.log(`   Header (${fila.length} cols): [${fila.slice(-4).map(col => `"${col}"`).join(', ')}] (√∫ltimas 4)`);
            } else {
                // console.log(`   Fila ${index} (${fila.length} cols): [${fila.slice(-4).map(col => `"${col}"`).join(', ')}] (√∫ltimas 4)`);
            }
        });
        
        // console.log(`‚úÖ CONCILIACI√ìN COMPLETADA:`);
        // console.log(`   üìà Registros procesados: ${resultadosFiltrados.length}`);
        // console.log(`   üîç Anulaciones esperadas: ${anulacionesEncontradas.length}`);
        // // console.log(`   üîÑ Paso 3 procesados: ${paso3Procesados} | Conciliados: ${paso3Conciliados}`);
        // // console.log(`      ‚Ü≥ Etapa 3b (Anulado Saldo): ${paso3Etapa2}`);
        // // console.log(`      ‚Ü≥ Etapa 3c (Anulaciones en Mayor): ${paso3Etapa3}`);
        // console.log(`   üìä Archivo final: ${datosFinales.length} filas (incluye header) | ${cabeceraFinal.length} columnas (A-N + O,P)`);
        // console.log(`   üéØ ESTADO en columna O | #REF en columna P`);
        
        // CONTEO FINAL DE ESTADOS
        const estadosContados = {};
        resultadosFiltrados.forEach(fila => {
            const estado = fila[fila.length - 2]; // Pen√∫ltima columna (ESTADO)
            estadosContados[estado] = (estadosContados[estado] || 0) + 1;
        });
        
        // // console.log(`üè¶ PASO 4 - RESUMEN: ${resultadosPaso4.candidatos} candidatos, ${resultadosPaso4.conciliados} conciliados total`);
        // // console.log(`   üÖ∞Ô∏è Etapa 4A (BNA+Extracto): ${resultadosPaso4.etapa4a} conciliaciones`);
        // // console.log(`   üÖ±Ô∏è Etapa 4B (L04 vs L09): ${resultadosPaso4.etapa4b} conciliaciones`);
        
        // // console.log(`üìà PASO 5 - RESUMEN: ${resultadosPaso5.candidatos} candidatos, ${resultadosPaso5.grupos} grupos, ${resultadosPaso5.conciliados} conciliados`);
        // // console.log(`   üìö Agrupaci√≥n por fechas con sumas de HABER`);
        
        // // console.log(`üè¶ PASO 6 - RESUMEN: ${resultadosPaso6.candidatos} candidatos, ${resultadosPaso6.conciliados} conciliados total`);
        // // console.log(`   üÖ∞Ô∏è Etapa 6A (NUMDOC): ${resultadosPaso6.etapa6a} conciliaciones`);
        // // console.log(`   üÖ±Ô∏è Etapa 6B (FDOC+DEBE): ${resultadosPaso6.etapa6b} conciliaciones`);
        
        // // console.log(`üìã PASO 7 - RESUMEN: ${resultadosPaso7.candidatos} candidatos, ${resultadosPaso7.conciliados} conciliados total`);
        // // console.log(`   üìã Mapeo √∫nico: FDOC+DEBE vs FECHA+MONTO`);
        
        // // console.log(`üìö PASO 8 - RESUMEN: ${resultadosPaso8.candidatos} candidatos, ${resultadosPaso8.conciliados} conciliados total`);
        // // console.log(`   üìã Mapeo √∫nico: FDOC+HABER vs FECHA+|MONTO| (m√∫ltiples libros)`);
        // // console.log(`   üìà Distribuci√≥n: L03=${resultadosPaso8.libro03}, L09=${resultadosPaso8.libro09}, L14=${resultadosPaso8.libro14}, L15=${resultadosPaso8.libro15}`);
        
        // // console.log(`üîó PASO 9 - RESUMEN: ${resultadosPaso9.candidatos} candidatos, ${resultadosPaso9.grupos} grupos, ${resultadosPaso9.conciliados} conciliados`);
        // // console.log(`   üìã Agrupaci√≥n por NUMDOC con suma de TOTAL HABER (m√∫ltiples libros)`);
        // // console.log(`   üìà Distribuci√≥n: L03=${resultadosPaso9.libro03}, L09=${resultadosPaso9.libro09}, L14=${resultadosPaso9.libro14}, L15=${resultadosPaso9.libro15}`);
        
        // // console.log(`üìù PASO 10 - RESUMEN: ${resultadosPaso10.candidatos} candidatos mayor, ${resultadosPaso10.candidatosExtracto} candidatos extracto, ${resultadosPaso10.conciliados} conciliados`);
        // // console.log(`   üìù Mapeo NUMDOC+HABER vs √∫ltimos 8 chars + |MONTO| (cheques LIBRO 02)`);
        
        // // console.log(`üí∞ PASO 11 - RESUMEN: ${resultadosPaso11.candidatos} candidatos mayor, ${resultadosPaso11.candidatosExtracto} candidatos extracto, ${resultadosPaso11.conciliados} conciliados`);
        // // console.log(`   üí∞ Agrupaci√≥n global ITF: Mayor ${resultadosPaso11.totalMayor?.toFixed(2) || 0} vs Extracto ${resultadosPaso11.totalExtracto?.toFixed(2) || 0} (diferencia: ${resultadosPaso11.diferencia?.toFixed(4) || 0})`);
        
        // // console.log(`üéØ PASO 12 - RESUMEN: ${resultadosPaso12.candidatos} candidatos pendientes, ${resultadosPaso12.totalConciliados} conciliados total`);
        // console.log(`   üÖ∞Ô∏è Etapa 12A (Tolerancia ¬±5.0): ${resultadosPaso12.etapa12a} conciliaciones`);
        // console.log(`   üÖ±Ô∏è Etapa 12B (Fechas ¬±2 d√≠as): ${resultadosPaso12.etapa12b} conciliaciones`);
        // console.log(`   üÖ≤ Etapa 12C (Solo montos): ${resultadosPaso12.etapa12c} conciliaciones`);
        // console.log(`   üí∞ Estrategia progresiva: A ‚Üí B ‚Üí C (multi-criterio)`);
        
        // console.log(`üìä DISTRIBUCI√ìN DE ESTADOS:`);
        Object.entries(estadosContados).forEach(([estado, cantidad]) => {
            // console.log(`   ${estado}: ${cantidad} registros`);
        });
        
        // MOSTRAR MUESTRA DE ANULACIONES PROCESADAS
        const anulacionesProcesadas = resultadosFiltrados.filter(fila => {
            const estado = fila[fila.length - 2];
            const ref = fila[fila.length - 1];
            return estado === 'P3 - Conciliada' || estado.includes('Anulado') || estado.includes('Anula a');
        });
        
        // // console.log(`\nüîç MUESTRA DE ANULACIONES PROCESADAS (${anulacionesProcesadas.length} total):`);
        // anulacionesProcesadas.slice(0, 10).forEach((fila, idx) => {
        //     const numdoc = fila[1] || ''; // NUMDOC en √≠ndice 1
        //     const debe = fila[12] || ''; // DEBE en √≠ndice 12  
        //     const haber = fila[13] || ''; // HABER en √≠ndice 13
        //     const estado = fila[fila.length - 2]; // ESTADO
        //     const ref = fila[fila.length - 1]; // #REF
        //     // console.log(`   ${idx + 1}. NUMDOC=${numdoc}, DEBE=${debe}, HABER=${haber} ‚Üí ESTADO="${estado}", REF="${ref}"`);
        // });
        
        // MOSTRAR CASOS ESPEC√çFICOS DEL USUARIO
        const caso43335 = resultadosFiltrados.find(fila => {
            const numdoc = this.normalizarTexto(fila[1] || '');
            return numdoc === '43335';
        });
        
        const casos43676 = resultadosFiltrados.filter(fila => {
            const numdoc = this.normalizarTexto(fila[1] || '');
            return numdoc === '43676';
        });
        
        // if (caso43335) {
        //     // console.log(`\nüéØ CASO ESPEC√çFICO 00043335 (debe mapear con saldo):`);
        //     const estado = caso43335[caso43335.length - 2];
        //     const ref = caso43335[caso43335.length - 1];
        //     // console.log(`   Estado: "${estado}", REF: "${ref}"`);
        // }
        
        // if (casos43676.length > 0) {
        //     // console.log(`\nüéØ CASOS ESPEC√çFICOS 00043676 (${casos43676.length} registros, deben mapear internamente):`);
        //     casos43676.forEach((fila, idx) => {
        //         const debe = fila[12] || '';
        //         const haber = fila[13] || '';
        //         const estado = fila[fila.length - 2];
        //         const ref = fila[fila.length - 1];
        //         // console.log(`   ${idx + 1}. DEBE=${debe}, HABER=${haber} ‚Üí ESTADO="${estado}", REF="${ref}"`);
        //     });
        // }
        
        // MOSTRAR RESULTADOS DEL PASO 4
        const casosPaso4 = resultadosFiltrados.filter(fila => {
            const estado = fila[fila.length - 2];
            return estado.includes('P4 - Conciliada');
        });
        
        if (casosPaso4.length > 0) {
            // // console.log(`\nüè¶ CASOS PASO 4 - BNA (${casosPaso4.length} registros conciliados):`);
            casosPaso4.slice(0, 5).forEach((fila, idx) => {
                const fdoc = fila[2] || ''; // FDOC
                const debe = fila[12] || ''; // DEBE 
                const estado = fila[fila.length - 2];
                const ref = fila[fila.length - 1];
                // // console.log(`   ${idx + 1}. FDOC=${fdoc}, DEBE=${debe} ‚Üí ESTADO="${estado}", REF="${ref}"`);
            });
        }
        
        // MOSTRAR CASOS ESPEC√çFICOS DEL PASO 5
        const casosPaso5 = resultadosFiltrados.filter(fila => {
            const estado = fila[fila.length - 2];
            return estado.includes('P5 - Conciliada');
        });
        
        if (casosPaso5.length > 0) {
            // // console.log(`\nüìà CASOS PASO 5 - PROT/DEV (${casosPaso5.length} registros conciliados):`);
            casosPaso5.slice(0, 5).forEach((fila, idx) => {
                const fdoc = fila[2] || ''; // FDOC
                const libro = fila[4] || ''; // LIBRO
                const glosa = (fila[11] || '').substring(0, 20); // GLOSA truncada
                const haber = fila[13] || ''; // HABER 
                const estado = fila[fila.length - 2];
                const ref = fila[fila.length - 1];
                
                // DEBUG: Mostrar toda la estructura de la fila para diagnosticar
                // console.log(`   üîß DEBUG FILA ${idx + 1}: longitud=${fila.length}, estado="${estado}", ref="${ref}"`);
                // console.log(`   ${idx + 1}. FDOC=${fdoc}, LIBRO=${libro}, GLOSA="${glosa}...", HABER=${haber} ‚Üí REF="${ref}"`);
            });
        }

        // PREPARAR DATOS PARA LAS 3 HOJAS
        
        // HOJA 1: MAYOR (filas filtradas despu√©s del paso 2)
        const datosMayorHoja = [cabeceraFinal, ...resultadosFiltrados];
        
        // HOJA 2: EXTRACTO (eliminar primeras filas seg√∫n configuraci√≥n del banco + agregar ESTADO y #REF procesados)
        let datosExtractoHoja;
        if (datosExtracto.length > headerRowIndex) {
            // Header del extracto (usando configuraci√≥n espec√≠fica del banco) + columnas ESTADO y #REF
            const headerExtracto = datosExtracto[headerRowIndex] ? [...datosExtracto[headerRowIndex], 'ESTADO', '#REF'] : [];
            
            // Verificar que extractoProcesable existe y es un array
            if (extractoProcesable && Array.isArray(extractoProcesable)) {
                // Datos del extracto (desde fila siguiente al header) con estados procesados  
                // Para SANT usar dataStartIndex, para otros bancos mantener compatibilidad
                const datosExtractoSinHeader = extractoProcesable.map((item, idx) => {
                    // Verificar si esta fila fue procesada en PASO 4
                    const estadoInfo = estadosExtracto.get(idx);
                    const estado = estadoInfo ? estadoInfo.estado : 'Pendiente';
                    const ref = estadoInfo ? estadoInfo.ref : '';
                    
                    return [
                        ...item.fila, // Acceder a la fila dentro del objeto
                        estado, // ESTADO procesado
                        ref // #REF procesado
                    ];
                });
                
                datosExtractoHoja = [headerExtracto, ...datosExtractoSinHeader];
            } else {
                console.error('‚ö†Ô∏è extractoProcesable no est√° disponible, usando datos b√°sicos del extracto');
                // Fallback: usar datos b√°sicos del extracto con configuraci√≥n din√°mica
                const dataStartIndexFallback = headerRowIndex + 1;
                const datosExtractoSinHeader = datosExtracto.slice(dataStartIndexFallback).map(fila => [
                    ...fila, 
                    'Pendiente', // ESTADO por defecto
                    '' // #REF vac√≠o
                ]);
                datosExtractoHoja = [headerExtracto, ...datosExtractoSinHeader];
            }
        } else {
            datosExtractoHoja = [['Fecha', 'Fecha valuta', 'Descripci√≥n operaci√≥n', 'Monto', 'Saldo', 'Sucursal - agencia', 'Operaci√≥n - N√∫mero', 'Operaci√≥n - Hora', 'Usuario', 'UTC', 'Referencia2', 'ESTADO', '#REF']];
        }
        
        // HOJA 3: SALDO (usar datos reales si est√°n disponibles + agregar ESTADO y #REF en columna P)
        let datosSaldoHoja;
        if (datosSaldo && datosSaldo.length > 0) {
            // Header del saldo con padding hasta columna P (√≠ndice 15)
            const headerSaldoOriginal = datosSaldo[0] || [];
            const headerSaldoPadded = [...headerSaldoOriginal];
            
            // Asegurar que hay exactamente 15 columnas antes de ESTADO (columna P)
            while (headerSaldoPadded.length < 15) {
                headerSaldoPadded.push(''); // Rellenar con columnas vac√≠as
            }
            
            const headerSaldo = [...headerSaldoPadded.slice(0, 15), 'ESTADO', '#REF'];
            
            // Datos del saldo con padding hasta columna P (solo filas con datos reales)
            const datosSaldoSinHeader = datosSaldo.slice(1)
                .filter(fila => {
                    // Solo incluir filas que tengan al menos un dato no vac√≠o en las primeras columnas importantes
                    return fila && fila.some((col, idx) => {
                        if (idx > 10) return false; // Solo revisar primeras 10 columnas
                        const valor = (col || '').toString().trim();
                        return valor !== '';
                    });
                })
                .map(fila => {
                const filaPadded = [...fila];
                
                // Asegurar que hay exactamente 15 columnas antes de ESTADO
                while (filaPadded.length < 15) {
                    filaPadded.push(''); // Rellenar con datos vac√≠os
                }
                
                return [...filaPadded.slice(0, 15), 'Pendiente', ''];
            });
            
            datosSaldoHoja = [headerSaldo, ...datosSaldoSinHeader];
        } else {
            // Datos simulados si no hay archivo de saldo (15 columnas + ESTADO + #REF)
            const headerSimulado = [
                'CUENTA', 'DESCRIP', 'Banco', 'Concepto Reporte Final', 'FDOC', 
                'GLOSA 1', 'NUMDOC', 'DEBE', 'HABER', '', '', '', '', '', '', 
                'ESTADO', '#REF'
            ];
            datosSaldoHoja = [headerSimulado];
        }
        
        // --- APLICAR ESTADOS FINALES AL SALDO ---
        if (datosSaldo && datosSaldo.length > 1 && estadosSaldo.size > 0) {
            // console.log(`üìä Aplicando ${estadosSaldo.size} estados finales al saldo...`);
            this.aplicarEstadosASaldo(datosSaldoHoja, estadosSaldo);
            // console.log(`‚úÖ Estados aplicados exitosamente a datosSaldoHoja`);
        }

        // console.log(`üìä DATOS PREPARADOS PARA 3 HOJAS:`);
        // console.log(`   üìã Mayor: ${datosMayorHoja.length} filas (incluye header)`);
        // console.log(`   üìã Extracto: ${datosExtractoHoja.length} filas (incluye header)`);
        // console.log(`   üìã Saldo: ${datosSaldoHoja.length} filas ${datosSaldo ? '(datos reales)' : '(solo header simulado)'}`);

        return {
            datosMayor: datosFinales,
            datosExtracto: datosExtractoHoja,
            datosSaldo: datosSaldoHoja,
            totalProcesados: dataRowsMayor.length,
            estadosExtracto: estadosExtracto
        };
            },

            procesarPaso4(dataRowsMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 4 - OPERACIONES BNA (BANCO DE LA NACI√ìN):
                
                ETAPA 4A - MAPEO CON EXTRACTO BANCARIO:
                CRITERIOS DE FILTRADO (Mayor):
                - DES_TDOP = "Bna"
                - LIBRO = "04" (como string)
                - ESTADO = "Pendiente" (no procesados en pasos anteriores)
                
                MAPEO:
                - Mayor: FDOC + DEBE
                - Extracto: FECHA (col A) + MONTO (col D)
                
                ESTADOS RESULTANTES:
                - Mayor: "P4 - Conciliada", #REF = [Columna G del Extracto]
                - Extracto: "P4 - Conciliada", #REF = "[LIBRO]-[COMPROB]" del Mayor
                
                ETAPA 4B - MAPEO INTERNO MAYOR (LIBRO 04 vs LIBRO 09):
                CRITERIOS:
                - Filas pendientes con LIBRO = "04" (que no se mapearon en 4A)
                - Buscar coincidencia de DEBE (libro 04) vs HABER (libro 09)
                
                ESTADOS RESULTANTES:
                - Ambas filas: "P4 - Conciliada"
                - Libro 04: #REF = "09-[COMPROB del libro 09]"
                - Libro 09: #REF = "04-[COMPROB del libro 04]"
                */
                
                // // console.log(`üè¶ PASO 4: Iniciando procesamiento de operaciones BNA`);
                // // console.log(`üîç Total filas a revisar: ${dataRowsMayor.length}`);
                // // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                // ETAPA 4A - Contadores
                let candidatosBNA = 0;
                let conciliadosExtracto = 0;
                let filasPendientes = 0;
                let filasConBNA = 0;
                let filasConLibro04 = 0;
                let filasConDebe = 0;
                
                // ETAPA 4B - Contadores  
                let candidatosLibro04 = 0;
                let candidatosLibro09 = 0;
                let conciliadosInternos = 0;
                
                // =======================================================
                // ETAPA 4A: MAPEO CON EXTRACTO BANCARIO (BNA + LIBRO 04)
                // =======================================================
                // // console.log(`\nüÖ∞Ô∏è ETAPA 4A: Mapeo BNA con Extracto Bancario`);
                
                for (let i = 0; i < dataRowsMayor.length; i++) {
                    const filaMayor = dataRowsMayor[i];
                    
                    // Solo procesar si no tiene estado asignado (Pendiente)
                    if (estadosFilas.has(i)) continue;
                    filasPendientes++;
                    
                    const desTdop = filaMayor[idxM.desTdop] || '';
                    const libro = filaMayor[idxM.libro] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Debug: Mostrar las primeras 10 filas para entender el formato
                    if (i < 10) {
                        // // console.log(`üîç Fila ${i}: DES_TDOP="${desTdop}", LIBRO="${libro}", DEBE=${debe}`);
                    }
                    
                    // Verificar criterios del PASO 4
                    const esBNA = desTdop.trim().toUpperCase() === 'BNA';
                    const esLibro4 = libro.trim() === '04';
                    
                    // Contar cu√°ntas filas cumplen cada criterio
                    if (esBNA) filasConBNA++;
                    if (esLibro4) filasConLibro04++;
                    if (debe > 0) filasConDebe++;
                    
                    if (esBNA && esLibro4 && debe > 0) {
                        candidatosBNA++;
                        
                        // Normalizar fecha del Mayor para logging
                        const fdocNormalizado = this.normalizarFecha(fdoc);
                        
                        // // console.log(`üîç Candidato BNA ${candidatosBNA}:`);
                        // // console.log(`   FDOC raw: "${fdoc}" ‚Üí normalizado: "${fdocNormalizado}"`);
                        // // console.log(`   DEBE: ${debe}, LIBRO: "${libro}", COMPROB: "${comprob}"`);
                        // // console.log(`   DES_TDOP: "${desTdop}", esLibro4: ${esLibro4}`);
                        
                        // Buscar match en extracto
                        const matchExtracto = this.buscarMatchExtracto(fdoc, debe, extractoProcesable, idxE, estadosExtracto);
                        
                        if (matchExtracto.encontrado) {
                            // Asignar estados a ambos registros
                            const refMayor = matchExtracto.operacionNumero; // Columna G del extracto
                            const refExtracto = `${libro}-${comprob}`; // LIBRO-COMPROB del mayor
                            
                            estadosFilas.set(i, {
                                estado: 'P4 - Conciliada',
                                ref: refMayor
                            });
                            
                            estadosExtracto.set(matchExtracto.indice, {
                                estado: 'P4 - Conciliada',
                                ref: refExtracto
                            });
                            
                            conciliadosExtracto++;
                        } else {
                            if (candidatosBNA <= 5) {
                                // // console.log(`‚ùå No se encontr√≥ match para candidato BNA ${candidatosBNA}`);
                            }
                        }
                    }
                }
                
                // =======================================================
                // ETAPA 4B: MAPEO INTERNO MAYOR (LIBRO 04 vs LIBRO 09)
                // =======================================================
                // // console.log(`\nüÖ±Ô∏è ETAPA 4B: Mapeo interno Mayor (LIBRO 04 vs 09)`);
                
                // Buscar filas pendientes con LIBRO="04"
                for (let i = 0; i < dataRowsMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = dataRowsMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Solo filas con LIBRO="04" y DEBE > 0
                    if (libro.trim() === '04' && debe > 0) {
                        candidatosLibro04++;
                        
                        if (candidatosLibro04 <= 5) {
                            // // console.log(`üîç Candidato LIBRO 04 (${candidatosLibro04}): DEBE=${debe}, COMPROB="${comprob}"`);
                        }
                        
                        // Buscar coincidencia en LIBRO="09" con HABER similar
                        for (let j = 0; j < dataRowsMayor.length; j++) {
                            if (i === j || estadosFilas.has(j)) continue;
                            
                            const otraFila = dataRowsMayor[j];
                            const otroLibro = otraFila[idxM.libro] || '';
                            const otroHaber = this.normalizarMonto(otraFila[idxM.haber] || '0');
                            const otroComprob = otraFila[idxM.comprob] || '';
                            
                            if (otroLibro.trim() === '09' && otroHaber > 0) {
                                candidatosLibro09++;
                                
                                // Verificar coincidencia de montos (exacto)
                const diferencia = Math.abs(debe - otroHaber);
                const coincide = diferencia === 0;
                                
                                if (candidatosLibro04 <= 5 && candidatosLibro09 <= 10) {
                                    // // console.log(`   üîÑ vs LIBRO 09: HABER=${otroHaber}, diff=${diferencia.toFixed(4)} ${coincide ? '‚úÖ' : '‚ùå'}`);
                                }
                                
                                if (coincide) {
                                    // Asignar estados a ambas filas
                                    estadosFilas.set(i, {
                                        estado: 'P4 - Conciliada',
                                        ref: `09-${otroComprob}`
                                    });
                                    
                                    estadosFilas.set(j, {
                                        estado: 'P4 - Conciliada', 
                                        ref: `04-${comprob}`
                                    });
                                    
                                    conciliadosInternos++;
                                    
                                    // // console.log(`‚úÖ ETAPA 4B - CONCILIACI√ìN INTERNA EXITOSA:`);
                                    // // console.log(`   LIBRO 04 (fila ${i}): DEBE=${debe} ‚Üí REF="09-${otroComprob}"`);
                                    // // console.log(`   LIBRO 09 (fila ${j}): HABER=${otroHaber} ‚Üí REF="04-${comprob}"`);
                                    
                                    // Salir del bucle interno ya que encontramos el match
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // // console.log(`üìä PASO 4 - RESUMEN COMPLETO:`);
                // // console.log(`   üìã Filas pendientes iniciales: ${filasPendientes}`);
                // // console.log(`\nüÖ∞Ô∏è ETAPA 4A (BNA + Extracto):`);
                // // console.log(`   üè¶ Filas con DES_TDOP="Bna": ${filasConBNA}`);
                // // console.log(`   üìö Filas con LIBRO="04": ${filasConLibro04}`);
                // // console.log(`   üí∞ Filas con DEBE > 0: ${filasConDebe}`);
                // // console.log(`   ‚úÖ Candidatos BNA (todos criterios): ${candidatosBNA}`);
                // // console.log(`   üéØ Conciliaciones con extracto: ${conciliadosExtracto}`);
                // // console.log(`\nüÖ±Ô∏è ETAPA 4B (Libro 04 vs 09):`);
                // // console.log(`   üìö Candidatos LIBRO 04: ${candidatosLibro04}`);
                // // console.log(`   üìó Candidatos LIBRO 09 revisados: ${candidatosLibro09}`);
                // // console.log(`   üéØ Conciliaciones internas: ${conciliadosInternos}`);
                // // console.log(`\nüèÅ PASO 4 TOTAL: ${conciliadosExtracto + conciliadosInternos} conciliaciones`);
                
                return {
                    candidatos: candidatosBNA + candidatosLibro04,
                    conciliados: conciliadosExtracto + conciliadosInternos,
                    etapa4a: conciliadosExtracto,
                    etapa4b: conciliadosInternos
                };
            },

            procesarPaso5(dataRowsMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 5 - OPERACIONES PROT Y DEV (Agrupaci√≥n por Totales Diarios):
                
                CRITERIOS DE FILTRADO:
                - LIBRO = "04" + GLOSA inicia con "PROT" (Protestos)
                - LIBRO = "03" + GLOSA inicia con "DEV" (Devoluciones)
                - ESTADO = "Pendiente" (no procesados en pasos anteriores)
                
                ESTRATEGIA DE AGRUPACI√ìN:
                1. Agrupar por FDOC (fecha) los registros que cumplen criterios
                2. Sumar TOTAL HABER de cada grupo por fecha
                3. Mapear: FDOC del grupo + TOTAL HABER vs FECHA + |MONTO| del Extracto
                
                ESTADOS RESULTANTES:
                - Todas las filas del grupo: "P5 - Conciliada"
                - Mayor: #REF = [Operaci√≥n - N√∫mero del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del primer registro del grupo
                
                NOTA: Los montos del extracto est√°n en negativo, se usa Math.abs()
                */
                
                // // console.log(`üìà PASO 5: Iniciando procesamiento de operaciones PROT y DEV`);
                // // console.log(`üîç Total filas a revisar: ${dataRowsMayor.length}`);
                // // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                let candidatosPROT = 0;
                let candidatosDEV = 0;
                let gruposFormados = 0;
                let conciliados = 0;
                
                // Agrupar filas por FDOC que cumplan criterios
                const gruposPorFecha = new Map();
                
                // Primera pasada: Identificar candidatos y agrupar por fecha
                for (let i = 0; i < dataRowsMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = dataRowsMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Verificar criterios del PASO 5
                    const esPROT = libro.trim() === '04' && glosa.startsWith('PROT');
                    const esDEV = libro.trim() === '03' && glosa.startsWith('DEV');
                    
                    if (esPROT || esDEV) {
                        if (esPROT) candidatosPROT++;
                        if (esDEV) candidatosDEV++;
                        
                        // Debug: Mostrar los primeros 5 candidatos
                        // if ((candidatosPROT + candidatosDEV) <= 5) {
                        //     // console.log(`üîç Candidato ${candidatosPROT + candidatosDEV}: LIBRO="${libro}", GLOSA="${glosa.substring(0, 30)}...", FDOC="${fdoc}", HABER=${haber}`);
                        // }
                        
                        // Normalizar fecha para agrupaci√≥n
                        const fdocNormalizado = this.normalizarFecha(fdoc);
                        
                        if (!gruposPorFecha.has(fdocNormalizado)) {
                            gruposPorFecha.set(fdocNormalizado, {
                                fecha: fdocNormalizado,
                                fechaOriginal: fdoc,
                                totalHaber: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposPorFecha.get(fdocNormalizado);
                        grupo.totalHaber += haber;
                        grupo.filas.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            haber: haber,
                            comprob: comprob
                        });
                    }
                }
                
                gruposFormados = gruposPorFecha.size;
                // // console.log(`üìä PASO 5 - AGRUPACI√ìN:`);
                // // console.log(`   üìö Candidatos LIBRO 04 (PROT): ${candidatosPROT}`);
                // // console.log(`   üìó Candidatos LIBRO 03 (DEV): ${candidatosDEV}`);
                // // console.log(`   üìÖ Grupos por fecha formados: ${gruposFormados}`);
                
                // Segunda pasada: Buscar matches en extracto para cada grupo
                for (const [fechaNormalizada, grupo] of gruposPorFecha.entries()) {
                    // // console.log(`\nüóìÔ∏è Procesando grupo fecha: ${fechaNormalizada}`);
                    // // console.log(`   üí∞ Total HABER: ${grupo.totalHaber} (${grupo.filas.length} filas)`);
                    
                    // Buscar match en extracto
                    const matchExtracto = this.buscarMatchExtractoPorGrupo(fechaNormalizada, grupo.totalHaber, extractoProcesable, idxE, estadosExtracto);
                    
                    if (matchExtracto.encontrado) {
                        // Asignar estados a todas las filas del grupo
                        const refMayor = matchExtracto.operacionNumero;
                        const refExtracto = `${grupo.filas[0].libro}-${grupo.filas[0].comprob}`; // Usar primer registro del grupo
                        
                        // IMPORTANTE: Todas las filas del grupo reciben el MISMO n√∫mero de operaci√≥n del extracto
                        grupo.filas.forEach(item => {
                            estadosFilas.set(item.indice, {
                                estado: 'P5 - Conciliada',
                                ref: refMayor
                            });
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P5 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliados += grupo.filas.length;
                    }
                }
                
                // // console.log(`üìä PASO 5 - RESUMEN COMPLETO:`);
                // // console.log(`   üìö Candidatos PROT: ${candidatosPROT}`);
                // // console.log(`   üìó Candidatos DEV: ${candidatosDEV}`);
                // // console.log(`   üìÖ Grupos formados: ${gruposFormados}`);
                // // console.log(`   üéØ Grupos conciliados: ${conciliados}`);
                
                return {
                    candidatos: candidatosPROT + candidatosDEV,
                    grupos: gruposFormados,
                    conciliados: conciliados
                };
            },

            procesarPaso6(dataRowsMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 6 - DEP√ìSITOS BANCARIOS:
                
                CRITERIOS DE FILTRADO:
                - LIBRO = "01"
                - GLOSA contiene "DEPOSITO BANCARIO"
                - ESTADO = "Pendiente" (no procesados en pasos anteriores)
                
                ETAPA 6A - Mapeo por NUMDOC:
                1. NUMDOC (Mayor) ‚Üî Operaci√≥n - N√∫mero (Extracto col G/√≠ndice 6)
                
                ETAPA 6B - Mapeo por FDOC+DEBE:
                2. FDOC + DEBE (Mayor) ‚Üî FECHA + MONTO (Extracto)
                   - Normalizaci√≥n de fechas y montos
                   - Coincidencia exacta
                
                ESTADOS RESULTANTES:
                - Ambas etapas: "P6 - Conciliada"
                - Mayor: #REF = [Operaci√≥n - N√∫mero del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                // // console.log(`üìà PASO 6: Iniciando procesamiento de dep√≥sitos bancarios`);
                // // console.log(`üîç Total filas a revisar: ${dataRowsMayor.length}`);
                // // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                let candidatosDepositos = 0;
                let conciliadosEtapa6A = 0;
                let conciliadosEtapa6B = 0;
                
                // Identificar candidatos LIBRO="01" + GLOSA contiene "DEPOSITO BANCARIO"
                const candidatosPaso6 = [];
                
                for (let i = 0; i < dataRowsMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = dataRowsMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    
                    // Verificar criterios del PASO 6
                    const esLibro01 = libro.trim() === '01';
                    const esDepositoBancario = glosa.includes('DEPOSITO BANCARIO');
                    
                    if (esLibro01 && esDepositoBancario) {
                        candidatosDepositos++;
                        const numdoc = filaMayor[idxM.numdoc] || '';
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        const cuentaFila = filaMayor[idxM.cuenta] || '';
                        
                        // DEBUG: Log para candidatos SANT
                        if (cuentaFila === '1041401') {
                            console.log(`üîç DEBUG PASO 6 - Candidato SANT encontrado:`, {
                                indice: i, cuenta: cuentaFila, libro, glosa: glosa.substring(0, 50),
                                numdoc, fdoc, debe, comprob
                            });
                            
                            // Mostrar tambi√©n datos del extracto disponible para mapear
                            console.log(`üîç DEBUG PASO 6 - Extracto para mapear (primeras 3 filas):`, 
                                extractoProcesable.slice(0, 3).map(item => ({
                                    fecha: item.fila[idxE.fecha],
                                    monto: item.fila[idxE.monto],
                                    operacion: item.fila[idxE.operacion],
                                    descripcion: item.fila[idxE.descripcion],
                                    cuenta: item.fila[item.fila.length - 1]
                                }))
                            );
                        }
                        
                        candidatosPaso6.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            numdoc: this.normalizarTexto(numdoc),
                            fdoc: fdoc,
                            debe: debe,
                            comprob: comprob
                        });
                        
                        // Debug: Mostrar los primeros 5 candidatos
                        if (candidatosDepositos <= 5) {
                            // console.log(`üîç Candidato ${candidatosDepositos}: LIBRO="${libro}", GLOSA="${glosa.substring(0, 40)}...", NUMDOC="${numdoc}", FDOC="${fdoc}", DEBE=${debe}`);
                        }
                    }
                }
                
                // DEBUG: Resumen de candidatos por cuenta en PASO 6
                const candidatosPorCuenta = {};
                candidatosPaso6.forEach(c => {
                    const cuenta = c.fila[idxM.cuenta] || 'N/A';
                    candidatosPorCuenta[cuenta] = (candidatosPorCuenta[cuenta] || 0) + 1;
                });
                
                console.log(`üìä DEBUG PASO 6 - RESUMEN CANDIDATOS:`);
                console.log(`   üè¶ Total candidatos LIBRO 01 con DEP√ìSITO BANCARIO: ${candidatosDepositos}`);
                console.log(`   üìã Distribuci√≥n por cuenta:`, candidatosPorCuenta);
                
                if (candidatosDepositos === 0) {
                    console.log(`‚ö†Ô∏è No se encontraron candidatos para PASO 6`);
                    return { candidatos: 0, conciliados: 0, etapa6a: 0, etapa6b: 0 };
                }
                
                // ETAPA 6A: Mapeo por NUMDOC vs Operaci√≥n-N√∫mero
                // console.log(`\nüÖ∞Ô∏è ETAPA 6A: Mapeo por NUMDOC vs Operaci√≥n-N√∫mero`);
                
                for (const candidato of candidatosPaso6) {
                    // Saltar si ya fue procesado en otra etapa
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    // DEBUG: Log para SANT en ETAPA 6A
                    if (candidato.fila[idxM.cuenta] === '1041401') {
                        console.log(`üîç DEBUG PASO 6A - Procesando candidato SANT:`, {
                            indice: candidato.indice, numdoc: candidato.numdoc,
                            fdoc: candidato.fdoc, debe: candidato.debe
                        });
                    }
                    
                    // Buscar en extracto por NUMDOC vs Operaci√≥n-N√∫mero
                    const matchExtracto = this.buscarMatchPorNUMDOC(candidato.numdoc, extractoProcesable, idxE, estadosExtracto);
                    
                    if (matchExtracto.encontrado) {
                        const refMayor = matchExtracto.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P6 - Conciliada',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P6 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliadosEtapa6A++;
                        
                        // console.log(`‚úÖ ETAPA 6A - CONCILIACI√ìN EXITOSA:`);
                        // console.log(`   üìã Mayor: NUMDOC="${candidato.numdoc}", LIBRO=${candidato.libro}, COMPROB=${candidato.comprob} ‚Üí REF="${refMayor}"`);
                        // console.log(`   üìã Extracto: Operaci√≥n-N√∫mero="${matchExtracto.operacionNumero}" ‚Üí REF="${refExtracto}"`);
                    }
                }
                
                // ETAPA 6B: Mapeo por FDOC+DEBE vs FECHA+MONTO
                // console.log(`\nüÖ±Ô∏è ETAPA 6B: Mapeo por FDOC+DEBE vs FECHA+MONTO`);
                
                for (const candidato of candidatosPaso6) {
                    // Saltar si ya fue procesado en ETAPA 6A
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    // Buscar en extracto por FDOC+DEBE vs FECHA+MONTO
                    const matchExtracto = this.buscarMatchPorFechaYMonto(candidato.fdoc, candidato.debe, extractoProcesable, idxE, estadosExtracto);
                    
                    if (matchExtracto.encontrado) {
                        const refMayor = matchExtracto.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P6 - Conciliada',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P6 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliadosEtapa6B++;
                        
                        // console.log(`‚úÖ ETAPA 6B - CONCILIACI√ìN EXITOSA:`);
                        // console.log(`   üìã Mayor: FDOC="${candidato.fdoc}", DEBE=${candidato.debe} ‚Üí REF="${refMayor}"`);
                        // console.log(`   üìã Extracto: FECHA="${matchExtracto.fecha}", MONTO=${matchExtracto.monto} ‚Üí REF="${refExtracto}"`);
                    }
                }
                
                const totalConciliados = conciliadosEtapa6A + conciliadosEtapa6B;
                
                // // console.log(`üìä PASO 6 - RESUMEN COMPLETO:`);
                // console.log(`   üè¶ Candidatos DEP√ìSITOS: ${candidatosDepositos}`);
                // console.log(`   üÖ∞Ô∏è Etapa 6A (NUMDOC): ${conciliadosEtapa6A} conciliaciones`);
                // console.log(`   üÖ±Ô∏è Etapa 6B (FDOC+DEBE): ${conciliadosEtapa6B} conciliaciones`);
                // console.log(`   üéØ Total conciliados: ${totalConciliados}`);
                
                return {
                    candidatos: candidatosDepositos,
                    conciliados: totalConciliados,
                    etapa6a: conciliadosEtapa6A,
                    etapa6b: conciliadosEtapa6B
                };
            },

            buscarMatchPorNUMDOC(numdocMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                Busca un match en el extracto para ETAPA 6A:
                - Compara NUMDOC (Mayor normalizado) vs Operaci√≥n - N√∫mero (Extracto col G/√≠ndice 6)
                - Retorna datos del match si se encuentra
                */
                
                console.log(`üîç Buscando match por NUMDOC: "${numdocMayor}"`);
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    // console.log(`‚ùå Error: extractoProcesable no es v√°lido`);
                    return { encontrado: false };
                }
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    candidatosRevisados++;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const operacionNumero = filaExtracto[idxE.operacion] || ''; // Usar √≠ndice mapeado din√°micamente
                    const operacionNormalizada = this.normalizarTexto(operacionNumero);
                    
                    // Comparar NUMDOC vs Operaci√≥n-N√∫mero (ambos normalizados)
                    const coincide = numdocMayor && operacionNormalizada && numdocMayor === operacionNormalizada;
                    
                    // DEBUG: Mostrar candidatos para SANT
                    const cuentaOrigen = filaExtracto[filaExtracto.length - 1] || '';
                    if (cuentaOrigen === '1041401' && candidatosRevisados <= 5) {
                        console.log(`   üîç SANT Candidato ${candidatosRevisados}: Operaci√≥n="${operacionNumero}" ‚Üí "${operacionNormalizada}" | Match: ${coincide ? '‚úÖ' : '‚ùå'}`);
                        console.log(`      Comparando NUMDOC="${numdocMayor}" vs OP_NORM="${operacionNormalizada}"`);
                    }
                    
                    if (coincide) {
                        // console.log(`‚úÖ MATCH NUMDOC encontrado en √≠ndice ${i}`);
                        // console.log(`   üìã NUMDOC Mayor: "${numdocMayor}" ‚Üî Operaci√≥n Extracto: "${operacionNumero}"`);
                        return {
                            encontrado: true,
                            indice: i,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                // console.log(`‚ùå No se encontr√≥ match NUMDOC despu√©s de revisar ${candidatosRevisados} candidatos`);
                return { encontrado: false };
            },

            buscarMatchPorFechaYMonto(fdocMayor, debeMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                Busca un match en el extracto para ETAPA 6B:
                - Compara FDOC (Mayor) vs FECHA (Extracto col A)
                - Compara DEBE (Mayor) vs |MONTO| (Extracto col D en VALOR ABSOLUTO)
                - Retorna datos del match si se encuentra
                NOTA: Reutiliza la l√≥gica del Paso 4 con normalizaci√≥n
                */
                
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                // console.log(`üîç Buscando match por FECHA+MONTO: FDOC="${fdocMayor}" ‚Üí "${fechaMayorNormalizada}", DEBE=${debeMayor}`);
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    // console.log(`‚ùå Error: extractoProcesable no es v√°lido`);
                    return { encontrado: false };
                }
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    candidatosRevisados++;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[idxE.operacion] || ''; // Matriz fija - Operaci√≥n
                    
                    // Normalizar fecha y monto del extracto
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtractoRaw_parsed = this.normalizarMonto(montoExtractoRaw);
                    const montoExtracto = Math.abs(montoExtractoRaw_parsed); // VALOR ABSOLUTO
                    
                    // Comparar fechas y montos
                    const fechasCoinciden = fechaMayorNormalizada && fechaExtractoNormalizada && fechaMayorNormalizada === fechaExtractoNormalizada;
                    const diferenciaMonto = Math.abs(debeMayor - montoExtracto);
                    const montosCoinciden = diferenciaMonto === 0; // Exacto
                    
                    if (candidatosRevisados <= 5) {
                        // console.log(`   üîç Candidato ${candidatosRevisados}:`);
                        // console.log(`      Fecha: "${fechaExtractoRaw}" ‚Üí "${fechaExtractoNormalizada}" | Match: ${fechasCoinciden ? '‚úÖ' : '‚ùå'}`);
                        // console.log(`      Monto: ${montoExtractoRaw} ‚Üí abs(${montoExtracto}) | Diferencia: ${diferenciaMonto.toFixed(4)} | Match: ${montosCoinciden ? '‚úÖ' : '‚ùå'}`);
                    }
                    
                    if (fechasCoinciden && montosCoinciden) {
                        // console.log(`‚úÖ MATCH FECHA+MONTO encontrado en √≠ndice ${i}`);
                        // console.log(`   üìã FDOC Mayor: "${fdocMayor}" ‚Üî FECHA Extracto: "${fechaExtractoRaw}"`);
                        // console.log(`   üìã DEBE Mayor: ${debeMayor} ‚Üî |MONTO| Extracto: ${montoExtracto} (diferencia: ${diferenciaMonto.toFixed(4)})`);
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                // console.log(`‚ùå No se encontr√≥ match FECHA+MONTO despu√©s de revisar ${candidatosRevisados} candidatos`);
                return { encontrado: false };
            },

            procesarPaso7(dataRowsMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 7 - OPERACIONES LIBRO 3:
                
                CRITERIOS DE FILTRADO:
                - LIBRO = "03"
                - ESTADO = "Pendiente" (no procesados en pasos anteriores)
                
                MAPEO √öNICO:
                - FDOC + DEBE (Mayor) ‚Üî FECHA + |MONTO| (Extracto)
                - Normalizaci√≥n de fechas y montos
                - Coincidencia exacta
                
                ESTADOS RESULTANTES:
                - "P7 - Conciliada" para ambos registros
                - Mayor: #REF = [Operaci√≥n - N√∫mero del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                // // console.log(`üìà PASO 7: Iniciando procesamiento de operaciones LIBRO 3`);
                // // console.log(`üîç Total filas a revisar: ${dataRowsMayor.length}`);
                // // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                let candidatosLibro3 = 0;
                let conciliados = 0;
                
                // Identificar candidatos LIBRO="03" pendientes
                const candidatosPaso7 = [];
                
                for (let i = 0; i < dataRowsMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = dataRowsMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    
                    // Verificar criterios del PASO 7
                    const esLibro03 = libro.trim() === '03';
                    
                    if (esLibro03) {
                        candidatosLibro3++;
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosPaso7.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            fdoc: fdoc,
                            debe: debe,
                            comprob: comprob
                        });
                        
                        // Debug: Mostrar los primeros 5 candidatos
                        // if (candidatosLibro3 <= 5) {
                        //     // console.log(`üîç Candidato ${candidatosLibro3}: LIBRO="${libro}", FDOC="${fdoc}", DEBE=${debe}, COMPROB="${comprob}"`);
                        // }
                    }
                }
                
                // // console.log(`üìä PASO 7 - FILTRADO:`);
                // // console.log(`   üìã Candidatos LIBRO 03 pendientes: ${candidatosLibro3}`);
                
                if (candidatosLibro3 === 0) {
                    // // console.log(`‚ö†Ô∏è No se encontraron candidatos para PASO 7`);
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // MAPEO: FDOC+DEBE vs FECHA+MONTO
                // // console.log(`\nüìã MAPEO: FDOC+DEBE vs FECHA+MONTO`);
                
                for (const candidato of candidatosPaso7) {
                    // Saltar si ya fue procesado
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    // Buscar en extracto por FDOC+DEBE vs FECHA+MONTO (reutilizar funci√≥n del Paso 6)
                    const matchExtracto = this.buscarMatchPorFechaYMonto(candidato.fdoc, candidato.debe, extractoProcesable, idxE, estadosExtracto);
                    
                    if (matchExtracto.encontrado) {
                        const refMayor = matchExtracto.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P7 - Conciliada',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P7 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                        // // console.log(`‚úÖ PASO 7 - CONCILIACI√ìN EXITOSA:`);
                        // // console.log(`   üìã Mayor: LIBRO=${candidato.libro}, FDOC="${candidato.fdoc}", DEBE=${candidato.debe}, COMPROB=${candidato.comprob} ‚Üí REF="${refMayor}"`);
                        // // console.log(`   üìã Extracto: FECHA="${matchExtracto.fecha}", MONTO=${matchExtracto.monto} ‚Üí REF="${refExtracto}"`);
                    }
                }
                
                // // console.log(`üìä PASO 7 - RESUMEN COMPLETO:`);
                // // console.log(`   üìã Candidatos LIBRO 03: ${candidatosLibro3}`);
                // // console.log(`   üéØ Conciliados: ${conciliados}`);
                
                return {
                    candidatos: candidatosLibro3,
                    conciliados: conciliados
                };
            },

            procesarPaso8(dataRowsMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 8 - OPERACIONES M√öLTIPLES LIBROS:
                
                CRITERIOS DE FILTRADO:
                - LIBRO = "03", "09", "14", "15"
                - ESTADO = "Pendiente" (no procesados en pasos anteriores)
                
                MAPEO √öNICO:
                - FDOC + HABER (Mayor) ‚Üî FECHA + |MONTO| (Extracto)
                - Valor absoluto para monto extracto (como Paso 5)
                - Normalizaci√≥n de fechas y montos
                - Coincidencia exacta
                
                ESTADOS RESULTANTES:
                - "P8 - Conciliada" para ambos registros
                - Mayor: #REF = [Operaci√≥n - N√∫mero del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                // // console.log(`üìà PASO 8: Iniciando procesamiento de operaciones M√öLTIPLES LIBROS`);
                // // console.log(`üîç Total filas a revisar: ${dataRowsMayor.length}`);
                // // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                let candidatosLibro03 = 0;
                let candidatosLibro09 = 0;
                let candidatosLibro14 = 0;
                let candidatosLibro15 = 0;
                let conciliados = 0;
                
                // Libros objetivo del Paso 8
                const librosObjetivo = ['03', '09', '14', '15'];
                
                // Identificar candidatos de m√∫ltiples libros
                const candidatosPaso8 = [];
                
                for (let i = 0; i < dataRowsMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = dataRowsMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    
                    // Verificar criterios del PASO 8
                    const esLibroObjetivo = librosObjetivo.includes(libro.trim());
                    
                    if (esLibroObjetivo) {
                        // Contar por libro
                        if (libro.trim() === '03') candidatosLibro03++;
                        else if (libro.trim() === '09') candidatosLibro09++;
                        else if (libro.trim() === '14') candidatosLibro14++;
                        else if (libro.trim() === '15') candidatosLibro15++;
                        
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosPaso8.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            fdoc: fdoc,
                            haber: haber,
                            comprob: comprob
                        });
                        
                        // Debug: Mostrar los primeros 5 candidatos
                        // if (candidatosPaso8.length <= 5) {
                        //     // console.log(`üîç Candidato ${candidatosPaso8.length}: LIBRO="${libro}", FDOC="${fdoc}", HABER=${haber}, COMPROB="${comprob}"`);
                        // }
                    }
                }
                
                const totalCandidatos = candidatosPaso8.length;
                
                // // console.log(`üìä PASO 8 - FILTRADO:`);
                // // console.log(`   üìã Candidatos LIBRO 03: ${candidatosLibro03}`);
                // // console.log(`   üìó Candidatos LIBRO 09: ${candidatosLibro09}`);
                // // console.log(`   üìò Candidatos LIBRO 14: ${candidatosLibro14}`);
                // // console.log(`   üìô Candidatos LIBRO 15: ${candidatosLibro15}`);
                // // console.log(`   üìö Total candidatos m√∫ltiples libros: ${totalCandidatos}`);
                
                if (totalCandidatos === 0) {
                    // // console.log(`‚ö†Ô∏è No se encontraron candidatos para PASO 8`);
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // MAPEO: FDOC+HABER vs FECHA+MONTO
                // // console.log(`\nüìã MAPEO: FDOC+HABER vs FECHA+MONTO (valor absoluto)`);
                
                for (const candidato of candidatosPaso8) {
                    // Saltar si ya fue procesado
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    // Buscar en extracto por FDOC+HABER vs FECHA+MONTO
                    const matchExtracto = this.buscarMatchPorFechaYMontoHaber(candidato.fdoc, candidato.haber, extractoProcesable, idxE, estadosExtracto);
                    
                    if (matchExtracto.encontrado) {
                        const refMayor = matchExtracto.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P8 - Conciliada',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P8 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                        // // console.log(`‚úÖ PASO 8 - CONCILIACI√ìN EXITOSA:`);
                        // // console.log(`   üìã Mayor: LIBRO=${candidato.libro}, FDOC="${candidato.fdoc}", HABER=${candidato.haber}, COMPROB=${candidato.comprob} ‚Üí REF="${refMayor}"`);
                        // // console.log(`   üìã Extracto: FECHA="${matchExtracto.fecha}", |MONTO|=${matchExtracto.monto} ‚Üí REF="${refExtracto}"`);
                    }
                }
                
                // // console.log(`üìä PASO 8 - RESUMEN COMPLETO:`);
                // // console.log(`   üìö Candidatos m√∫ltiples libros: ${totalCandidatos}`);
                // // console.log(`   üéØ Conciliados: ${conciliados}`);
                // // console.log(`   üìà Distribuci√≥n: L03=${candidatosLibro03}, L09=${candidatosLibro09}, L14=${candidatosLibro14}, L15=${candidatosLibro15}`);
                
                return {
                    candidatos: totalCandidatos,
                    conciliados: conciliados,
                    libro03: candidatosLibro03,
                    libro09: candidatosLibro09,
                    libro14: candidatosLibro14,
                    libro15: candidatosLibro15
                };
            },

            buscarMatchPorFechaYMontoHaber(fdocMayor, haberMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                Busca un match en el extracto para PASO 8 (HABER):
                - Compara FDOC (Mayor) vs FECHA (Extracto col A)
                - Compara HABER (Mayor) vs |MONTO| (Extracto col D en VALOR ABSOLUTO)
                - Retorna datos del match si se encuentra
                NOTA: Similar a buscarMatchPorFechaYMonto pero usa HABER y enfatiza Math.abs()
                */
                
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                // // console.log(`üîç Buscando match por FECHA+HABER: FDOC="${fdocMayor}" ‚Üí "${fechaMayorNormalizada}", HABER=${haberMayor}`);
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    // // console.log(`‚ùå Error: extractoProcesable no es v√°lido`);
                    return { encontrado: false };
                }
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    candidatosRevisados++;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[idxE.operacion] || ''; // Matriz fija - Operaci√≥n
                    
                    // Normalizar fecha y monto del extracto
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtractoRaw_parsed = this.normalizarMonto(montoExtractoRaw);
                    const montoExtracto = Math.abs(montoExtractoRaw_parsed); // VALOR ABSOLUTO (como Paso 5)
                    
                    // Comparar fechas y montos
                    const fechasCoinciden = fechaMayorNormalizada && fechaExtractoNormalizada && fechaMayorNormalizada === fechaExtractoNormalizada;
                    const diferenciaMonto = Math.abs(haberMayor - montoExtracto);
                    const montosCoinciden = diferenciaMonto === 0; // Exacto
                    
                    // if (candidatosRevisados <= 5) {
                    //     // console.log(`   üîç Candidato ${candidatosRevisados}:`);
                    //     // console.log(`      Fecha: "${fechaExtractoRaw}" ‚Üí "${fechaExtractoNormalizada}" | Match: ${fechasCoinciden ? '‚úÖ' : '‚ùå'}`);
                    //     // console.log(`      Monto: ${montoExtractoRaw} ‚Üí abs(${montoExtracto}) | HABER=${haberMayor} | Diferencia: ${diferenciaMonto.toFixed(4)} | Match: ${montosCoinciden ? '‚úÖ' : '‚ùå'}`);
                    // }
                    
                    if (fechasCoinciden && montosCoinciden) {
                        // // console.log(`‚úÖ MATCH FECHA+HABER encontrado en √≠ndice ${i}`);
                        // // console.log(`   üìã FDOC Mayor: "${fdocMayor}" ‚Üî FECHA Extracto: "${fechaExtractoRaw}"`);
                        // // console.log(`   üìã HABER Mayor: ${haberMayor} ‚Üî |MONTO| Extracto: ${montoExtracto} (diferencia: ${diferenciaMonto.toFixed(4)})`);
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                // // console.log(`‚ùå No se encontr√≥ match FECHA+HABER despu√©s de revisar ${candidatosRevisados} candidatos`);
                return { encontrado: false };
            },

            procesarPaso9(dataRowsMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 9 - OPERACIONES M√öLTIPLES LIBROS AGRUPADAS:
                
                CRITERIOS DE FILTRADO:
                - LIBRO = "03", "09", "14", "15"
                - ESTADO = "Pendiente" (no procesados en pasos anteriores)
                
                ESTRATEGIA DE AGRUPACI√ìN:
                1. Agrupar por NUMDOC los registros que cumplen criterios
                2. Sumar TOTAL HABER de cada grupo por NUMDOC
                3. Mapear: FDOC del grupo + TOTAL HABER vs FECHA + |MONTO| del Extracto
                
                ESTADOS RESULTANTES:
                - Todas las filas del grupo: "P9 - Conciliada"
                - Mayor: #REF = [Operaci√≥n - N√∫mero del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del primer registro del grupo
                
                NOTA: Similar al Paso 5 pero agrupando por NUMDOC y con m√∫ltiples libros
                */
                
                // console.log(`üìà PASO 9: Iniciando procesamiento de operaciones M√öLTIPLES LIBROS AGRUPADAS`);
                // console.log(`üîç Total filas a revisar: ${dataRowsMayor.length}`);
                // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                let candidatosLibro03 = 0;
                let candidatosLibro09 = 0;
                let candidatosLibro14 = 0;
                let candidatosLibro15 = 0;
                let gruposFormados = 0;
                let conciliados = 0;
                
                // Libros objetivo del Paso 9
                const librosObjetivo = ['03', '09', '14', '15'];
                
                // Agrupar filas por NUMDOC que cumplan criterios
                const gruposPorNUMDOC = new Map();
                
                // Primera pasada: Identificar candidatos y agrupar por NUMDOC
                for (let i = 0; i < dataRowsMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = dataRowsMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const numdoc = filaMayor[idxM.numdoc] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Verificar criterios del PASO 9
                    const esLibroObjetivo = librosObjetivo.includes(libro.trim());
                    
                    if (esLibroObjetivo) {
                        // Contar por libro
                        if (libro.trim() === '03') candidatosLibro03++;
                        else if (libro.trim() === '09') candidatosLibro09++;
                        else if (libro.trim() === '14') candidatosLibro14++;
                        else if (libro.trim() === '15') candidatosLibro15++;
                        
                        // Debug: Mostrar los primeros 5 candidatos
                        // if ((candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15) <= 10) {
                        //     console.log(`üîç Candidato ${candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15}: LIBRO="${libro}", NUMDOC="${numdoc}", FDOC="${fdoc}", HABER=${haber}`);
                        // }
                        
                        // Normalizar NUMDOC para agrupaci√≥n
                        const numdocNormalizado = this.normalizarTexto(numdoc);
                        
                        if (!gruposPorNUMDOC.has(numdocNormalizado)) {
                            gruposPorNUMDOC.set(numdocNormalizado, {
                                numdoc: numdocNormalizado,
                                numdocOriginal: numdoc,
                                fdoc: fdoc, // Usar FDOC del primer registro para mapeo
                                totalHaber: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposPorNUMDOC.get(numdocNormalizado);
                        grupo.totalHaber += haber;
                        grupo.filas.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            numdoc: numdoc,
                            fdoc: fdoc,
                            haber: haber,
                            comprob: comprob
                        });
                    }
                }
                
                gruposFormados = gruposPorNUMDOC.size;
                const totalCandidatos = candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15;
                
                // console.log(`üìä PASO 9 - AGRUPACI√ìN:`);
                // console.log(`   üìã Candidatos LIBRO 03: ${candidatosLibro03}`);
                // console.log(`   üìó Candidatos LIBRO 09: ${candidatosLibro09}`);
                // console.log(`   üìò Candidatos LIBRO 14: ${candidatosLibro14}`);
                // console.log(`   üìô Candidatos LIBRO 15: ${candidatosLibro15}`);
                // console.log(`   üìö Total candidatos: ${totalCandidatos}`);
                // console.log(`   üîó Grupos por NUMDOC formados: ${gruposFormados}`);
                
                if (gruposFormados === 0) {
                    console.log(`‚ö†Ô∏è No se encontraron grupos para PASO 9`);
                    console.log(`   üìã Verificar si las filas tienen LIBRO en ["03", "09", "14", "15"]`);
                    console.log(`   üìã Verificar si las filas est√°n marcadas como "Pendiente"`);
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                // ‚úÖ A. GRUPOS ESPEC√çFICOS OBJETIVO
                console.log(`\nüìä === GRUPOS ESPEC√çFICOS ===`);
                console.log(`üéØ FILTRO ACTIVO: Solo mostrando NUMDOC: 11302, 1113, 11303, 1157, 900013`);
                let contadorGrupo = 104;
                const gruposObjetivoA = ['11302', '1113', '11303', '1157', '900013']; // Solo estos grupos
                for (const [numdocNormalizado, grupo] of gruposPorNUMDOC.entries()) {
                    // Solo mostrar los grupos objetivo espec√≠ficos
                    if (gruposObjetivoA.includes(numdocNormalizado)) {
                        console.log(`\nüîó GRUPO ${contadorGrupo}: NUMDOC="${numdocNormalizado}"`);
                        console.log(`   üìÖ FDOC: "${grupo.fdoc}" (${this.normalizarFecha(grupo.fdoc)})`);
                        console.log(`   üí∞ Total HABER: ${grupo.totalHaber.toFixed(2)}`);
                        console.log(`   üìã Filas en grupo: ${grupo.filas.length}`);
                        grupo.filas.forEach((fila, idx) => {
                            console.log(`     ${idx + 1}. LIBRO="${fila.libro}" | HABER=${fila.haber.toFixed(2)} | COMPROB="${fila.comprob}"`);
                        });
                        contadorGrupo++;
                    }
                }
                
                console.log(`\nüéØ === B. GRUPOS VS EXTRACTO ===`);
                
                // ‚úÖ PASO 9B: BUSCAR MATCHES EN EXTRACTO PARA CADA GRUPO
                contadorGrupo = 104;
                const gruposObjetivo = ['11302', '1113', '11303', '1157', '900013']; // Solo estos grupos
                
                for (const [numdocNormalizado, grupo] of gruposPorNUMDOC.entries()) {
                    // Solo procesar y mostrar logs para los grupos objetivo
                    const esGrupoObjetivo = gruposObjetivo.includes(numdocNormalizado);
                    
                    if (esGrupoObjetivo) {
                        console.log(`\nüîç BUSCANDO MATCH PARA GRUPO ${contadorGrupo}: NUMDOC="${numdocNormalizado}"`);
                        console.log(`   üìÖ FDOC: "${grupo.fdoc}" ‚Üí "${this.normalizarFecha(grupo.fdoc)}"`);
                        console.log(`   üí∞ Total HABER: ${grupo.totalHaber.toFixed(2)}`);
                    }
                    
                    // Buscar match en extracto usando FDOC y TOTAL HABER del grupo
                    const matchExtracto = this.buscarMatchExtractoPorGrupoNUMDOC(grupo.fdoc, grupo.totalHaber, extractoProcesable, idxE, estadosExtracto, esGrupoObjetivo);
                    
                    if (matchExtracto.encontrado) {
                        const refMayor = matchExtracto.operacionNumero; // Se quita el sufijo
                        const refExtracto = `${grupo.filas[0].libro}-${grupo.filas[0].comprob}`;
                        
                        // Asignar estados a todas las filas del grupo
                        grupo.filas.forEach(item => {
                            estadosFilas.set(item.indice, {
                                estado: 'P9 - Conciliada',
                                ref: refMayor
                            });
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P9 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliados += grupo.filas.length;
                        
                        if (esGrupoObjetivo) {
                            console.log(`\n‚úÖ ¬°MATCH ENCONTRADO PARA GRUPO ${contadorGrupo}!`);
                            console.log(`   üéØ Extracto √≠ndice: ${matchExtracto.indice}`);
                            console.log(`   üìÖ Fechas: "${grupo.fdoc}" ‚Üî "${matchExtracto.fecha}"`);
                            console.log(`   üí∞ Montos: ${grupo.totalHaber.toFixed(2)} ‚Üî ${matchExtracto.monto.toFixed(2)}`);
                            console.log(`   üè¶ Operaci√≥n #: "${matchExtracto.operacionNumero}"`);
                        }
                    } else {
                        if (esGrupoObjetivo) {
                            console.log(`\n‚ùå NO SE ENCONTR√ì MATCH PARA GRUPO ${contadorGrupo}: NUMDOC="${numdocNormalizado}"`);
                            console.log(`   ‚ùì Verificar en extracto operaciones del ${this.normalizarFecha(grupo.fdoc)} por ${grupo.totalHaber.toFixed(2)}`);
                        }
                    }
                    
                    // Solo incrementar contador para grupos objetivo (para mantener numeraci√≥n consistente en logs)
                    if (esGrupoObjetivo) {
                        contadorGrupo++;
                    }
                }
                
                // ‚úÖ C. TABLA DE ESTADOS DE GRUPOS (SOLO GRUPOS OBJETIVO)
                console.log(`\nüìä === C. TABLA DE ESTADOS DE GRUPOS ===`);
                console.log(`‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
                console.log(`‚îÇ GRUPO ‚îÇ NUMDOC          ‚îÇ FDOC            ‚îÇ TOTAL HABER  ‚îÇ FILAS       ‚îÇ ESTADO      ‚îÇ`);
                console.log(`‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§`);
                
                let gruposConciliados = 0;
                let gruposNoConciliados = 0;
                let numeroGrupo = 104;
                const gruposObjetivoTabla = ['11302', '1113', '11303', '1157', '900013']; // Redefinir para la tabla
                
                for (const [numdocNormalizado, grupo] of gruposPorNUMDOC.entries()) {
                    // Solo mostrar los grupos objetivo espec√≠ficos
                    if (gruposObjetivoTabla.includes(numdocNormalizado)) {
                        // Verificar si el grupo fue conciliado revisando el estado de la primera fila
                        const primeraFila = grupo.filas[0];
                        const estadoPrimeraFila = estadosFilas.get(primeraFila.indice);
                        const estado = estadoPrimeraFila && estadoPrimeraFila.estado === 'P9 - Conciliada' ? '‚úÖ CONCILIADO' : '‚ùå PENDIENTE';
                        
                        if (estado === '‚úÖ CONCILIADO') gruposConciliados++;
                        else gruposNoConciliados++;
                        
                        const grupoPadded = numeroGrupo.toString().padStart(5);
                        const numdocPadded = (numdocNormalizado || '').toString().padEnd(15);
                        const fdocPadded = (grupo.fdoc || '').toString().padEnd(15);
                        const haberPadded = (grupo.totalHaber || 0).toFixed(2).padStart(12);
                        const filasPadded = (grupo.filas?.length || 0).toString().padStart(11);
                        const estadoPadded = (estado || '').toString().padEnd(13);
                        
                        console.log(`‚îÇ ${grupoPadded} ‚îÇ ${numdocPadded} ‚îÇ ${fdocPadded} ‚îÇ ${haberPadded} ‚îÇ ${filasPadded} ‚îÇ ${estadoPadded} ‚îÇ`);
                    }
                    numeroGrupo++;
                }
                
                console.log(`‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`);
                console.log(`üìä RESUMEN: ${gruposConciliados} conciliados, ${gruposNoConciliados} pendientes`);
                console.log(`üéØ SOLO MOSTRANDO GRUPOS: ${gruposObjetivoTabla.join(', ')}`);
                
                return {
                    candidatos: totalCandidatos,
                    grupos: gruposFormados,
                    conciliados: conciliados,
                    libro03: candidatosLibro03,
                    libro09: candidatosLibro09,
                    libro14: candidatosLibro14,
                    libro15: candidatosLibro15
                };
            },

            buscarMatchExtractoPorGrupoNUMDOC(fdocGrupo, totalHaber, extractoProcesable, idxE, estadosExtracto, esGrupoObjetivo = false) {
                /*
                Busca un match en el extracto para PASO 9 (grupos por NUMDOC):
                - Compara FDOC del grupo vs FECHA (Extracto col A)
                - Compara total HABER del grupo vs |MONTO| (Extracto col D en VALOR ABSOLUTO)
                - Retorna datos del match si se encuentra
                NOTA: Similar a buscarMatchExtractoPorGrupo del Paso 5 pero para agrupaci√≥n por NUMDOC
                */
                
                if (esGrupoObjetivo) {
                    console.log(`üîç Buscando match para grupo NUMDOC: FDOC="${fdocGrupo}", total HABER=${totalHaber}`);
                    console.log(`üìÑ Total l√≠neas disponibles en extracto: ${extractoProcesable ? extractoProcesable.length : 0}`);
                    console.log(`üìÑ L√≠neas ya procesadas: ${estadosExtracto.size}`);
                    
                    // Mostrar primeras 5 l√≠neas del extracto con fechas normalizadas
                    console.log(`üìã PRIMERAS 5 L√çNEAS DEL EXTRACTO DISPONIBLE:`);
                    for (let i = 0; i < Math.min(5, extractoProcesable.length); i++) {
                        if (!estadosExtracto.has(i)) {
                            const fila = extractoProcesable[i].fila;
                            const fechaRaw = fila[idxE.fecha] || '';
                            const fechaNorm = this.normalizarFecha(fechaRaw);
                            const montoRaw = fila[idxE.monto] || '';
                            console.log(`   ${i}: "${fechaRaw}" ‚Üí "${fechaNorm}" | Monto: "${montoRaw}"`);
                        } else {
                            console.log(`   ${i}: [YA PROCESADA]`);
                        }
                    }
                    
                    // Buscar espec√≠ficamente la fecha objetivo en todo el extracto
                    const fechaObjetivo = this.normalizarFecha(fdocGrupo);
                    console.log(`üéØ BUSCANDO FECHA OBJETIVO "${fechaObjetivo}" EN TODO EL EXTRACTO:`);
                    let encontradas = 0;
                    const lineasObjetivo = [];
                    for (let i = 0; i < extractoProcesable.length; i++) {
                        const fila = extractoProcesable[i].fila;
                        const fechaRaw = fila[idxE.fecha] || '';
                        const fechaNorm = this.normalizarFecha(fechaRaw);
                        if (fechaNorm === fechaObjetivo) {
                            const montoRaw = fila[idxE.monto] || '';
                            const montoNorm = Math.abs(this.normalizarMonto(montoRaw));
                            const procesada = estadosExtracto.has(i) ? '[PROCESADA]' : '[DISPONIBLE]';
                            const diferencia = Math.abs(totalHaber - montoNorm);
                            const coincide = diferencia === 0 ? 'üéØ MATCH!' : `Dif: ${diferencia.toFixed(2)}`;
                            console.log(`   √çndice ${i}: "${fechaRaw}" | Monto: "${montoRaw}" ‚Üí ${montoNorm.toFixed(2)} ${procesada} ${coincide}`);
                            if (!estadosExtracto.has(i)) {
                                lineasObjetivo.push({indice: i, monto: montoNorm, diferencia});
                            }
                            encontradas++;
                        }
                    }
                    if (encontradas === 0) {
                        console.log(`   ‚ùå NO se encontraron l√≠neas con fecha "${fechaObjetivo}"`);
                    } else {
                        console.log(`   üìä Total encontradas: ${encontradas} | Disponibles: ${lineasObjetivo.length}`);
                    }
                }
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    // // console.log(`‚ùå Error: extractoProcesable no es v√°lido`);
                    return { encontrado: false };
                }
                
                const fechaGrupoNormalizada = this.normalizarFecha(fdocGrupo);
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    candidatosRevisados++;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[idxE.operacion] || ''; // Matriz fija - Operaci√≥n
                    
                    // Normalizar fecha y monto del extracto
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtractoRaw_parsed = this.normalizarMonto(montoExtractoRaw);
                    const montoExtracto = Math.abs(montoExtractoRaw_parsed); // VALOR ABSOLUTO para extracto
                    
                    // Comparar fechas y montos
                    const fechasCoinciden = fechaGrupoNormalizada === fechaExtractoNormalizada;
                    const diferenciaMonto = Math.abs(totalHaber - montoExtracto);
                    const montosCoinciden = diferenciaMonto < 0.01; // Tolerancia para errores de floating point
                    
                    // Solo mostrar logs para coincidencias de fecha o matches completos
                    if (esGrupoObjetivo && (fechasCoinciden || (fechasCoinciden && montosCoinciden))) {
                        console.log(`   üîç Candidato ${candidatosRevisados} (√çndice ${i}):`);
                        console.log(`      Fecha: "${fechaExtractoRaw}" ‚Üí "${fechaExtractoNormalizada}" | FDOC Grupo: "${fechaGrupoNormalizada}" | Match: ${fechasCoinciden ? '‚úÖ' : '‚ùå'}`);
                        console.log(`      Monto: ${montoExtractoRaw} ‚Üí abs(${montoExtracto.toFixed(2)}) | Total HABER=${totalHaber.toFixed(6)} | Diferencia: ${diferenciaMonto.toFixed(6)} | Match: ${montosCoinciden ? '‚úÖ' : '‚ùå'}`);
                    }
                    
                    if (fechasCoinciden && montosCoinciden) {
                        // console.log(`‚úÖ MATCH COMPLETO encontrado en √≠ndice ${i}`);
                        // console.log(`   üìã FDOC Grupo: "${fdocGrupo}" ‚Üî FECHA Extracto: "${fechaExtractoRaw}"`);
                        // console.log(`   üìã Total HABER: ${totalHaber} ‚Üî |MONTO|: ${montoExtracto} (diferencia: ${diferenciaMonto.toFixed(4)})`);
                        // console.log(`   üìã Operaci√≥n-N√∫mero del extracto: "${operacionNumero}" (se asignar√° a todas las filas del grupo)`);
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                // // console.log(`‚ùå No se encontr√≥ match despu√©s de revisar ${candidatosRevisados} candidatos`);
                return { encontrado: false };
            },

            procesarPaso10(dataRowsMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, datosSaldo = null, estadosSaldo = null) {
                /*
                PASO 10 - OPERACIONES DE CHEQUES (2 ETAPAS):
                
                ETAPA 10A - MAPEO MAYOR VS EXTRACTO:
                CRITERIOS DE FILTRADO:
                - Mayor: LIBRO = "02" + ESTADO = "Pendiente"
                - Extracto: "Descripci√≥n operaci√≥n" empieza con "CHEQUE" o "CERT. CHQ"
                
                MAPEO:
                - NUMDOC (Mayor) ‚Üî √∫ltimos 8 caracteres de "Descripci√≥n operaci√≥n" (Extracto)
                - HABER (Mayor) ‚Üî |MONTO| (Extracto en valor absoluto)
                
                ESTADOS RESULTANTES:
                - "P10A - Conciliada" para ambos registros
                - Mayor: #REF = [Operaci√≥n - N√∫mero del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                
                ETAPA 10B - MAPEO EXTRACTO VS SALDO:
                CRITERIOS DE FILTRADO:
                - Extracto: "Descripci√≥n operaci√≥n" inicia con "CHEQUE" + ESTADO = "Pendiente"
                - Saldo: ESTADO = "Pendiente"
                
                MAPEO:
                - √öltimos 8 caracteres de Descripci√≥n operaci√≥n (Extracto) ‚Üî NUMDOC (Saldo)
                
                ESTADOS RESULTANTES:
                - "P10B - Conciliada" para ambos registros
                - Saldo: #REF = "Operaci√≥n - N√∫mero" del extracto
                - Extracto: #REF = "libro - comprobante" (columnas L y M de saldo)
                */
                
                // // console.log(`üìà PASO 10: Iniciando procesamiento de operaciones de CHEQUES (2 ETAPAS)`);
                // // console.log(`üîç Total filas a revisar: ${dataRowsMayor.length}`);
                // // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                // ========================================
                // ETAPA 10A: MAPEO MAYOR VS EXTRACTO
                // ========================================
                let candidatosLibro02 = 0;
                let candidatosExtractoCheques = 0;
                let conciliados10A = 0;
                let conciliados10B = 0;
                
                // Identificar candidatos LIBRO="02" pendientes
                const candidatosPaso10 = [];
                
                for (let i = 0; i < dataRowsMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = dataRowsMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    
                    // Verificar criterios del PASO 10A
                    const esLibro02 = libro.trim() === '02';
                    
                    if (esLibro02) {
                        candidatosLibro02++;
                        const numdoc = filaMayor[idxM.numdoc] || '';
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosPaso10.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            numdoc: this.normalizarTexto(numdoc),
                            numdocOriginal: numdoc,
                            haber: haber,
                            comprob: comprob
                        });
                    }
                }
                
                // // console.log(`üìä ETAPA 10A - FILTRADO MAYOR:`);
                // // console.log(`   üìù Candidatos LIBRO 02 (cheques): ${candidatosLibro02}`);
                
                // Filtrar extracto por descripci√≥n que empiece con "CHEQUE" o "CERT. CHQ"
                const extractoCheques = [];
                
                if (extractoProcesable && Array.isArray(extractoProcesable)) {
                    for (let i = 0; i < extractoProcesable.length; i++) {
                        // Solo revisar filas no procesadas del extracto
                        if (estadosExtracto.has(i)) continue;
                        
                        const itemExtracto = extractoProcesable[i];
                        const filaExtracto = itemExtracto.fila;
                        
                        if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                        
                        const descripcionOperacion = (filaExtracto[idxE.descripcion] || '').toString().toUpperCase();
                        
                        // Verificar si empieza con "CHEQUE" o "CERT. CHQ"
                        const esCheque = descripcionOperacion.startsWith('CHEQUE') || descripcionOperacion.startsWith('CERT. CHQ');
                        
                        if (esCheque) {
                            candidatosExtractoCheques++;
                            
                            // Extraer √∫ltimos 8 caracteres de la descripci√≥n
                            const ultimos8Chars = descripcionOperacion.slice(-8);
                            const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                            const operacionNumero = filaExtracto[idxE.operacion] || ''; // Matriz fija - Operaci√≥n
                            
                            extractoCheques.push({
                                indiceOriginal: i,
                                descripcion: descripcionOperacion,
                                ultimos8: this.normalizarTexto(ultimos8Chars),
                                monto: Math.abs(this.normalizarMonto(montoExtractoRaw)), // VALOR ABSOLUTO
                                operacionNumero: operacionNumero,
                                filaCompleta: filaExtracto
                            });
                        }
                    }
                }
                
                // // console.log(`üìä ETAPA 10A - FILTRADO EXTRACTO:`);
                // // console.log(`   üìù Candidatos con CHEQUE/CERT. CHQ: ${candidatosExtractoCheques}`);
                
                // ETAPA 10A: MAPEO MAYOR vs EXTRACTO
                if (candidatosLibro02 > 0 && candidatosExtractoCheques > 0) {
                    // // console.log(`\nüìù ETAPA 10A - MAPEO: NUMDOC+HABER vs √∫ltimos 8 chars + |MONTO|`);
                    
                    for (const candidato of candidatosPaso10) {
                        // Saltar si ya fue procesado
                        if (estadosFilas.has(candidato.indice)) continue;
                        
                        // Buscar match en extracto filtrado
                        const matchExtracto = this.buscarMatchPorNUMDOCyCheque(candidato.numdoc, candidato.haber, extractoCheques, estadosExtracto);
                        
                        if (matchExtracto.encontrado) {
                            const refMayor = matchExtracto.operacionNumero;
                            const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                            
                            // Asignar estados ETAPA 10A
                            estadosFilas.set(candidato.indice, {
                                estado: 'P10A - Conciliada',
                                ref: refMayor
                            });
                            
                            estadosExtracto.set(matchExtracto.indice, {
                                estado: 'P10A - Conciliada',
                                ref: refExtracto
                            });
                            
                            conciliados10A++;
                            
                            // // console.log(`‚úÖ ETAPA 10A - CONCILIACI√ìN EXITOSA:`);
                            // // console.log(`   üìù Mayor: LIBRO=${candidato.libro}, NUMDOC="${candidato.numdocOriginal}", HABER=${candidato.haber}, COMPROB=${candidato.comprob} ‚Üí REF="${refMayor}"`);
                            // // console.log(`   üìù Extracto: DESC="${matchExtracto.descripcion}", √öltimos 8="${matchExtracto.ultimos8}", |MONTO|=${matchExtracto.monto} ‚Üí REF="${refExtracto}"`);
                        }
                    }
                }
                
                // ========================================
                // ETAPA 10B: MAPEO EXTRACTO VS SALDO
                // ========================================
                
                // // console.log(`\nüìà ETAPA 10B: Iniciando mapeo EXTRACTO vs SALDO para cheques`);
                
                if (datosSaldo && datosSaldo.length > 1 && estadosSaldo) {
                    // Mapear √≠ndices del saldo
                    const headerSaldo = datosSaldo[0] || [];
                    const indicesSaldo = this.buscarIndicesColumnas(headerSaldo, {
                        cuenta: ['CUENTA'], 
                        numdoc: ['NUMDOC'], 
                        debe: ['DEBE'], 
                        haber: ['HABER'], 
                        fdoc: ['FDOC'], 
                        libro: ['LIBRO'], // Columna L
                        comprobante: ['COMPROBANTE', 'COMPROB'] // Columna M
                    });
                    
                    const filasSaldo = datosSaldo.slice(1);
                    
                    // Filtrar extracto cheques pendientes despu√©s de ETAPA 10A
                    const extractoChequesParaSaldo = extractoCheques.filter(item => !estadosExtracto.has(item.indiceOriginal));
                    
                    // // console.log(`üìä ETAPA 10B - CANDIDATOS:`);
                    // // console.log(`   üìù Extracto cheques pendientes: ${extractoChequesParaSaldo.length}`);
                    // // console.log(`   üìù Filas saldo disponibles: ${filasSaldo.length}`);
                    
                    // MAPEO: √öltimos 8 chars extracto ‚Üî NUMDOC saldo
                    for (const extractoItem of extractoChequesParaSaldo) {
                        for (let idx = 0; idx < filasSaldo.length; idx++) {
                            // Solo procesar filas saldo pendientes
                            if (estadosSaldo.has(idx) && estadosSaldo.get(idx).estado !== 'Pendiente') continue;
                            
                            const filaSaldo = filasSaldo[idx];
                            const numdocSaldoRaw = filaSaldo[indicesSaldo.numdoc] || '';
                            const numdocSaldoNormalizado = this.normalizarTexto(numdocSaldoRaw);
                            
                            // Comparar √∫ltimos 8 chars extracto vs NUMDOC saldo
                            if (extractoItem.ultimos8 && numdocSaldoNormalizado && extractoItem.ultimos8 === numdocSaldoNormalizado) {
                                // MATCH ENCONTRADO
                                const operacionNumero = extractoItem.operacionNumero;
                                const libroSaldo = filaSaldo[indicesSaldo.libro] || filaSaldo[11] || ''; // Columna L
                                const comprobanteSaldo = filaSaldo[indicesSaldo.comprobante] || filaSaldo[12] || ''; // Columna M
                                const refExtracto = `${libroSaldo}-${comprobanteSaldo}`;
                                
                                // Asignar estados ETAPA 10B
                                estadosSaldo.set(idx, {
                                    estado: 'P10B - Conciliada',
                                    ref: operacionNumero
                                });
                                
                                estadosExtracto.set(extractoItem.indiceOriginal, {
                                    estado: 'P10B - Conciliada',
                                    ref: refExtracto
                                });
                                
                                conciliados10B++;
                                
                                // // console.log(`‚úÖ ETAPA 10B - CONCILIACI√ìN EXITOSA:`);
                                // // console.log(`   üìù Extracto: DESC="${extractoItem.descripcion}", √öltimos 8="${extractoItem.ultimos8}", Operaci√≥n="${operacionNumero}" ‚Üí REF="${refExtracto}"`);
                                // // console.log(`   üìù Saldo: NUMDOC="${numdocSaldoRaw}", LIBRO="${libroSaldo}", COMPROB="${comprobanteSaldo}" ‚Üí REF="${operacionNumero}"`);
                                
                                break; // Solo uno por extracto
                            }
                        }
                    }

                    
                } else {
                    // // console.log(`‚ö†Ô∏è ETAPA 10B: No hay datos de saldo disponibles o estadosSaldo no inicializado`);
                    // // console.log(`   üìä datosSaldo: ${datosSaldo ? 'S√ç' : 'NO'}, estadosSaldo: ${estadosSaldo ? 'S√ç' : 'NO'}`);
                }
                
                // // console.log(`üìä PASO 10 - RESUMEN COMPLETO:`);
                // // console.log(`   üìù Candidatos LIBRO 02: ${candidatosLibro02}`);
                // // console.log(`   üìù Candidatos extracto cheques: ${candidatosExtractoCheques}`);
                // // console.log(`   üéØ Conciliados 10A: ${conciliados10A}`);
                // // console.log(`   üéØ Conciliados 10B: ${conciliados10B}`);
                
                return {
                    candidatos: candidatosLibro02,
                    candidatosExtracto: candidatosExtractoCheques,
                    conciliados10A: conciliados10A,
                    conciliados10B: conciliados10B,
                    conciliados: conciliados10A + conciliados10B
                };
            },

            aplicarEstadosASaldo(datosSaldo, estadosSaldo) {
                /*
                Aplica los estados del Map estadosSaldo a las columnas P (ESTADO) y Q (#REF) del archivo saldo.
                - datosSaldo: Array con header + filas de datos del saldo
                - estadosSaldo: Map con √≠ndices y estados {estado, ref}
                */
                
                if (!datosSaldo || datosSaldo.length <= 1 || !estadosSaldo || estadosSaldo.size === 0) {
                    // // console.log(`‚ö†Ô∏è aplicarEstadosASaldo: Sin datos para procesar`);
                    return;
                }
                
                // // console.log(`üìä aplicarEstadosASaldo: Aplicando ${estadosSaldo.size} estados a ${datosSaldo.length - 1} filas`);
                
                let estadosAplicados = 0;
                
                // Procesar cada fila de datos (saltar header)
                for (let i = 1; i < datosSaldo.length; i++) {
                    const indiceData = i - 1; // √çndice en el Map (0-based para filas de datos)
                    
                    if (estadosSaldo.has(indiceData)) {
                        const estadoInfo = estadosSaldo.get(indiceData);
                        const fila = datosSaldo[i];
                        
                        // Asegurar que la fila tiene al menos 17 columnas (0-16)
                        while (fila.length < 17) {
                            fila.push('');
                        }
                        
                        // Actualizar columnas P (15) y Q (16)
                        fila[15] = estadoInfo.estado || 'Pendiente'; // Columna P = ESTADO
                        fila[16] = estadoInfo.ref || ''; // Columna Q = #REF
                        
                        estadosAplicados++;
                        
                        // // console.log(`   ‚úÖ Fila ${i}: ESTADO="${estadoInfo.estado}", REF="${estadoInfo.ref}"`);
                    }
                }
                
                // // console.log(`üìä aplicarEstadosASaldo: ${estadosAplicados} estados aplicados exitosamente`);
            },

            buscarMatchPorNUMDOCyCheque(numdocMayor, haberMayor, extractoCheques, estadosExtracto) {
                /*
                Busca un match en el extracto filtrado para PASO 10 (cheques):
                - Compara NUMDOC (Mayor normalizado) vs √∫ltimos 8 caracteres de descripci√≥n (Extracto)
                - Compara HABER (Mayor) vs |MONTO| (Extracto en valor absoluto)
                - Retorna datos del match si se encuentra
                */
                
                // // console.log(`üîç Buscando match por CHEQUE: NUMDOC="${numdocMayor}", HABER=${haberMayor}`);
                
                let candidatosRevisados = 0;
                
                for (const itemExtracto of extractoCheques) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(itemExtracto.indiceOriginal)) continue;
                    
                    candidatosRevisados++;
                    
                    // Comparar NUMDOC vs √∫ltimos 8 caracteres y HABER vs |MONTO|
                    const numdocCoincide = numdocMayor && itemExtracto.ultimos8 && numdocMayor === itemExtracto.ultimos8;
                    const diferenciaMonto = Math.abs(haberMayor - itemExtracto.monto);
                    const montosCoinciden = diferenciaMonto === 0; // Exacto
                    
                    // if (candidatosRevisados <= 5) {
                    //     // console.log(`   üîç Candidato ${candidatosRevisados}:`);
                    //     // console.log(`      NUMDOC: "${numdocMayor}" vs √öltimos 8: "${itemExtracto.ultimos8}" | Match: ${numdocCoincide ? '‚úÖ' : '‚ùå'}`);
                    //     // console.log(`      HABER: ${haberMayor} vs |MONTO|: ${itemExtracto.monto} | Diferencia: ${diferenciaMonto.toFixed(4)} | Match: ${montosCoinciden ? '‚úÖ' : '‚ùå'}`);
                    // }
                    
                    if (numdocCoincide && montosCoinciden) {
                        // // console.log(`‚úÖ MATCH CHEQUE encontrado`);
                        // // console.log(`   üìù NUMDOC Mayor: "${numdocMayor}" ‚Üî √öltimos 8 Extracto: "${itemExtracto.ultimos8}"`);
                        // // console.log(`   üìù HABER Mayor: ${haberMayor} ‚Üî |MONTO| Extracto: ${itemExtracto.monto} (diferencia: ${diferenciaMonto.toFixed(4)})`);
                        // // console.log(`   üìù Descripci√≥n completa: "${itemExtracto.descripcion}"`);
                        return {
                            encontrado: true,
                            indiceOriginal: itemExtracto.indiceOriginal,
                            descripcion: itemExtracto.descripcion,
                            ultimos8: itemExtracto.ultimos8,
                            monto: itemExtracto.monto,
                            operacionNumero: itemExtracto.operacionNumero
                        };
                    }
                }
                
                // // console.log(`‚ùå No se encontr√≥ match CHEQUE despu√©s de revisar ${candidatosRevisados} candidatos`);
                return { encontrado: false };
            },

            procesarPaso11(dataRowsMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 11 - ITF (IMPUESTO A LAS TRANSACCIONES FINANCIERAS) - L√ìGICA GLOBAL:
                R√©plica exacta de la l√≥gica del conciliador estable.
                
                CRITERIOS DE FILTRADO:
                - Mayor: LIBRO = "09" + GLOSA empieza con "ITF" + ESTADO = "Pendiente"
                - Extracto: "Descripci√≥n operaci√≥n" contiene "IMPUESTO ITF" (BCP) o empieza con "CARGO POR ITF" (SANT)
                
                ESTRATEGIA DE AGRUPACI√ìN:
                1. Identificar todos los registros ITF del mayor (LIBRO 09)
                2. Identificar todos los registros ITF del extracto
                3. Conciliar suma total de mayor vs suma total de extracto
                
                ESTADOS RESULTANTES:
                - "P11 - Conciliada" para todos los registros agrupados
                - Mayor: #REF = [Operaci√≥n - N√∫mero del primer Extracto ITF]
                - Extracto: #REF = "LIBRO-COMPROB" del primer registro Mayor ITF
                */
                
                console.log(`üìà PASO 11: Iniciando procesamiento de ITF (GLOBAL)`);
                console.log(`üîç Total filas a revisar: ${dataRowsMayor.length}`);
                console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                let candidatosLibro09ITF = 0;
                let candidatosExtractoITF = 0;
                let conciliados = 0;
                
                // Identificar candidatos LIBRO="09" + GLOSA empieza con "ITF"
                const candidatosMayorITF = [];
                
                for (let i = 0; i < dataRowsMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = dataRowsMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    
                    // Verificar criterios del PASO 11
                    const esLibro09 = libro.trim() === '09';
                    const esGlosaITF = glosa.startsWith('ITF');
                    
                    if (esLibro09 && esGlosaITF) {
                        candidatosLibro09ITF++;
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        const cuenta = filaMayor[idxM.cuenta] || '';
                        
                        candidatosMayorITF.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            fdoc: fdoc,
                            debe: debe,
                            haber: haber,
                            comprob: comprob,
                            cuenta: cuenta
                        });
                        
                        // DEBUG: Mostrar los primeros 3 candidatos ITF del mayor
                        if (candidatosLibro09ITF <= 3) {
                            console.log(`üîç Candidato ITF Mayor ${candidatosLibro09ITF}: CUENTA=${cuenta}, LIBRO="${libro}", GLOSA="${glosa.substring(0, 30)}...", DEBE=${debe}, HABER=${haber}`);
                        }
                    }
                }
                
                console.log(`üìä PASO 11 - FILTRADO MAYOR:`);
                console.log(`   üí∞ Candidatos LIBRO 09 + ITF: ${candidatosLibro09ITF}`);
                
                if (candidatosLibro09ITF === 0) {
                    console.log(`‚ö†Ô∏è No se encontraron candidatos ITF en LIBRO 09 para PASO 11`);
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // Filtrar extracto por cuenta espec√≠fica y descripci√≥n que contenga ITF
                const extractoITF = [];
                console.log(`üîç PASO 11 - BUSQUEDA POR CUENTA ESPEC√çFICA:`);
                
                // DEBUG: Mostrar muestra de cuentas en extractoProcesable
                console.log(`üîç DEBUG EXTRACTO - Total filas: ${extractoProcesable ? extractoProcesable.length : 0}`);
                if (extractoProcesable && extractoProcesable.length > 0) {
                    const muestraFilas = extractoProcesable.slice(0, 10);
                    muestraFilas.forEach((item, idx) => {
                        if (item && item.fila) {
                            const cuenta = item.fila[item.fila.length - 1] || 'SIN_CUENTA';
                            console.log(`   Fila ${idx + 1}: CUENTA=${cuenta}, cols=${item.fila.length}`);
                        }
                    });
                }
                
                // Para cada ITF del MAYOR, buscar solo en SU extracto espec√≠fico
                candidatosMayorITF.forEach((mayorITF, mayorIdx) => {
                    const cuentaMayor = mayorITF.cuenta; // ej: 1041401 para SANT
                    console.log(`   üîç Buscando ITF en extracto para cuenta ${cuentaMayor} (${mayorIdx + 1}/${candidatosMayorITF.length})`);
                    
                    let filasRevisadasCuenta = 0; // Contador para esta cuenta espec√≠fica
                    let filasTotalesProcesadas = 0; // Contador total de filas procesadas
                    
                    if (extractoProcesable && Array.isArray(extractoProcesable)) {
                        for (let i = 0; i < extractoProcesable.length; i++) {
                            filasTotalesProcesadas++;
                            
                            // Solo revisar filas no procesadas del extracto
                            if (estadosExtracto.has(i)) {
                                if (cuentaMayor === '1041401' && filasRevisadasCuenta < 3) {
                                    console.log(`   ‚è≠Ô∏è SANT: Saltando fila ${i} (ya procesada)`);
                                }
                        continue;
                    }
                    
                            const itemExtracto = extractoProcesable[i];
                            const filaExtracto = itemExtracto.fila;
                            
                            if (!filaExtracto || !Array.isArray(filaExtracto)) {
                                if (cuentaMayor === '1041401' && filasRevisadasCuenta < 3) {
                                    console.log(`   ‚ùå SANT: Fila ${i} inv√°lida o no es array`);
                                }
                                continue;
                            }
                            
                            const cuentaOrigen = filaExtracto[filaExtracto.length - 1] || ''; // CUENTA_ORIGEN est√° al final
                            
                            if (cuentaMayor === '1041401' && filasRevisadasCuenta < 5) {
                                console.log(`   üîç SANT: Fila ${i}, CUENTA_ORIGEN="${cuentaOrigen}", buscando="${cuentaMayor}"`);
                            }
                            
                            // ‚úÖ CLAVE: Solo buscar en el extracto de la MISMA cuenta del MAYOR
                            if (cuentaOrigen !== cuentaMayor) continue;
                            
                            filasRevisadasCuenta++; // Contar filas de esta cuenta espec√≠fica
                            
                            const descripcionOperacion = (filaExtracto[idxE.descripcion] || '').toString().toUpperCase();
                            
                            // DEBUG ESPEC√çFICO PARA SANT - Mostrar todas las columnas
                            if (cuentaOrigen === '1041401' && candidatosExtractoITF < 5) {
                                console.log(`üîç DEBUG SANT - Fila completa:`, filaExtracto);
                                console.log(`üîç SANT Col E (idx4): "${filaExtracto[4] || 'VAC√çO'}"`);
                                console.log(`üîç SANT Col D (idx3): "${filaExtracto[3] || 'VAC√çO'}"`);
                                console.log(`üîç SANT Col F (idx5): "${filaExtracto[5] || 'VAC√çO'}"`);
                                console.log(`üîç SANT Descripci√≥n detectada (idx${idxE.descripcion}): "${descripcionOperacion}"`);
                            }
                            
                            // Verificar si contiene ITF (diferentes criterios por banco)
                            let esITF = false;
                            if (cuentaOrigen === '1041401') {
                                // SANT usa "CARGO POR ITF" - usar startsWith para evitar problemas con espacios
                                esITF = descripcionOperacion.startsWith('CARGO POR ITF');
                            } else {
                                // BCP y otros usan "IMPUESTO ITF"
                                esITF = descripcionOperacion.includes('IMPUESTO ITF');
                            }
                        
                            if (esITF) {
                                candidatosExtractoITF++;
                                
                                const fechaExtracto = filaExtracto[idxE.fecha] || '';
                                const montoExtracto = Math.abs(this.normalizarMonto(filaExtracto[idxE.monto] || '0'));
                                const operacionNumero = filaExtracto[idxE.operacion] || '';
                                
                                extractoITF.push({
                                    indiceOriginal: i,
                                    fecha: fechaExtracto,
                                    descripcion: descripcionOperacion,
                                    monto: montoExtracto,
                                    operacionNumero: operacionNumero,
                                    cuenta: cuentaOrigen,
                                    mayorAsociado: mayorIdx // Referencia al ITF del mayor
                                });
                                
                                // DEBUG: Mostrar los primeros 3 candidatos ITF del extracto
                                if (candidatosExtractoITF <= 3) {
                                    console.log(`   ‚úÖ ITF Extracto ${candidatosExtractoITF}: CUENTA=${cuentaOrigen}, DESC="${descripcionOperacion.substring(0, 30)}...", MONTO=${montoExtracto}`);
                                }
                            }
                        } // fin for extractoProcesable
                        
                        console.log(`   üìä RESUMEN cuenta ${cuentaMayor}:`);
                        console.log(`      - Filas totales procesadas: ${filasTotalesProcesadas}`);
                        console.log(`      - Filas de esta cuenta: ${filasRevisadasCuenta}`);
                        console.log(`      - Estados procesados: ${estadosExtracto.size}`);
                    } // fin if extractoProcesable
                }); // fin forEach candidatosMayorITF
                
                console.log(`üìä PASO 11 - FILTRADO EXTRACTO:`);
                console.log(`   üí∞ Candidatos con ITF: ${candidatosExtractoITF}`);
                
                if (candidatosExtractoITF === 0) {
                    console.log(`‚ö†Ô∏è No se encontraron candidatos ITF en extracto para PASO 11`);
                    return { candidatos: candidatosLibro09ITF, conciliados: 0 };
                }
                
                // CONCILIACI√ìN INDIVIDUAL POR CUENTA (NO GLOBAL)
                console.log(`üìä PASO 11 - CONCILIACI√ìN POR CUENTA ESPEC√çFICA:`);
                
                // Agrupar ITF del mayor por cuenta
                const mayorPorCuenta = {};
                        candidatosMayorITF.forEach(item => {
                    if (!mayorPorCuenta[item.cuenta]) {
                        mayorPorCuenta[item.cuenta] = [];
                    }
                    mayorPorCuenta[item.cuenta].push(item);
                });
                
                // Agrupar ITF del extracto por cuenta
                const extractoPorCuenta = {};
                extractoITF.forEach(item => {
                    if (!extractoPorCuenta[item.cuenta]) {
                        extractoPorCuenta[item.cuenta] = [];
                    }
                    extractoPorCuenta[item.cuenta].push(item);
                });
                
                let conciliadosTotal = 0;
                
                // Conciliar cada cuenta individualmente
                Object.keys(mayorPorCuenta).forEach(cuenta => {
                    const mayorCuenta = mayorPorCuenta[cuenta];
                    const extractoCuenta = extractoPorCuenta[cuenta] || [];
                    
                    const totalMayorCuenta = mayorCuenta.reduce((suma, item) => suma + (item.debe + item.haber), 0);
                    const totalExtractoCuenta = extractoCuenta.reduce((suma, item) => suma + item.monto, 0);
                    
                    console.log(`   üí∞ CUENTA ${cuenta}:`);
                    console.log(`      Mayor: ${totalMayorCuenta.toFixed(2)} (${mayorCuenta.length} registros)`);
                    console.log(`      Extracto: ${totalExtractoCuenta.toFixed(2)} (${extractoCuenta.length} registros)`);
                    
                    const diferenciaCuenta = Math.abs(totalMayorCuenta - totalExtractoCuenta);
                    const coincideCuenta = diferenciaCuenta === 0;
                    
                    console.log(`      Diferencia: ${diferenciaCuenta.toFixed(4)} - ${coincideCuenta ? '‚úÖ COINCIDE' : '‚ùå NO COINCIDE'}`);
                    
                    if (coincideCuenta && extractoCuenta.length > 0) {
                        // CONCILIACI√ìN EXITOSA PARA ESTA CUENTA
                        const refMayor = extractoCuenta[0].operacionNumero || `ITF-${cuenta}`;
                        const refExtracto = `${mayorCuenta[0].libro}-${mayorCuenta[0].comprob}`;
                        
                        // Asignar estados a registros del mayor de esta cuenta
                        mayorCuenta.forEach((item, idx) => {
                        estadosFilas.set(item.indice, {
                            estado: 'P11 - Conciliada',
                                ref: refMayor
                        });
                            
                            console.log(`      ‚úÖ Mayor ${idx + 1}: GLOSA="${item.glosa.substring(0, 25)}...", MONTO=${item.debe + item.haber} ‚Üí REF="${refMayor}"`);
                    });
                    
                        // Asignar estados a registros del extracto de esta cuenta  
                        extractoCuenta.forEach((item, idx) => {
                        estadosExtracto.set(item.indiceOriginal, {
                            estado: 'P11 - Conciliada',
                            ref: refExtracto
                        });
                            
                            console.log(`      ‚úÖ Extracto ${idx + 1}: DESC="${item.descripcion.substring(0, 25)}...", MONTO=${item.monto} ‚Üí REF="${refExtracto}"`);
                        });
                        
                        conciliadosTotal += mayorCuenta.length + extractoCuenta.length;
                        console.log(`      üéØ Conciliados ${mayorCuenta.length + extractoCuenta.length} registros para cuenta ${cuenta}`);
                } else {
                        console.log(`      ‚ùå No se pudo conciliar cuenta ${cuenta} (diferencia: ${diferenciaCuenta.toFixed(4)} o sin extracto)`);
                    }
                });
                
                conciliados = conciliadosTotal;
                
                console.log(`üìä PASO 11 - RESUMEN COMPLETO:`);
                console.log(`   üí∞ Candidatos LIBRO 09 ITF: ${candidatosLibro09ITF}`);
                console.log(`   üí∞ Candidatos extracto ITF: ${candidatosExtractoITF}`);
                console.log(`   üéØ Registros conciliados: ${conciliados}`);
                console.log(`   üí∞ Estrategia: Conciliaci√≥n individual por cuenta espec√≠fica`);
                
                return {
                    candidatos: candidatosLibro09ITF,
                    candidatosExtracto: candidatosExtractoITF,
                    conciliados: conciliados
                };
            },

            procesarPaso12(dataRowsMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 12 - CONCILIACI√ìN MULTI-CRITERIO PROGRESIVA:
                
                ESTRATEGIA PROGRESIVA:
                - Etapa 12A: Tolerancia Ampliada (¬±5.0) - FECHA exacta + MONTO flexible
                - Etapa 12B: Fechas Aproximadas (¬±2 d√≠as) - MONTO exacto + FECHA flexible
                - Etapa 12C: Solo Montos Exactos - Ignorar fechas completamente
                
                CRITERIOS:
                - Solo registros PENDIENTES de cualquier libro
                - Cada etapa toma lo que la anterior no pudo conciliar
                - Normalizaci√≥n completa de fechas y montos
                
                ESTADOS RESULTANTES:
                - "P12 - Conciliaci√≥n A" (tolerancia ampliada)
                - "P12 - Conciliaci√≥n B" (fechas aproximadas)
                - "P12 - Conciliaci√≥n C" (solo montos exactos)
                
                REFERENCIAS:
                - Mayor: #REF = [Operaci√≥n - N√∫mero del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                // // console.log(`üìà PASO 12: Iniciando conciliaci√≥n MULTI-CRITERIO PROGRESIVA`);
                // console.log(`üîç Total filas a revisar: ${dataRowsMayor.length}`);
                // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                let conciliadosEtapa12A = 0;
                let conciliadosEtapa12B = 0;
                let conciliadosEtapa12C = 0;
                
                // Identificar candidatos PENDIENTES (cualquier libro)
                const candidatosPendientes = [];
                
                for (let i = 0; i < dataRowsMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = dataRowsMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Determinar monto principal (DEBE o HABER, el que sea mayor)
                    const montoPrincipal = Math.max(debe, haber);
                    
                    if (montoPrincipal > 0) {
                        candidatosPendientes.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            fdoc: fdoc,
                            debe: debe,
                            haber: haber,
                            montoPrincipal: montoPrincipal,
                            comprob: comprob
                        });
                    }
                }
                
                // // console.log(`üìä PASO 12 - CANDIDATOS PENDIENTES:`);
                // console.log(`   üéØ Total registros pendientes: ${candidatosPendientes.length}`);
                
                if (candidatosPendientes.length === 0) {
                    // // console.log(`‚ö†Ô∏è No se encontraron registros pendientes para PASO 12`);
                    return { etapa12a: 0, etapa12b: 0, etapa12c: 0, totalConciliados: 0 };
                }
                
                // ETAPA 12A: Tolerancia Ampliada (¬±5.0)
                // console.log(`\nüéØ ETAPA 12A: Tolerancia Ampliada (¬±5.0)`);
                conciliadosEtapa12A = this.procesarEtapa12A(candidatosPendientes, extractoProcesable, idxE, estadosFilas, estadosExtracto);
                // console.log(`   ‚úÖ Etapa 12A: ${conciliadosEtapa12A} conciliaciones con tolerancia ampliada`);
                
                // ETAPA 12B: Fechas Aproximadas (¬±2 d√≠as)
                // console.log(`\nüéØ ETAPA 12B: Fechas Aproximadas (¬±2 d√≠as)`);
                conciliadosEtapa12B = this.procesarEtapa12B(candidatosPendientes, extractoProcesable, idxE, estadosFilas, estadosExtracto);
                // console.log(`   ‚úÖ Etapa 12B: ${conciliadosEtapa12B} conciliaciones con fechas aproximadas`);
                
                // ETAPA 12C: Solo Montos Exactos
                // console.log(`\nüéØ ETAPA 12C: Solo Montos Exactos (ignorar fechas)`);
                conciliadosEtapa12C = this.procesarEtapa12C(candidatosPendientes, extractoProcesable, idxE, estadosFilas, estadosExtracto);
                // console.log(`   ‚úÖ Etapa 12C: ${conciliadosEtapa12C} conciliaciones por montos exactos`);
                
                const totalConciliados = conciliadosEtapa12A + conciliadosEtapa12B + conciliadosEtapa12C;
                
                // // console.log(`üìä PASO 12 - RESUMEN COMPLETO:`);
                // console.log(`   üéØ Registros pendientes iniciales: ${candidatosPendientes.length}`);
                // console.log(`   üÖ∞Ô∏è Etapa 12A (Tolerancia ¬±5.0): ${conciliadosEtapa12A} conciliaciones`);
                // console.log(`   üÖ±Ô∏è Etapa 12B (Fechas ¬±2 d√≠as): ${conciliadosEtapa12B} conciliaciones`);
                // console.log(`   üÖ≤ Etapa 12C (Solo montos): ${conciliadosEtapa12C} conciliaciones`);
                // console.log(`   üìà TOTAL conciliado: ${totalConciliados} registros`);
                // console.log(`   üí∞ Estrategia: Conciliaci√≥n progresiva multi-criterio`);
                
                return {
                    candidatos: candidatosPendientes.length,
                    etapa12a: conciliadosEtapa12A,
                    etapa12b: conciliadosEtapa12B,
                    etapa12c: conciliadosEtapa12C,
                    totalConciliados: totalConciliados
                };
            },

            procesarEtapa12A(candidatosPendientes, extractoProcesable, idxE, estadosFilas, estadosExtracto) {
                /*
                ETAPA 12A - TOLERANCIA AMPLIADA:
                - FECHA exacta + MONTO con tolerancia ¬±5.0
                - Estado: "P12 - Conciliaci√≥n A"
                */
                let conciliados = 0;
                
                for (const candidato of candidatosPendientes) {
                    // Saltar si ya fue procesado
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    const match = this.buscarMatchPorToleranciaAmpliada(candidato.fdoc, candidato.montoPrincipal, extractoProcesable, idxE, estadosExtracto);
                    
                    if (match.encontrado) {
                        const refMayor = match.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P12 - Conciliaci√≥n A',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(match.indice, {
                            estado: 'P12 - Conciliaci√≥n A',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                        // console.log(`‚úÖ ETAPA 12A - CONCILIACI√ìN:`);
                        // console.log(`   üìã Mayor: LIBRO=${candidato.libro}, FDOC="${candidato.fdoc}", MONTO=${candidato.montoPrincipal}, COMPROB=${candidato.comprob} ‚Üí REF="${refMayor}"`);
                        // console.log(`   üìã Extracto: FECHA="${match.fecha}", MONTO=${match.monto}, Diferencia: ${match.diferencia.toFixed(4)} ‚Üí REF="${refExtracto}"`);
                    }
                }
                
                return conciliados;
            },

            procesarEtapa12B(candidatosPendientes, extractoProcesable, idxE, estadosFilas, estadosExtracto) {
                /*
                ETAPA 12B - FECHAS APROXIMADAS:
                - MONTO exacto (tolerancia ¬±0.1) + FECHA ¬±2 d√≠as
                - Estado: "P12 - Conciliaci√≥n B"
                */
                let conciliados = 0;
                
                for (const candidato of candidatosPendientes) {
                    // Saltar si ya fue procesado
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    const match = this.buscarMatchPorFechasAproximadas(candidato.fdoc, candidato.montoPrincipal, extractoProcesable, idxE, estadosExtracto);
                    
                    if (match.encontrado) {
                        const refMayor = match.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P12 - Conciliaci√≥n B',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(match.indice, {
                            estado: 'P12 - Conciliaci√≥n B',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                        // console.log(`‚úÖ ETAPA 12B - CONCILIACI√ìN:`);
                        // console.log(`   üìã Mayor: LIBRO=${candidato.libro}, FDOC="${candidato.fdoc}", MONTO=${candidato.montoPrincipal}, COMPROB=${candidato.comprob} ‚Üí REF="${refMayor}"`);
                        // console.log(`   üìã Extracto: FECHA="${match.fecha}", MONTO=${match.monto}, Diferencia d√≠as: ${match.diferenciaDias} ‚Üí REF="${refExtracto}"`);
                    }
                }
                
                return conciliados;
            },

            procesarEtapa12C(candidatosPendientes, extractoProcesable, idxE, estadosFilas, estadosExtracto) {
                /*
                ETAPA 12C - SOLO MONTOS EXACTOS:
                - Solo MONTO exacto (tolerancia ¬±0.1), ignorar fechas
                - Estado: "P12 - Conciliaci√≥n C"
                */
                let conciliados = 0;
                
                for (const candidato of candidatosPendientes) {
                    // Saltar si ya fue procesado
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    const match = this.buscarMatchSoloMonto(candidato.montoPrincipal, extractoProcesable, idxE, estadosExtracto);
                    
                    if (match.encontrado) {
                        const refMayor = match.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P12 - Conciliaci√≥n C',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(match.indice, {
                            estado: 'P12 - Conciliaci√≥n C',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                        // console.log(`‚úÖ ETAPA 12C - CONCILIACI√ìN:`);
                        // console.log(`   üìã Mayor: LIBRO=${candidato.libro}, MONTO=${candidato.montoPrincipal}, COMPROB=${candidato.comprob} ‚Üí REF="${refMayor}"`);
                        // console.log(`   üìã Extracto: FECHA="${match.fecha}", MONTO=${match.monto} (fecha ignorada) ‚Üí REF="${refExtracto}"`);
                    }
                }
                
                return conciliados;
            },

            buscarMatchPorToleranciaAmpliada(fdocMayor, montoMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                ETAPA 12A: FECHA exacta + MONTO con tolerancia ¬±5.0
                */
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[idxE.operacion] || ''; // Matriz fija
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtracto = Math.abs(this.normalizarMonto(montoExtractoRaw));
                    
                    // FECHA exacta + MONTO tolerancia ¬±5.0
                    const fechasCoinciden = fechaMayorNormalizada === fechaExtractoNormalizada;
                    const diferenciaMonto = Math.abs(montoMayor - montoExtracto);
                    const montosCoinciden = diferenciaMonto <= 5.0; // Tolerancia ampliada
                    
                    if (fechasCoinciden && montosCoinciden) {
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            diferencia: diferenciaMonto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                return { encontrado: false };
            },

            buscarMatchPorFechasAproximadas(fdocMayor, montoMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                ETAPA 12B: MONTO exacto (¬±0.1) + FECHA ¬±2 d√≠as
                */
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                if (!fechaMayorNormalizada) return { encontrado: false };
                
                const fechaMayorObj = new Date(fechaMayorNormalizada);
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[idxE.operacion] || ''; // Matriz fija
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtracto = Math.abs(this.normalizarMonto(montoExtractoRaw));
                    
                    if (!fechaExtractoNormalizada) continue;
                    const fechaExtractoObj = new Date(fechaExtractoNormalizada);
                    
                    // MONTO exacto + FECHA ¬±2 d√≠as
                    const diferenciaMonto = Math.abs(montoMayor - montoExtracto);
                    const montosCoinciden = diferenciaMonto <= 0.1; // Tolerancia normal
                    
                    const diferenciaDias = Math.abs((fechaMayorObj - fechaExtractoObj) / (1000 * 60 * 60 * 24));
                    const fechasAproximadas = diferenciaDias <= 2; // ¬±2 d√≠as
                    
                    if (montosCoinciden && fechasAproximadas) {
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            diferenciaDias: diferenciaDias,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                return { encontrado: false };
            },

            buscarMatchSoloMonto(montoMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                ETAPA 12C: Solo MONTO exacto (¬±0.1), ignorar fechas completamente
                */
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[idxE.operacion] || ''; // Matriz fija
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtracto = Math.abs(this.normalizarMonto(montoExtractoRaw));
                    
                    // Solo MONTO exacto (ignorar fechas)
                    const diferenciaMonto = Math.abs(montoMayor - montoExtracto);
                    const montosCoinciden = diferenciaMonto <= 0.1; // Tolerancia normal
                    
                    if (montosCoinciden) {
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                return { encontrado: false };
            },

            buscarMatchExtractoPorGrupo(fechaGrupo, totalHaber, extractoProcesable, idxE, estadosExtracto) {
                /*
                Busca un match en el extracto para PASO 5 (grupos):
                - Compara fecha del grupo vs FECHA (Extracto col A)
                - Compara total HABER del grupo vs |MONTO| (Extracto col D en VALOR ABSOLUTO)
                - Retorna datos del match si se encuentra
                NOTA: Los montos del extracto est√°n en negativo, se usa Math.abs()
                */
                
                // // console.log(`üîç Buscando match para grupo: fecha="${fechaGrupo}", total=${totalHaber}`);
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    // console.log(`‚ùå Error: extractoProcesable no es v√°lido`);
                    return { encontrado: false };
                }
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    candidatosRevisados++;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[idxE.operacion] || ''; // Matriz fija - Operaci√≥n
                    
                    // Normalizar fecha y monto del extracto
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtractoRaw_parsed = this.normalizarMonto(montoExtractoRaw);
                    const montoExtracto = Math.abs(montoExtractoRaw_parsed); // VALOR ABSOLUTO para extracto
                    
                    // Comparar fechas y montos
                    const fechasCoinciden = fechaGrupo === fechaExtractoNormalizada;
                    const diferenciaMonto = Math.abs(totalHaber - montoExtracto);
                    const montosCoinciden = diferenciaMonto === 0; // Exacto
                    
                    // if (candidatosRevisados <= 5) {
                    //     // console.log(`   üîç Candidato ${candidatosRevisados}:`);
                    //     // console.log(`      Fecha: "${fechaExtractoRaw}" ‚Üí "${fechaExtractoNormalizada}" | Match: ${fechasCoinciden ? '‚úÖ' : '‚ùå'}`);
                    //     // console.log(`      Monto: ${montoExtractoRaw} ‚Üí abs(${montoExtracto}) | Diferencia: ${diferenciaMonto.toFixed(4)} | Match: ${montosCoinciden ? '‚úÖ' : '‚ùå'}`);
                    // }
                    
                    if (fechasCoinciden && montosCoinciden) {
                        // // console.log(`‚úÖ MATCH COMPLETO encontrado en √≠ndice ${i}`);
                        // // console.log(`   üìã Operaci√≥n-N√∫mero del extracto: "${operacionNumero}" (se asignar√° a todas las filas del grupo)`);
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                // // console.log(`‚ùå No se encontr√≥ match despu√©s de revisar ${candidatosRevisados} candidatos`);
                return { encontrado: false };
            },

            buscarMatchExtracto(fdocMayor, debeMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                Busca un match en el extracto para PASO 4:
                - Compara FDOC (Mayor) vs FECHA (Extracto col A)
                - Compara DEBE (Mayor) vs |MONTO| (Extracto col D en VALOR ABSOLUTO)
                - Retorna datos del match si se encuentra
                NOTA: Los montos del extracto est√°n en negativo, se usa Math.abs()
                */
                
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                // // console.log(`üîç Buscando match para FDOC="${fdocMayor}" (normalizado: "${fechaMayorNormalizada}"), DEBE=${debeMayor}`);
                
                let candidatosRevisados = 0;
                let mejoresMatches = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Saltar si ya est√° procesado
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila; // Acceder a la fila dentro del objeto
                    const fechaExtracto = filaExtracto[0] || ''; // Columna A
                    const montoExtractoRaw = this.normalizarMonto(filaExtracto[3] || '0'); // Columna D
                    const montoExtracto = Math.abs(montoExtractoRaw); // VALOR ABSOLUTO para extracto
                    const operacionNumero = filaExtracto[idxE.operacion] || ''; // Matriz fija // Columna G
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                    
                    // Comparar fechas y montos
                    const fechasCoinciden = fechaMayorNormalizada && fechaExtractoNormalizada && fechaMayorNormalizada === fechaExtractoNormalizada;
                    const diferenciaMontos = Math.abs(debeMayor - montoExtracto);
                    const montosCoinciden = diferenciaMontos === 0; // Exacto para PASO 4
                    
                    candidatosRevisados++;
                    
                    // Log detallado solo para matches prometedores
                    if (fechasCoinciden || montosCoinciden || candidatosRevisados <= 2) {
                        // // console.log(`   üîç Candidato ${candidatosRevisados} (√≠ndice ${i}):`);
                        // // console.log(`      Fecha: "${fechaExtracto}" ‚Üí "${fechaExtractoNormalizada}" | Match: ${fechasCoinciden ? '‚úÖ' : '‚ùå'}`);
                        // // console.log(`      Monto: ${montoExtractoRaw} ‚Üí abs(${montoExtracto}) | Diferencia: ${diferenciaMontos.toFixed(4)} | Match: ${montosCoinciden ? '‚úÖ' : '‚ùå'}`);
                        // // console.log(`      Operaci√≥n: "${operacionNumero}"`);
                        
                        if (fechasCoinciden || montosCoinciden) {
                            mejoresMatches.push({
                                indice: i,
                                fechaMatch: fechasCoinciden,
                                montoMatch: montosCoinciden,
                                diferenciaMonto: diferenciaMontos,
                                fechaExtracto: fechaExtracto,
                                montoExtracto: montoExtracto
                            });
                        }
                    }
                    
                    if (fechasCoinciden && montosCoinciden) {
                        // console.log(`‚úÖ MATCH COMPLETO encontrado en √≠ndice ${i}`);
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtracto,
                            monto: montoExtracto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                // console.log(`‚ùå No se encontr√≥ match completo. Revisados: ${candidatosRevisados} candidatos`);
                if (mejoresMatches.length > 0) {
                    // console.log(`   üìã Mejores candidatos parciales:`);
                    mejoresMatches.slice(0, 3).forEach((match, idx) => {
                        // console.log(`      ${idx + 1}. Fecha ${match.fechaMatch ? '‚úÖ' : '‚ùå'}, Monto ${match.montoMatch ? '‚úÖ' : '‚ùå'} (diff: ${match.diferenciaMonto.toFixed(4)})`);
                    });
                }
                
                return {
                    encontrado: false,
                    indice: -1,
                    fecha: '',
                    monto: 0,
                    operacionNumero: ''
                };
            },

            normalizarFecha(fechaRaw) {
                /*
                Normaliza fechas a formato YYYY-MM-DD para comparaci√≥n
                Maneja m√∫ltiples formatos de entrada:
                - DD/MM/YYYY, DD-MM-YYYY
                - YYYY/MM/DD, YYYY-MM-DD
                - DD/MM/YY, etc.
                - N√∫meros seriales de Excel (45809 = d√≠as desde 1900-01-01)
                */
                
                if (!fechaRaw) return '';
                
                const fechaStr = fechaRaw.toString().trim();
                if (!fechaStr) return '';
                
                // Detectar si es un n√∫mero serial de Excel (5 d√≠gitos aproximadamente)
                const numeroSerial = parseFloat(fechaStr);
                if (!isNaN(numeroSerial) && numeroSerial > 1 && numeroSerial < 100000 && !fechaStr.includes('/') && !fechaStr.includes('-')) {
                    const fechaConvertida = this.convertirSerialExcelAFecha(numeroSerial);
                    // MEJORADO: Log para m√°s casos espec√≠ficos que estamos analizando
                    // if (numeroSerial >= 45800 && numeroSerial <= 45900) {
                    //     // console.log(`üîÑ FECHA Serial Excel ${numeroSerial} ‚Üí "${fechaConvertida}"`);
                    // }
                    return fechaConvertida;
                }
                
                // Limpiar y detectar separadores para fechas normales
                const separadores = ['-', '/', '.'];
                let separador = null;
                
                for (const sep of separadores) {
                    if (fechaStr.includes(sep)) {
                        separador = sep;
                        break;
                    }
                }
                
                if (!separador) {
                    return '';
                }
                
                const partes = fechaStr.split(separador);
                if (partes.length !== 3) {
                    return '';
                }
                
                let dia, mes, ano;
                
                // Detectar formato basado en longitud y valores
                const [p1, p2, p3] = partes.map(p => parseInt(p, 10));
                
                if (p1 > 31) {
                    // Formato YYYY-MM-DD o YYYY-DD-MM
                    ano = p1;
                    if (p2 > 12) {
                        mes = p3;
                        dia = p2;
                    } else {
                        mes = p2;
                        dia = p3;
                    }
                } else if (p3 > 31 || (p3 > 24 && p3 < 100)) {
                    // Formato DD-MM-YYYY o MM-DD-YYYY
                    ano = p3 < 100 ? 2000 + p3 : p3;
                    if (p1 > 12) {
                        dia = p1;
                        mes = p2;
                    } else if (p2 > 12) {
                        dia = p2;
                        mes = p1;
                    } else {
                        // Asumir DD-MM-YYYY
                        dia = p1;
                        mes = p2;
                    }
                } else {
                    return '';
                }
                
                // Validar rangos
                if (mes < 1 || mes > 12 || dia < 1 || dia > 31 || ano < 1900) {
                    return '';
                }
                
                // Formatear con ceros a la izquierda
                const mesStr = mes.toString().padStart(2, '0');
                const diaStr = dia.toString().padStart(2, '0');
                
                return `${ano}-${mesStr}-${diaStr}`;
            },

            convertirSerialExcelAFecha(serial) {
                /*
                Convierte n√∫meros seriales de Excel a fechas
                Excel usa 1899-12-30 como d√≠a 0, 1900-01-01 como d√≠a 2 (bug hist√≥rico)
                */
                
                // Fecha base de Excel: 1899-12-30 00:00:00 (d√≠a 0)
                const fechaBase = new Date(1899, 11, 30, 0, 0, 0, 0);
                
                // Agregar los d√≠as directamente
                const fechaResultado = new Date(fechaBase.getTime() + serial * 24 * 60 * 60 * 1000);
                
                // Formatear a YYYY-MM-DD
                const a√±o = fechaResultado.getFullYear();
                const mes = (fechaResultado.getMonth() + 1).toString().padStart(2, '0');
                const dia = fechaResultado.getDate().toString().padStart(2, '0');
                
                return `${a√±o}-${mes}-${dia}`;
            },

            procesarPaso3(filaMayor, extracto, idxM, idxE, todasLasFilasMayor, saldoData = null, indiceFilaActual = -1) {
        /*
        PASO 3 - PROCESAMIENTO DE DOCUMENTOS ANULADOS (3 ETAPAS):
        
        ETAPA 3a: Filtrar por GLOSA contiene "ANULADO" (se hace en el bucle principal)
        ETAPA 3b: Mayor vs Saldo por NUMDOC ‚Üí ESTADO="P3 - Conciliada", REF="Anulado Saldo" (PRIMERO)
        ETAPA 3c: Mayor interno por NUMDOC + coincidencia exacta (SEGUNDO):
        - DEBE ‚Üí ESTADO="P3 - Conciliada", REF="Anula a [valor_comprob]" 
        - HABER ‚Üí ESTADO="P3 - Conciliada", REF="Anulado por [valor_comprob]"
        */
        
        const glosa = filaMayor[idxM.glosa] || '';
        
        // ETAPA 3a: Verificar si tiene "ANULADO" en GLOSA
        if (!glosa.toUpperCase().includes("ANULADO")) {
            return { estado: '', ref: '', etapa: 0 };
        }
        
        const fecha = filaMayor[idxM.fdoc];
        const montoDebe = this.normalizarMonto(filaMayor[idxM.debe] || 0);
        const montoHaber = this.normalizarMonto(filaMayor[idxM.haber] || 0);
        const numdoc = filaMayor[idxM.numdoc] || '';
        const comprob = filaMayor[idxM.comprob] || '';
        
        // Determinar si est√° en DEBE o HABER y el monto a buscar
        const estaEnDebe = montoDebe > 0;
        const montoABuscar = estaEnDebe ? montoDebe : montoHaber;
        
        // // console.log(`üîç PASO 3 procesando: NUMDOC=${numdoc}, DEBE=${montoDebe}, HABER=${montoHaber}, estaEnDebe=${estaEnDebe}`);
        
        // ETAPA 3b: MAPEAR MAYOR VS SALDO POR NUMDOC ‚Üí ESTADO="P3 - Conciliada", REF="Anulado Saldo" (PRIMERO)
        if (saldoData && saldoData.length > 1) {
            // Mapear √≠ndices del saldo
            const headerSaldo = saldoData[0] || [];
            const indicesSaldo = this.buscarIndicesColumnas(headerSaldo, {
                cuenta: ['CUENTA'], numdoc: ['NUMDOC'], debe: ['DEBE'], haber: ['HABER'], 
                fdoc: ['FDOC'], comprobante: ['COMPROBANTE', 'COMPROB']
            });
            
            const filasSaldo = saldoData.slice(1);
            
            // Normalizar NUMDOC del mayor para comparaci√≥n
            const numdocMayorNormalizado = this.normalizarTexto(numdoc);
            
            for (let idx = 0; idx < filasSaldo.length; idx++) {
                const filaSaldo = filasSaldo[idx];
                const numdocSaldoRaw = filaSaldo[indicesSaldo.numdoc] || '';
                const numdocSaldoNormalizado = this.normalizarTexto(numdocSaldoRaw);
                const debeSaldoRaw = filaSaldo[indicesSaldo.debe] || '';
                const haberSaldoRaw = filaSaldo[indicesSaldo.haber] || '';
                
                // Normalizar y parsear montos
                const debeSaldo = this.normalizarMonto(debeSaldoRaw);
                const haberSaldo = this.normalizarMonto(haberSaldoRaw);
                
                // Columna M (√≠ndice 12) para Comprobante
                const comprobanteSaldo = filaSaldo[12] || filaSaldo[indicesSaldo.comprobante] || '';
                
                // Buscar por NUMDOC normalizado
                if (numdocMayorNormalizado && numdocSaldoNormalizado && numdocMayorNormalizado === numdocSaldoNormalizado) {
                    // console.log(`   üéØ MATCH NUMDOC encontrado en fila ${idx + 2} del saldo:`);
                    // console.log(`      Mayor NUMDOC: "${numdoc}" ‚Üí normalizado: "${numdocMayorNormalizado}"`);
                    // console.log(`      Saldo NUMDOC: "${numdocSaldoRaw}" ‚Üí normalizado: "${numdocSaldoNormalizado}"`);
                    // console.log(`      Saldo DEBE raw: "${debeSaldoRaw}" ‚Üí parseado: ${debeSaldo}`);
                    // console.log(`      Saldo HABER raw: "${haberSaldoRaw}" ‚Üí parseado: ${haberSaldo}`);
                    // console.log(`      Saldo Comprobante (col M): "${comprobanteSaldo}"`);
                    // console.log(`      Mayor: DEBE=${montoDebe}, HABER=${montoHaber}, estaEnDebe=${estaEnDebe}, montoABuscar=${montoABuscar}`);
                    
                    // Comparar tanto DEBE como HABER del saldo con el monto del mayor
                    const diferenciaDebe = Math.abs(montoABuscar - debeSaldo);
                    const diferenciaHaber = Math.abs(montoABuscar - haberSaldo);
                    
                    // console.log(`      Comparando montos:`);
                    // console.log(`        Mayor ${estaEnDebe ? 'DEBE' : 'HABER'}=${montoABuscar} vs Saldo DEBE=${debeSaldo}, diferencia=${diferenciaDebe}`);
                    // console.log(`        Mayor ${estaEnDebe ? 'DEBE' : 'HABER'}=${montoABuscar} vs Saldo HABER=${haberSaldo}, diferencia=${diferenciaHaber}`);
                    
                    // Si cualquiera de las dos diferencias es exacta, es un match
                    if (diferenciaDebe === 0 || diferenciaHaber === 0) {
                        const mejorMatch = diferenciaDebe < diferenciaHaber ? 'DEBE' : 'HABER';
                        const mejorDiferencia = Math.min(diferenciaDebe, diferenciaHaber);
                        // // console.log(`‚úÖ ETAPA 3b - ANULADO SALDO: Mayor NUMDOC=${numdoc} ‚Üî Saldo NUMDOC=${numdocSaldoRaw}`);
                        // // console.log(`   üìã Mejor match: Saldo ${mejorMatch} (diferencia: ${mejorDiferencia})`);
                        // // console.log(`   üìã REF asignado: "${comprobanteSaldo}"`);
                        return { 
                            estado: 'P3 - Conciliada', 
                            ref: 'Anulado Saldo', 
                            etapa: 2,
                            indiceParejaEncontrada: idx,
                            estadoPareja: 'P3 - Conciliada',
                            refPareja: 'Anulado Mayor'
                        };
                    } else {
                        // console.log(`   ‚ùå Montos no coinciden (mejores diferencias: DEBE=${diferenciaDebe}, HABER=${diferenciaHaber})`);
                    }
                }
            }
            
        } else {
            // // console.log(`‚ö†Ô∏è ETAPA 3b: No hay datos de saldo disponibles`);
        }
        
        // ETAPA 3c: MAPEAR DENTRO DEL MAYOR POR NUMDOC CON DEBE/HABER (SEGUNDO)
        // // console.log(`‚ö° ETAPA 3c: Buscando mapeo interno en mayor para NUMDOC=${numdoc}`);
        // // console.log(`   üìã Registro actual: DEBE=${montoDebe}, HABER=${montoHaber} ‚Üí busca ${estaEnDebe ? 'HABER' : 'DEBE'} con monto ${montoABuscar}`);
        
        let candidatosEncontrados = 0;
        const numdocMayorNormalizado = this.normalizarTexto(numdoc);
        const candidatosDetalle = [];
        
        for (let i = 0; i < todasLasFilasMayor.length; i++) {
            const otraFila = todasLasFilasMayor[i];
            
            // Saltar la misma fila
            if (otraFila === filaMayor) continue;
            
            const otroMontoDebe = this.normalizarMonto(otraFila[idxM.debe] || 0);
            const otroMontoHaber = this.normalizarMonto(otraFila[idxM.haber] || 0);
            const otroNumdocRaw = otraFila[idxM.numdoc] || '';
            const otroNumdocNormalizado = this.normalizarTexto(otroNumdocRaw);
            const otroComprob = otraFila[idxM.comprob] || '';
            const otraGlosa = otraFila[idxM.glosa] || '';
            
            // Criterios: mismo NUMDOC normalizado
            const coincidenNumdoc = numdocMayorNormalizado && otroNumdocNormalizado && (numdocMayorNormalizado === otroNumdocNormalizado);
            
            if (coincidenNumdoc) {
                candidatosEncontrados++;
                
                // Verificar si est√° en la columna contraria y con el mismo monto (exacto)
                const montoAComparar = estaEnDebe ? otroMontoHaber : otroMontoDebe;
                const diferenciaMonto = Math.abs(montoAComparar - montoABuscar);
                const coincideMonto = diferenciaMonto === 0;
                
                // Guardar detalles del candidato
                candidatosDetalle.push({
                    fila: i + 1,
                    numdoc: otroNumdocRaw,
                    debe: otroMontoDebe,
                    haber: otroMontoHaber,
                    comprob: otroComprob,
                    montoComparar: montoAComparar,
                    diferencia: diferenciaMonto,
                    coincide: coincideMonto
                });
                
                // console.log(`   üîç Candidato ${candidatosEncontrados}: NUMDOC="${otroNumdocRaw}" (fila ${i + 1})`);
                // console.log(`      Este: DEBE=${montoDebe}, HABER=${montoHaber}, busca ${estaEnDebe ? 'HABER' : 'DEBE'}=${montoABuscar}`);
                // console.log(`      Otro: DEBE=${otroMontoDebe}, HABER=${otroMontoHaber}, encontrado=${montoAComparar}`);
                // console.log(`      Diferencia: ${diferenciaMonto.toFixed(4)} ${coincideMonto ? '‚úÖ COINCIDE' : '‚ùå NO COINCIDE'}`);
                // console.log(`      COMPROB: "${otroComprob}"`);
                
                if (coincideMonto) {
                    // // console.log(`\n‚úÖ ETAPA 3c - ¬°ANULACI√ìN ENCONTRADA!`);
                    // // console.log(`   üéØ NUMDOC: ${numdoc} (normalizado: ${numdocMayorNormalizado})`);
                    // // console.log(`   üìã Registro A (actual): DEBE=${montoDebe}, HABER=${montoHaber}, COMPROB="${comprob}"`);
                    // // console.log(`   üìã Registro B (pareja): DEBE=${otroMontoDebe}, HABER=${otroMontoHaber}, COMPROB="${otroComprob}"`);
                    // // console.log(`   üí∞ Monto que coincide: ${montoABuscar}`);
                    
                    // Determinar estados seg√∫n DEBE/HABER y usar COMPROB de la pareja
                    if (estaEnDebe) {
                        // Este registro est√° en DEBE ‚Üí "Anula a [comprob_de_la_pareja]"
                        // La pareja est√° en HABER ‚Üí "Anulado por [comprob_de_este]"
                        // console.log(`   ‚úÖ Este registro (DEBE) ANULA AL OTRO (HABER)`);
                        // console.log(`   üìã Este: ESTADO="P3 - Conciliada", REF="Anula a ${otroComprob}"`);
                        // console.log(`   üìã Pareja: ESTADO="P3 - Conciliada", REF="Anulado por ${comprob}"`);
                        
                        return { 
                            estado: 'P3 - Conciliada', 
                            ref: `Anula a ${otroComprob}`, 
                            etapa: 3,
                            indiceParejaEncontrada: i,
                            estadoPareja: 'P3 - Conciliada',
                            refPareja: `Anulado por ${comprob}`
                        };
                    } else {
                        // Este registro est√° en HABER ‚Üí "Anulado por [comprob_de_la_pareja]"
                        // La pareja est√° en DEBE ‚Üí "Anula a [comprob_de_este]"
                        // console.log(`   ‚úÖ Este registro (HABER) ES ANULADO POR EL OTRO (DEBE)`);
                        // console.log(`   üìã Este: ESTADO="P3 - Conciliada", REF="Anulado por ${otroComprob}"`);
                        // console.log(`   üìã Pareja: ESTADO="P3 - Conciliada", REF="Anula a ${comprob}"`);
                        
                        return { 
                            estado: 'P3 - Conciliada', 
                            ref: `Anulado por ${otroComprob}`, 
                            etapa: 3,
                            indiceParejaEncontrada: i,
                            estadoPareja: 'P3 - Conciliada',
                            refPareja: `Anula a ${comprob}`
                        };
                    }
                }
            }
        }
        
        // Si llegamos aqu√≠, mostrar resumen
        // // console.log(`   üìä ETAPA 3c - Resumen: ${candidatosEncontrados} candidatos con mismo NUMDOC`);
        if (candidatosDetalle.length > 0) {
            // // console.log(`   üìã Candidatos encontrados:`);
            candidatosDetalle.forEach((cand, idx) => {
                // // console.log(`      ${idx + 1}. Fila ${cand.fila}: DEBE=${cand.debe}, HABER=${cand.haber}, diff=${cand.diferencia.toFixed(4)} ${cand.coincide ? '‚úÖ' : '‚ùå'}`);
            });
        }
        
        // Si llegamos aqu√≠, no se pudo procesar la anulaci√≥n
        // // console.log(`‚ùå PASO 3 - No procesado: NUMDOC=${numdoc} (${candidatosEncontrados} candidatos internos encontrados)`);
        return { 
            estado: '', 
            ref: '', 
            etapa: 0,
            indiceParejaEncontrada: -1,
            estadoPareja: '',
            refPareja: ''
        };
            },
     
            buscarIndicesColumnas(headers, mapeo) {
         const indices = {};
         for (const [clave, posiblesNombres] of Object.entries(mapeo)) {
            let encontrado = false;
             for (let i = 0; i < headers.length; i++) {
                 const header = (headers[i] || '').toString().toUpperCase().trim();
                if (posiblesNombres.some(nombre => header.includes(nombre.toUpperCase()))) {
                         indices[clave] = i;
                    encontrado = true;
                         break;
                     }
                 }
            if (!encontrado) indices[clave] = -1;
         }
         return indices;
            },
     
            // Funci√≥n para normalizar texto (eliminar espacios, convertir a may√∫sculas)
            normalizarTexto(texto) {
                if (!texto) return '';
                let normalizado = texto.toString().trim().toUpperCase().replace(/\s+/g, '');
                
                // Si es un n√∫mero puro, eliminar ceros a la izquierda pero mantener al menos un d√≠gito
                if (/^\d+$/.test(normalizado)) {
                    normalizado = normalizado.replace(/^0+/, '') || '0';
                }
                
                return normalizado;
            },
            
            // Funci√≥n para normalizar y parsear montos
            normalizarMonto(montoRaw) {
                if (!montoRaw) return 0;
                
                // Convertir a string y limpiar espacios
                let montoStr = montoRaw.toString().trim().replace(/\s+/g, '');
                
                // Si est√° vac√≠o despu√©s de limpiar, retornar 0
                if (!montoStr) return 0;
                
                // Detectar diferentes formatos de n√∫meros
                let montoLimpio;
                let tipoFormato = '';
                
                // NUEVO: Manejar n√∫meros negativos
                const esNegativo = montoStr.startsWith('-');
                if (esNegativo) {
                    montoStr = montoStr.substring(1);
                }
                
                // Formato 1: Solo n√∫meros con coma decimal (18956,26)
                if (/^\d+,\d+$/.test(montoStr)) {
                    montoLimpio = montoStr.replace(',', '.');
                    tipoFormato = 'europeo simple';
                }
                // Formato 2: Formato europeo con separador de miles punto y decimal coma (46.744,48)
                else if (/^\d{1,3}(\.\d{3})+,\d{2,}$/.test(montoStr)) {
                    montoLimpio = montoStr.replace(/\./g, '').replace(',', '.');
                    tipoFormato = 'europeo con separador miles';
                }
                // Formato 3: Formato americano con separador de miles coma y decimal punto (46,744.48)
                else if (/^\d{1,3}(,\d{3})+\.\d{2,}$/.test(montoStr)) {
                    montoLimpio = montoStr.replace(/,/g, '');
                    tipoFormato = 'americano con separador miles';
                }
                // Formato 4: Solo punto decimal (18956.26)
                else if (/^\d+\.\d+$/.test(montoStr)) {
                    montoLimpio = montoStr;
                    tipoFormato = 'decimal punto';
                }
                // Formato 5: Solo n√∫meros enteros (18956)
                else if (/^\d+$/.test(montoStr)) {
                    montoLimpio = montoStr;
                    tipoFormato = 'entero';
                }
                // MEJORADO: Formato mixto problem√°tico - detectar contexto
                else if (montoStr.includes(',') && montoStr.includes('.')) {
                    // Si hay m√°s puntos que comas, probablemente sea europeo (46.744,48)
                    const puntos = (montoStr.match(/\./g) || []).length;
                    const comas = (montoStr.match(/,/g) || []).length;
                    
                    if (puntos > comas) {
                        // Europeo: punto separador miles, coma decimal
                        montoLimpio = montoStr.replace(/\./g, '').replace(',', '.');
                        tipoFormato = 'mixto - europeo detectado';
                    } else {
                        // Americano: coma separador miles, punto decimal
                        montoLimpio = montoStr.replace(/,/g, '');
                        tipoFormato = 'mixto - americano detectado';
                    }
                }
                // Por defecto: eliminar todo excepto n√∫meros y punto
                else {
                    montoLimpio = montoStr.replace(/[^0-9.]/g, '');
                    tipoFormato = 'limpieza general';
                }
                
                let monto = parseFloat(montoLimpio);
                if (isNaN(monto)) monto = 0;
                
                // Aplicar signo negativo si corresponde
                if (esNegativo) monto = -monto;
                
                const resultado = monto;
                
                // MEJORADO: Log detallado para casos espec√≠ficos y problem√°ticos
                // if (montoStr.includes('46744') || montoStr.includes('46.744') || 
                //     montoStr.includes('18956') || montoStr.includes('27788') ||
                //     resultado === 0 || tipoFormato.includes('mixto') || tipoFormato === 'limpieza general') {
                //     // console.log(`üí∞ MONTO "${montoStr}" (${tipoFormato}) ‚Üí ${resultado.toFixed(2)}`);
                // }
                
                return resultado;
            }
        }
    }
</script>

</div>
</body>
</html>