<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conciliador Bancario</title>
    <!-- 
    ======================================================
    CONCILIADOR BANCARIO - VERSI√ìN WORDPRESS
    ======================================================
    
    Esta versi√≥n est√° optimizada para integrarse en WordPress:
    
    ‚úÖ Todos los estilos est√°n encapsulados con la clase .conciliador-bancario-app
    ‚úÖ Se usa !important para prevenir conflictos con temas de WordPress
    ‚úÖ Tailwind CSS configurado con selector important
    ‚úÖ Reset de estilos para elementos cr√≠ticos
    ‚úÖ Isolation CSS para crear contexto de stacking independiente
    
    INTEGRACI√ìN EN WORDPRESS:
    - Insertar el contenido del <body> en una p√°gina/post
    - Asegurar que las librer√≠as CDN est√°n cargadas
    - El contenedor .conciliador-bancario-app a√≠sla los estilos
    
    ====================================================== 
    -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- Cache buster v2 -->
    
<!-- CDN Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/preline@2.0.3/dist/preline.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <script>
        tailwind.config = {
            important: '.conciliador-bancario-app',
            theme: {
                extend: {
                    fontFamily: {
                        'sans': ['Inter', 'ui-sans-serif', 'system-ui', 'sans-serif'],
                    },
                    colors: {
                        primary: {
                            50: '#eff6ff',
                            100: '#dbeafe',
                            200: '#bfdbfe',
                            300: '#93c5fd',
                            400: '#60a5fa',
                            500: '#3b82f6',
                            600: '#2563eb',
                            700: '#1d4ed8',
                            800: '#1e40af',
                            900: '#1e3a8a',
                        }
                    }
                }
            }
        }
    </script>
    
    <style>
        /* Conciliador Bancario - Estilos aislados para WordPress */
        .conciliador-bancario-app [x-cloak] { display: none !important; }
        .conciliador-bancario-app .file-input-area {
            transition: all 0.2s ease !important;
        }
        .conciliador-bancario-app .file-input-area:hover {
            border-color: #3b82f6 !important;
            background-color: #eff6ff !important;
        }
        .conciliador-bancario-app .file-input-area.has-file {
            border-color: #10b981 !important;
            background-color: #ecfdf5 !important;
        }
        
        /* Reset de estilos WordPress que podr√≠an interferir */
        .conciliador-bancario-app * {
            box-sizing: border-box !important;
        }
        
        .conciliador-bancario-app {
            line-height: 1.5 !important;
            font-family: 'Inter', ui-sans-serif, system-ui, sans-serif !important;
            min-height: 100vh !important;
            isolation: isolate !important;
        }
        
        /* Prevenir que los estilos de WordPress afecten los botones y formularios */
        .conciliador-bancario-app button,
        .conciliador-bancario-app input,
        .conciliador-bancario-app select,
        .conciliador-bancario-app textarea {
            font-family: inherit !important;
            font-size: inherit !important;
            line-height: inherit !important;
        }
        
        /* Espaciado espec√≠fico para la lista de archivos */
        .conciliador-bancario-app .space-y-1 > * + * {
            margin-top: 0.25rem !important;
            margin-bottom: 0 !important;
        }
        
        .conciliador-bancario-app .file-item {
            padding: 0.5rem !important;
            margin-top: 0.25rem !important;
            margin-bottom: 0 !important;
        }
        
        .conciliador-bancario-app .space-y-1 {
            gap: 0.25rem !important;
        }
        
        .conciliador-bancario-app .space-y-1 > *:first-child {
            margin-top: 0 !important;
        }
        
        .conciliador-bancario-app .files-container {
            display: flex !important;
            flex-direction: column !important;
            gap: 0.25rem !important;
        }
        
        .conciliador-bancario-app .files-container .file-item {
            margin: 0 !important;
        }
        
        /* Reset de margin-bottom de p√°rrafos que causa el espaciado extra */
        .conciliador-bancario-app .files-container p {
            margin-bottom: 0 !important;
            margin-top: 0 !important;
        }
        
        .conciliador-bancario-app p {
            margin-bottom: 0 !important;
        }
    </style>
</head>

<body>
<div class="conciliador-bancario-app bg-gray-50" x-data="bancarioConciliador()">
    <!-- Header -->
    <div class="max-w-none mx-auto px-4 py-8" style="max-width: 1200px;">
        <h1 class="text-3xl font-bold text-gray-900 mb-8">Conciliador Bancario</h1>

        <!-- Upload Area - Layout Compacto -->
        <div class="mb-8">
            <div class="grid grid-cols-12 gap-6">
                
                <!-- 30% Izquierda: √Årea de Drag & Drop -->
                <div class="col-span-4">
            <div class="border-2 border-dashed border-gray-300 rounded-lg bg-white hover:border-gray-400 transition-colors duration-200 cursor-pointer"
                         style="height: 300px;"
                 :class="{ 'border-blue-500 bg-blue-50': isDragOver }"
                 @dragover.prevent="isDragOver = true"
                 @dragleave.prevent="isDragOver = false"
                 @drop.prevent="handleDrop($event)"
                 @click="$refs.fileInput.click()">
                
                        <div class="p-6 text-center h-full flex flex-col justify-center">
                    <input type="file" 
                           x-ref="fileInput" 
                           multiple 
                           accept=".xlsx,.xls,.csv"
                           @change="handleFileSelect($event)"
                           class="hidden">
                    
                            <div class="mx-auto h-10 w-10 text-gray-400 mb-3">
                                <i class="fas fa-cloud-upload-alt text-3xl"></i>
                    </div>

                            <div class="text-lg text-gray-900 font-medium mb-3">
                                Arrastra archivos aqu√≠
                    </div>
                    
                            <div class="text-sm text-gray-500 mb-3">
                                o haz clic para seleccionar
                            </div>
                            
                            <div class="text-xs text-gray-400">
                                XLSX, XLS, CSV
                            </div>
                            
                            <p class="text-xs text-blue-600 mt-3" x-show="files.length > 0">
                        <i class="fas fa-info-circle mr-1"></i>
                                Auto-guardado activado
                    </p>
                                    </div>
                                </div>
                            </div>

                <!-- 70% Derecha: Lista de Archivos -->
                <div class="col-span-8">
                    <div class="bg-white rounded-lg border border-gray-200 p-6" 
                         :style="`min-height: 300px; height: ${files.length > 0 ? 'auto' : '300px'};`">
                        
                        <!-- Lista de Archivos -->
                        <div x-show="files.length > 0" x-cloak class="h-full flex flex-col">
                            <h3 class="text-lg font-semibold text-gray-900 mb-4">
                                <i class="fas fa-list mr-2 text-blue-600"></i>
                                Archivos cargados (<span x-text="files.length"></span>)
                            </h3>
                            
                            <div class="grid grid-cols-2 gap-2 flex-1 overflow-y-auto">
                <template x-for="file in files" :key="file.id">
                                    <div class="file-item flex items-center p-2 bg-gray-50 border border-gray-200 rounded-lg hover:bg-gray-100 transition-colors duration-200 h-fit">
                        
                                        <div class="flex-shrink-0 w-5 h-5 rounded flex items-center justify-center mr-2 text-sm text-gray-600">
                            <i :class="getFileIcon(file.name)"></i>
    </div>

                        <div class="flex-grow min-w-0">
                            <p class="text-sm font-medium text-gray-900 truncate" x-text="file.name"></p>
    </div>

                        <button @click="deleteFile(file.id)"
                                                class="flex-shrink-0 text-red-500 hover:text-red-700 text-xs ml-1">
                                            <i class="fas fa-times"></i>
                            </button>
            </div>
                </template>
                            </div>
        </div>
                        
                        <!-- Mensaje cuando no hay archivos -->
                        <div x-show="files.length === 0" x-cloak class="h-full flex flex-col items-center justify-center text-center">
                            <div class="text-gray-400 mb-3">
                                <i class="fas fa-file-upload text-4xl"></i>
                            </div>
                            <p class="text-gray-500 text-lg font-medium mb-2">No hay archivos cargados</p>
                            <p class="text-gray-400 text-sm">Arrastra archivos al √°rea de la izquierda para comenzar</p>
                        </div>
                        
                    </div>
                </div>
                
            </div>
        </div>

        <!-- Loading Spinner -->
        <div x-show="isLoading" x-cloak class="text-center py-8">
            <div class="inline-block animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600 mb-2"></div>
            <p class="text-gray-600">Procesando archivos de conciliaci√≥n...</p>
                                    </div>

        <!-- Status Message -->
        <div x-show="statusMessage.show" 
             x-cloak
             class="mb-6 p-4 rounded-md"
             :class="statusMessage.type === 'success' ? 'bg-green-50 text-green-800 border border-green-200' : 'bg-red-50 text-red-800 border border-red-200'">
            <span x-text="statusMessage.text"></span>
                                </div>



                        <!-- Botones de Conciliaci√≥n -->
            <div class="flex justify-center space-x-4">
                <button x-show="canProcessConciliation()"
                        @click="realizarConciliacion()"
                        class="inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 transition-colors duration-200 shadow-sm">
                    <i class="fas fa-balance-scale mr-2"></i>
                    Iniciar conciliaci√≥n bancaria
                </button>
                
                <button x-show="!canProcessConciliation() && files.length > 0"
                        disabled
                        class="inline-flex items-center px-6 py-3 border border-gray-300 text-base font-medium rounded-md text-gray-400 bg-gray-100 cursor-not-allowed">
                    <i class="fas fa-exclamation-triangle mr-2"></i>
                    <span x-text="getMissingFilesMessage()"></span>
                </button>
                
                <!-- RESULTS SECTION REMOVED PER USER REQUEST -->
                
                                <!-- Bot√≥n para cargar archivos de prueba -->
                <button x-show="files.length === 0"
                        @click="loadTestFiles()"
                        class="inline-flex items-center px-4 py-3 border border-green-300 text-base font-medium rounded-md text-green-600 bg-white hover:bg-green-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-500 transition-colors duration-200 shadow-sm"
                        title="Cargar archivos de prueba con nomenclatura: MAYOR.PEN/USD.MMAAAA, BCP.01/02/USD.PEN/USD.MMAAAA, SANT.PEN/USD.MMAAAA, BBVA.PEN/USD.MMAAAA, SBP.PEN/USD.MMAAAA, IBK.PEN.MMAAAA, SALDO.PEN.MMAAAA">
                    <i class="fas fa-flask mr-2"></i>
                    Cargar Archivos de Prueba
                </button>

                <!-- Bot√≥n para limpiar cache -->
                <button x-show="files.length > 0"
                        @click="clearStoredFiles()"
                        class="inline-flex items-center px-4 py-3 border border-red-300 text-base font-medium rounded-md text-red-600 bg-white hover:bg-red-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition-colors duration-200 shadow-sm"
                        title="Limpiar archivos guardados y empezar de nuevo">
                    <i class="fas fa-trash-alt mr-2"></i>
                    Limpiar Todo
                </button>
            </div>
        </div>


</div>

<script>
    function bancarioConciliador() {
        return {
            files: [],
            isDragOver: false,
            isLoading: false,
            statusMessage: {
                show: false,
                text: '',
                type: 'success'
            },
            conciliationResult: null,
            requiredFileTypes: ['mayor', 'extracto', 'resumen'],
            
            // === CONFIGURACI√ìN MULTI-CUENTA ===
            cuentasConfig: {
                '1041501': {
                    codigo: '1041501',
                    banco: 'BCO DE CREDITO M/N',
                    alias: 'BCP.01',
                    moneda: 'PEN',
                    archivoPattern: /^bcp\.01\.pen\.\d{6}/,
                    pesta√±aExcel: 'BCP.01',
                    activo: true, // Actualmente activo
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'bna_operations',
                        paso5: 'prot_dev_grouping',
                        paso6: 'depositos_bancarios',
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_operations',
                        paso11: 'itf_operations',
                        paso12: 'multi_criteria_progressive'
                    }
                },
                '1041505': {
                    codigo: '1041505',
                    banco: 'BCO DE CREDITO M/N',
                    alias: 'BCP.02',
                    moneda: 'PEN',
                    archivoPattern: /^bcp\.02\.pen\.\d{6}/,
                    pesta√±aExcel: 'BCP.02',
                    activo: true, // ACTIVADO - Ahora funcional
                    pasos: {
                        paso3: 'anulaciones_standard', // Misma l√≥gica que BCP.01
                        paso4: 'bna_operations',
                        paso5: 'prot_dev_grouping',
                        paso6: 'depositos_bancarios',
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_operations',
                        paso11: 'itf_operations',
                        paso12: 'multi_criteria_progressive'
                    }
                },
                '1041502': {
                    codigo: '1041502',
                    banco: 'BCO DE CREDITO M/E',
                    alias: 'BCP.USD',
                    moneda: 'USD',
                    archivoPattern: /^bcp\.usd\.\d{6}/,
                    pesta√±aExcel: 'BCP.USD',
                    activo: true, // NUEVO - Cuenta USD
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'bna_operations',
                        paso5: 'prot_dev_grouping',
                        paso6: 'depositos_bancarios',
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_operations',
                        paso11: 'itf_operations',
                        paso12: 'multi_criteria_progressive'
                    }
                },
                '1041402': {
                    codigo: '1041402',
                    banco: 'BCO. SANTANDER M/E',
                    alias: 'SANT.USD',
                    moneda: 'USD',
                    archivoPattern: /^sant\.usd\.\d{6}/,
                    pesta√±aExcel: 'SANT.USD',
                    activo: true, // NUEVO - Cuenta Santander USD
                    estructuraEspecial: {
                        headerFila: 8, // Headers en fila 8 (√≠ndice 7) - igual que SANT.PEN
                        dataInicio: 9   // Datos empiezan en fila 9 (√≠ndice 8)
                    },
                    pasos: {
                        paso3: 'anulaciones_santander', // Misma l√≥gica que SANT.PEN
                        paso4: 'santander_operations',
                        paso5: 'prot_dev_grouping',
                        paso6: 'depositos_santander',
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_santander',
                        paso11: 'itf_operations',
                        paso12: 'multi_criteria_progressive'
                    }
                },
                '1041401': {
                    codigo: '1041401',
                    banco: 'BCO. SANTANDER M/N',
                    alias: 'SANT',
                    moneda: 'PEN',
                    archivoPattern: /^sant\.pen\.\d{6}/,
                    pesta√±aExcel: 'SANT',
                    activo: true, // ACTIVADO - Ahora funcional
                    estructuraEspecial: {
                        headerFila: 8, // Headers en fila 8 (√≠ndice 7)
                        dataInicio: 9   // Datos empiezan en fila 9 (√≠ndice 8)
                    },
                    pasos: {
                        paso3: 'anulaciones_santander',
                        paso4: 'santander_operations',
                        paso5: 'prot_dev_grouping',
                        paso6: 'depositos_santander',
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_santander',
                        paso11: 'itf_operations',
                        paso12: 'multi_criteria_progressive'
                    }
                },
                '1041202': {
                    codigo: '1041202',
                    banco: 'CONTINENTAL M/E',
                    alias: 'BBVA.USD',
                    moneda: 'USD',
                    archivoPattern: /^bbva\.usd\.\d{6}/,
                    pesta√±aExcel: 'BBVA.USD',
                    activo: true, // NUEVO - Cuenta BBVA USD
                    estructuraEspecial: {
                        headerFila: 11, // Headers en fila 11 (√≠ndice 10) - igual que BBVA.PEN
                        dataInicio: 13   // Datos empiezan en fila 13 (√≠ndice 12), saltando fila 12
                    },
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'bbva_operations', // Misma l√≥gica que BBVA.PEN
                        paso5: 'prot_dev_grouping',
                        paso6: 'depositos_bancarios',
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_operations',
                        paso11: 'itf_operations',
                        paso12: 'multi_criteria_progressive'
                    }
                },
                '1041201': {
                    codigo: '1041201',
                    banco: 'CONTINENTAL M/N',
                    alias: 'BBVA',
                    moneda: 'PEN',
                    archivoPattern: /^bbva\.pen\.\d{6}/,
                    pesta√±aExcel: 'BBVA',
                    activo: true, // ACTIVADO - Nueva cuenta BBVA
                    estructuraEspecial: {
                        headerFila: 11, // Headers en fila 11 (√≠ndice 10)
                        dataInicio: 13   // Datos empiezan en fila 13 (√≠ndice 12), saltando fila 12
                    },
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'standard_operations',
                        paso5: 'prot_dev_grouping',
                        paso6: 'depositos_standard',
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_operations',
                        paso11: 'itf_operations',
                        paso12: 'multi_criteria_progressive'
                    }
                },
                '1041302': {
                    codigo: '1041302',
                    banco: 'SCOTIABANK M/E',
                    alias: 'SBP.USD',
                    moneda: 'USD',
                    archivoPattern: /^sbp\.usd\.\d{6}/,
                    pesta√±aExcel: 'SBP.USD',
                    activo: true, // NUEVO - Cuenta SBP USD
                    estructuraEspecial: {
                        headerFila: 8, // Headers en fila 8 (√≠ndice 7) - igual que SBP.PEN
                        dataInicio: 9   // Datos empiezan en fila 9 (√≠ndice 8)
                    },
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'standard_operations', // MISMA L√ìGICA QUE SBP.PEN
                        paso5: 'prot_dev_grouping',
                        paso6: 'depositos_standard', // MISMA L√ìGICA QUE SBP.PEN
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_operations',
                        paso11: 'itf_operations',
                        paso12: 'multi_criteria_progressive'
                    }
                },
                '1041301': {
                    codigo: '1041301',
                    banco: 'SCOTIABANK M/N',
                    alias: 'SBP',
                    moneda: 'PEN',
                    archivoPattern: /^sbp\.pen\.\d{6}/,
                    pesta√±aExcel: 'SBP',
                    activo: true, // ACTIVADO - Nueva cuenta Scotiabank
                    estructuraEspecial: {
                        headerFila: 8, // Headers en fila 8 (√≠ndice 7)
                        dataInicio: 9   // Datos empiezan en fila 9 (√≠ndice 8)
                    },
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'standard_operations',
                        paso5: 'prot_dev_grouping',
                        paso6: 'depositos_standard',
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_operations',
                        paso11: 'itf_operations',
                        paso12: 'multi_criteria_progressive'
                    }
                },
                '1041101': {
                    codigo: '1041101',
                    banco: 'INTERBANK M/N',
                    alias: 'IBK',
                    moneda: 'PEN',
                    archivoPattern: /^ibk\.pen\.\d{6}/,
                    pesta√±aExcel: 'IBK',
                    activo: true, // ACTIVADO - Nueva cuenta Interbank
                    estructuraEspecial: {
                        headerFila: 12, // Headers en fila 12 (√≠ndice 11) - desde B12 hasta J12
                        dataInicio: 13,   // Datos empiezan en fila 13 (√≠ndice 12) - siguiente fila despu√©s de headers
                        columnaInicio: 1, // Columna B (√≠ndice 1)
                        columnaFin: 9,   // Columna J (√≠ndice 9)
                        origenHeaders: {
                            fila: 12,     // Los headers originales est√°n en fila 12
                            inicio: 1,    // Desde columna B (√≠ndice 1)
                            fin: 9        // Hasta columna J (√≠ndice 9)
                        },
                        headersEspecificos: {
                            fechaOperacion: 0,    // A - Fecha de operaci√≥n (de B12)
                            fechaProceso: 1,      // B - Fecha de proceso (de C12)
                            nroOperacion: 2,      // C - Nro. de operaci√≥n (de D12)
                            movimiento: 3,        // D - Movimiento (de E12)
                            descripcion: 4,       // E - Descripci√≥n (de F12)
                            canal: 5,             // F - Canal (de G12)
                            cargo: 6,             // G - Cargo (de H12)
                            abono: 7,             // H - Abono (de I12)
                            saldoContable: 8,     // I - Saldo contable (de J12)
                            estado: 9,            // J - Pendiente (nueva columna ESTADO)
                            ref: 10               // K - #REF (nueva columna)
                        }
                    },
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'ibk_operations',
                        paso5: 'ibk_financ_docs_78', // L√≥gica espec√≠fica IBK para FINANC.DOCS -78
                        paso6: 'ibk_depositos_abono', // L√≥gica espec√≠fica IBK usando columna Abono
                        paso7: 'ibk_libro03_abono',   // L√≥gica espec√≠fica IBK usando columna Abono
                        paso8: 'ibk_multi_libro_cargo', // L√≥gica espec√≠fica IBK usando Fecha operaci√≥n + |Cargo|
                        paso9: 'ibk_multi_libro_grouped_cargo', // L√≥gica espec√≠fica IBK agrupada usando |Cargo|
                        paso10: 'cheques_operations',
                        paso11: 'ibk_itf_abono', // L√≥gica espec√≠fica IBK para ITF usando ABONO
                        paso12: 'ibk_reprocess_paso4' // Reprocesar fase 1 del paso 4 para pendientes
                    }
                },
                '1041102': {
                    codigo: '1041102',
                    banco: 'INTERBANK M/E',
                    alias: 'IBK.USD',
                    moneda: 'USD',
                    archivoPattern: /^ibk\.usd\.\d{6}/,
                    pesta√±aExcel: 'IBK.USD',
                    activo: true, // NUEVO - Cuenta IBK USD
                    estructuraEspecial: {
                        headerFila: 12, // Headers en fila 12 (√≠ndice 11) - igual que IBK.PEN
                        dataInicio: 13,   // Datos empiezan en fila 13 (√≠ndice 12)
                        columnaInicio: 1, // Columna B (√≠ndice 1)
                        columnaFin: 9,   // Columna J (√≠ndice 9)
                        origenHeaders: {
                            fila: 12,     // Los headers originales est√°n en fila 12
                            inicio: 1,    // Desde columna B (√≠ndice 1)
                            fin: 9        // Hasta columna J (√≠ndice 9)
                        },
                        headersEspecificos: {
                            fechaOperacion: 0,    // A - Fecha de operaci√≥n (de B12)
                            fechaProceso: 1,      // B - Fecha de proceso (de C12)
                            nroOperacion: 2,      // C - Nro. de operaci√≥n (de D12)
                            movimiento: 3,        // D - Movimiento (de E12)
                            descripcion: 4,       // E - Descripci√≥n (de F12)
                            canal: 5,             // F - Canal (de G12)
                            cargo: 6,             // G - Cargo (de H12)
                            abono: 7,             // H - Abono (de I12)
                            saldoContable: 8,     // I - Saldo contable (de J12)
                        }
                    },
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'ibk_operations', // Misma l√≥gica que IBK.PEN
                        paso5: 'ibk_financ_docs_78', // L√≥gica espec√≠fica IBK para FINANC.DOCS -78
                        paso6: 'ibk_depositos_abono', // L√≥gica espec√≠fica IBK usando columna Abono
                        paso7: 'ibk_libro03_abono',   // L√≥gica espec√≠fica IBK usando columna Abono
                        paso8: 'ibk_multi_libro_cargo', // L√≥gica espec√≠fica IBK usando Fecha operaci√≥n + |Cargo|
                        paso9: 'ibk_multi_libro_grouped_cargo', // L√≥gica espec√≠fica IBK agrupada usando |Cargo|
                        paso10: 'cheques_operations',
                        paso11: 'ibk_itf_abono', // L√≥gica espec√≠fica IBK para ITF usando ABONO
                        paso12: 'ibk_reprocess_paso4' // Reprocesar fase 1 del paso 4 para pendientes
                    }
                },
                '1042101': {
                    codigo: '1042101',
                    banco: 'BANCOS Y FINANCIERAS',
                    alias: 'DET',
                    moneda: 'PEN',
                    archivoPattern: /^det\.pen\.\d{6}/,
                    pesta√±aExcel: 'DET',
                    activo: true, // ACTIVADO - Nuevo banco DET
                    estructuraEspecial: {
                        headerFila: 1, // Headers en fila 1 (√≠ndice 0)
                        dataInicio: 2,   // Datos empiezan en fila 2 (√≠ndice 1)
                        headersEspecificos: {
                            nro: 0,        // A - Nro
                            fecha: 1,      // B - Fecha
                            trans: 2,      // C - Trans
                            documento: 3,  // D - Documento
                            oficina: 4,    // E - Oficina
                            cargo: 5,      // F - Cargo
                            abono: 6,      // G - Abono
                            estado: 8,     // I - ESTADO (nueva columna)
                            ref: 9         // J - #REF (nueva columna)
                        }
                    },
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'det_operations',           // Operaciones espec√≠ficas DET usando Cargo/Abono
                        paso5: 'prot_dev_grouping',
                        paso6: 'det_depositos_abono',      // Dep√≥sitos DET usando columna Abono
                        paso7: 'det_libro03_abono',        // Libro 03 DET usando columna Abono
                        paso8: 'det_multi_libro_cargo',    // Multi-libro DET usando columna Cargo
                        paso9: 'det_multi_libro_grouped_cargo', // Multi-libro agrupado DET usando Cargo
                        paso10: 'cheques_operations',
                        paso11: 'det_itf_abono',          // ITF DET usando columna Abono
                        paso12: 'multi_criteria_progressive'
                    }
                },
                '1041601': {
                    codigo: '1041601',
                    banco: 'BCO. DE LA NACION',
                    alias: 'BN',
                    moneda: 'PEN',
                    archivoPattern: /^bn\.pen\.\d{6}/,
                    pesta√±aExcel: 'BN',
                    activo: true, // ACTIVADO - Nuevo banco BN
                    estructuraEspecial: {
                        headerFila: 1, // Headers en fila 1 (√≠ndice 0)
                        dataInicio: 2,   // Datos empiezan en fila 2 (√≠ndice 1)
                        headersEspecificos: {
                            // Pendiente: definir estructura espec√≠fica de BN cuando se proporcionen las columnas
                            estado: -2,  // Pen√∫ltima columna (ESTADO)
                            ref: -1      // √öltima columna (#REF)
                        }
                    },
                    pasos: {
                        paso3: 'anulaciones_standard',
                        paso4: 'standard_operations',
                        paso5: 'prot_dev_grouping',
                        paso6: 'bn_depositos_abono',      // Dep√≥sitos BN usando columna Abono
                        paso7: 'libro03_operations',
                        paso8: 'multi_libro_operations',
                        paso9: 'multi_libro_grouped',
                        paso10: 'cheques_operations',
                        paso11: 'itf_operations',
                        paso12: 'multi_criteria_progressive'
                    }
                }
                // M√°s cuentas se agregar√°n aqu√≠ en el futuro
            },

            init() {
                // // console.log("üèÅ Inicializando Conciliador Bancario");
                this.loadStoredFiles();
            },

            // === M√âTODOS PARA MANEJO MULTI-CUENTA ===
            
            // Obtener configuraci√≥n de cuenta activa (primera cuenta activa encontrada)
            getCuentaActiva() {
                return Object.values(this.cuentasConfig).find(cuenta => cuenta.activo);
            },
            
            // Obtener todas las cuentas activas (futuro: m√∫ltiples)
            getCuentasActivas() {
                return Object.values(this.cuentasConfig).filter(cuenta => cuenta.activo);
            },
            
            // Detectar cuenta por nombre de archivo
            detectarCuentaPorArchivo(fileName) {
                const name = fileName.toLowerCase();
                
                // Diagn√≥stico espec√≠fico para SBP.USD
                if (name.includes('sbp.usd')) {
                    console.log(`üîç DIAGN√ìSTICO SBP.USD DETECCI√ìN:`);
                    console.log(`   Archivo original: "${fileName}"`);
                    console.log(`   Archivo normalizado: "${name}"`);
                    console.log(`   Patr√≥n SBP.USD: ${this.cuentasConfig['1041302'].archivoPattern}`);
                    console.log(`   ¬øPatr√≥n coincide?: ${this.cuentasConfig['1041302'].archivoPattern.test(name)}`);
                    
                    // Probar variaciones del nombre
                    const sinExtension = name.replace(/\.(xls|xlsx)$/, '');
                    console.log(`   Sin extensi√≥n: "${sinExtension}"`);
                    console.log(`   ¬øSin extensi√≥n coincide?: ${this.cuentasConfig['1041302'].archivoPattern.test(sinExtension)}`);
                }
                
                for (const [codigo, config] of Object.entries(this.cuentasConfig)) {
                    if (config.archivoPattern.test(name)) {
                        if (name.includes('sbp.usd')) {
                            console.log(`   ‚úÖ PATR√ìN COINCIDE: ${codigo} (${config.alias})`);
                            console.log(`   üîß Patr√≥n usado: ${config.archivoPattern}`);
                        }
                        return { codigo, config };
                    } else if (name.includes('sbp.usd')) {
                        console.log(`   ‚ùå NO coincide con ${codigo} (${config.alias}): ${config.archivoPattern}`);
                    }
                }
                
                if (name.includes('sbp.usd')) {
                    console.log(`   üö® SBP.USD NO DETECTADO POR NING√öN PATR√ìN`);
                }
                
                return null;
            },
            
            // Obtener estrategia de procesamiento por cuenta y paso
            getEstrategiaProcesamiento(codigoCuenta, numeroPaso) {
                const cuenta = this.cuentasConfig[codigoCuenta];
                if (!cuenta) return 'default';
                return cuenta.pasos[`paso${numeroPaso}`] || 'default';
            },
            
            // Verificar si una cuenta debe ser procesada
            debeProcestarCuenta(codigoCuenta) {
                const cuenta = this.cuentasConfig[codigoCuenta];
                return cuenta && cuenta.activo;
            },
            
            // Obtener TODAS las cuentas para filtrado (PEN + USD completo)
            getCuentasCompletasParaFiltrado() {
                // Lista MAESTRA de TODAS las cuentas (PEN + USD) que deben procesarse
                const todasLasCuentas = [
                    // Cuentas PEN
                    '1041501', // BCP.01
                    '1041505', // BCP.02
                    '1041401', // SANT
                    '1041201', // BBVA
                    '1041301', // SBP
                    '1041101', // IBK
                    '1042101', // DET
                    '1041601', // BN
                    // Cuentas USD
                    '1041502', // BCP.USD
                    '1041402', // SANT.USD
                    '1041202', // BBVA.USD
                    '1041302', // SBP.USD
                    '1041102'  // IBK.USD
                ];
                
                // Filtrar solo las que est√°n activas en configuraci√≥n
                const cuentasActivasCompletas = todasLasCuentas.filter(codigo => {
                    const cuenta = this.cuentasConfig[codigo];
                    return cuenta && cuenta.activo;
                });
                
                console.log(`üìã getCuentasCompletasParaFiltrado: ${cuentasActivasCompletas.length} cuentas activas (PEN + USD)`);
                return cuentasActivasCompletas;
            },
            
            // Obtener configuraci√≥n de filtro de cuenta (WRAPPER para compatibilidad)
            getCuentasFiltro() {
                // IMPORTANTE: Usar la funci√≥n maestra que garantiza PEN + USD completo
                return this.getCuentasCompletasParaFiltrado();
            },

            // Cargar archivos guardados en localStorage
            loadStoredFiles() {
                try {
                    const storedFiles = localStorage.getItem('bancarioConciliador_files');
                    if (storedFiles) {
                        const filesData = JSON.parse(storedFiles);
                        this.files = filesData.map(fileData => ({
                            ...fileData,
                            file: this.base64ToFile(fileData.base64Data, fileData.name, fileData.type)
                        }));
                        // // // console.log(`üìÅ Cargados ${this.files.length} archivos desde localStorage`);
                        if (this.files.length > 0) {
                            this.showStatus(`${this.files.length} archivo(s) cargado(s) desde la sesi√≥n anterior`, 'success');
                        }
                    }
                } catch (error) {
                    // console.error('Error cargando archivos guardados:', error);
                }
            },

            // Guardar archivos en localStorage
            saveFilesToStorage() {
                try {
                    const filesToStore = this.files.map(file => ({
                        id: file.id,
                        name: file.name,
                        size: file.size,
                        category: file.category,
                        type: file.file.type,
                        base64Data: null // Se llenar√° despu√©s
                    }));

                    // Convertir archivos a base64 y guardar
                    Promise.all(filesToStore.map((fileInfo, index) => 
                        this.fileToBase64(this.files[index].file).then(base64 => {
                            fileInfo.base64Data = base64;
                            return fileInfo;
                        })
                    )).then(filesWithBase64 => {
                        localStorage.setItem('bancarioConciliador_files', JSON.stringify(filesWithBase64));
                        // // console.log('üìÅ Archivos guardados en localStorage');
                    }).catch(error => {
                        // console.error('Error guardando archivos:', error);
                    });
                } catch (error) {
                    // console.error('Error en saveFilesToStorage:', error);
                }
            },

            // Convertir archivo a base64
            fileToBase64(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.readAsDataURL(file);
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = error => reject(error);
                });
            },

            // Convertir base64 a archivo
            base64ToFile(base64String, fileName, fileType) {
                const byteCharacters = atob(base64String.split(',')[1]);
                const byteNumbers = new Array(byteCharacters.length);
                for (let i = 0; i < byteCharacters.length; i++) {
                    byteNumbers[i] = byteCharacters.charCodeAt(i);
                }
                const byteArray = new Uint8Array(byteNumbers);
                return new File([byteArray], fileName, { type: fileType });
            },

            // Limpiar archivos guardados
            clearStoredFiles() {
                localStorage.removeItem('bancarioConciliador_files');
                this.files = [];
                this.conciliationResult = null;
                this.showStatus('Archivos guardados eliminados', 'success');
                // // console.log('üóëÔ∏è Cache de archivos limpiado');
            },

            handleDrop(event) {
                this.isDragOver = false;
                const files = Array.from(event.dataTransfer.files);
                this.processFiles(files);
            },

            handleFileSelect(event) {
                const files = Array.from(event.target.files);
                this.processFiles(files);
            },

            processFiles(files) {
                const validFiles = files.filter(file => {
                    const extension = file.name.split('.').pop().toLowerCase();
                    const allowedExtensions = ['xlsx', 'xls', 'csv'];
                    return allowedExtensions.includes(extension);
                });

                if (validFiles.length > 0) {
                    this.addFiles(validFiles);
        } else {
                    this.showStatus('Por favor selecciona archivos v√°lidos (XLSX, XLS, CSV)', 'error');
                }
            },

            addFiles(files) {
                files.forEach(file => {
                    if (file.name.toLowerCase().includes('sbp.usd')) {
                        console.log(`üìÇ AGREGANDO ARCHIVO SBP.USD: "${file.name}"`);
                    }
                    const fileObj = {
                        id: Date.now() + Math.random(),
                        name: file.name,
                        size: file.size,
                        file: file,
                        category: this.categorizeFile(file.name)
                    };
                    if (file.name.toLowerCase().includes('sbp.usd')) {
                        console.log(`   üìä SBP.USD categor√≠a asignada: "${fileObj.category}"`);
                    }
                    this.files.push(fileObj);
                });
                this.showStatus(`${files.length} archivo(s) agregado(s) correctamente`, 'success');
                
                // Guardar autom√°ticamente en localStorage
                this.saveFilesToStorage();
            },

            categorizeFile(fileName) {
                const name = fileName.toLowerCase();
                
                // Debug espec√≠fico para SBP.USD
                if (name.includes('sbp.usd')) {
                    console.log(`üîç CATEGORIZANDO SBP.USD: "${fileName}" ‚Üí "${name}"`);
                }
                
                // === CATEGORIZACI√ìN BASADA EN CONFIGURACI√ìN DE CUENTAS ===
                
                // 1. Verificar si es archivo de extracto por cuenta espec√≠fica
                const cuentaDetectada = this.detectarCuentaPorArchivo(fileName);
                if (name.includes('sbp.usd')) {
                    console.log(`   üìã SBP.USD cuenta detectada:`, cuentaDetectada);
                }
                if (cuentaDetectada) {
                    if (name.includes('sbp.usd')) {
                        console.log(`   ‚úÖ SBP.USD categorizado como 'extracto'`);
                    }
                    // Archivo de extracto de cuenta espec√≠fica (BCP.01, BCP.02, SANT, BBVA, etc.)
                    return 'extracto';
                } else if (name.includes('sbp.usd')) {
                    console.log(`   ‚ùå SBP.USD NO detectado como cuenta - revisando otros patrones`);
                }
                
                // 2. Patrones para Mayor: MAYOR.PEN.MMAAAA o MAYOR.USD.MMAAAA
                if (name.match(/^mayor\.(pen|usd)\.\d{6}/)) {
                    return 'mayor';
                }
                
                // 3. Patrones para Saldo: SALDO.PEN.MMAAAA o SALDO.USD.MMAAAA
                if (name.match(/^saldo\.(pen|usd)\.\d{6}/)) {
                    return 'resumen';
                }
                
                // 4. Patrones legacy para compatibilidad (se eliminar√°n gradualmente)
                if (name.includes('mayor') || name.includes('analitico')) {
                    return 'mayor';
                } else if (name.includes('extracto') || name.includes('banco')) {
                    return 'extracto';
                } else if (name.includes('resumen') || name.includes('saldo')) {
                    return 'resumen';
        } else {
                    return 'otro';
                }
            },

            deleteFile(fileId) {
                if (confirm('¬øEst√°s seguro de que quieres eliminar este archivo?')) {
                    this.files = this.files.filter(file => file.id !== fileId);
                    this.showStatus('Archivo eliminado correctamente', 'success');
                    
                    // Actualizar localStorage
                    this.saveFilesToStorage();
                }
            },

            canProcessConciliation() {
                const hasMayor = this.files.some(f => f.category === 'mayor');
                const hasExtracto = this.files.some(f => f.category === 'extracto');
                return hasMayor && hasExtracto;
            },

            getMissingFilesMessage() {
                const hasMayor = this.files.some(f => f.category === 'mayor');
                const hasExtracto = this.files.some(f => f.category === 'extracto');
                
                if (!hasMayor && !hasExtracto) {
                    return 'Faltan archivos MAYOR.PEN/USD.MMAAAA y extractos bancarios (BCP.01/02/USD, SANT.PEN/USD, BBVA.PEN/USD, SBP.PEN/USD, IBK)';
                } else if (!hasMayor) {
                    return 'Falta archivo MAYOR.PEN/USD.MMAAAA';
                } else if (!hasExtracto) {
                    return 'Faltan archivos de extractos bancarios (BCP.01/02/USD, SANT.PEN/USD, BBVA.PEN/USD, SBP.PEN/USD, IBK)';
                }
                return 'Archivos incompletos';
            },

            async realizarConciliacion() {
                if (!this.canProcessConciliation()) {
                    this.showStatus('Se necesitan al menos los archivos MAYOR.PEN/USD.MMAAAA y extractos bancarios (BCP.01/02, SANT, BBVA, IBK)', 'error');
                    return;
                }

                this.isLoading = true;

                try {
                    // === SEPARAR ARCHIVOS MAYOR POR MONEDA ===
                    const mayorFiles = this.files.filter(f => f.category === 'mayor');
                    const mayorFilePEN = mayorFiles.find(f => f.name.toLowerCase().includes('mayor.pen'))?.file;
                    const mayorFileUSD = mayorFiles.find(f => f.name.toLowerCase().includes('mayor.usd'))?.file;
                    
                    // Por compatibilidad, si no hay archivos espec√≠ficos, usar el gen√©rico
                    const mayorFileGenerico = mayorFiles[0]?.file;
                    const mayorFile = mayorFilePEN || mayorFileGenerico;
                    
                    // === SEPARAR EXTRACTOS POR CUENTA ===
                    const extractoFiles = this.files.filter(f => f.category === 'extracto');
                    const extractosPorCuenta = new Map();
                    
                    // Procesar cada archivo de extracto por cuenta espec√≠fica
                    // console.log(`üîç DIAGN√ìSTICO ARCHIVOS EXTRACTO: ${extractoFiles.length} archivos encontrados`);
                    for (const extractoFileObj of extractoFiles) {
                        // Solo mostrar logs para SBP.USD
                        if (extractoFileObj.name.toLowerCase().includes('sbp.usd')) {
                            console.log(`   üìÅ SBP.USD Procesando: ${extractoFileObj.name}`);
                        }
                        const cuentaInfo = this.detectarCuentaPorArchivo(extractoFileObj.name);
                        if (cuentaInfo) {
                            if (cuentaInfo.codigo === '1041302') {
                                console.log(`   ‚úÖ SBP.USD Detectado: ${cuentaInfo.codigo} (${cuentaInfo.config.alias}) - Activo: ${cuentaInfo.config.activo}`);
                            }
                            if (cuentaInfo.config.activo) {
                                // Leer archivo con configuraci√≥n espec√≠fica (estructura especial si aplica)
                                const datosExtracto = await this.readExcelFile(extractoFileObj.file, cuentaInfo.config);
                                extractosPorCuenta.set(cuentaInfo.codigo, {
                                    config: cuentaInfo.config,
                                    datos: datosExtracto,
                                    archivo: extractoFileObj.name
                                });
                                if (cuentaInfo.codigo === '1041302') {
                                    console.log(`   üìä SBP.USD cargado: ${datosExtracto.length} filas`);
                                }
                                
                                // Diagn√≥stico especial para SBP.USD
                                if (cuentaInfo.codigo === '1041302') {
                                    console.log(`   üîç SBP.USD DATOS CARGADOS:`);
                                    console.log(`      üìÅ Archivo: ${extractoFileObj.name}`);
                                    console.log(`      üìä Total filas: ${datosExtracto.length}`);
                                    console.log(`      üèóÔ∏è Estructura especial: ${!!cuentaInfo.config.estructuraEspecial}`);
                                    if (cuentaInfo.config.estructuraEspecial) {
                                        console.log(`      üìã Header fila: ${cuentaInfo.config.estructuraEspecial.headerFila}`);
                                        console.log(`      üìä Datos desde fila: ${cuentaInfo.config.estructuraEspecial.dataInicio}`);
                                    }
                                    // Mostrar primeras filas para verificar
                                    if (datosExtracto.length > 0) {
                                        console.log(`      üìã Primera fila:`, datosExtracto[0]);
                                        if (datosExtracto.length > 1) {
                                            console.log(`      üìã Segunda fila:`, datosExtracto[1]);
                                        }
                                    }
                                }
                            } else {
                                console.log(`   ‚ö†Ô∏è ${cuentaInfo.config.alias} inactivo, saltando`);
                            }
                        } else {
                            console.log(`   ‚ùå No detectado como cuenta conocida: ${extractoFileObj.name}`);
                        }
                    }
                    
                    console.log(`üìã RESUMEN EXTRACTOS CARGADOS: ${extractosPorCuenta.size} cuentas`);
                    extractosPorCuenta.forEach((info, codigo) => {
                        console.log(`   ${codigo} (${info.config.alias}): ${info.datos.length} filas desde ${info.archivo}`);
                    });
                    
                    if (extractosPorCuenta.size === 0 || !mayorFile) {
                        throw new Error('No se encontraron los archivos necesarios');
                    }
                    
                    const saldoFile = this.files.find(f => f.category === 'resumen')?.file; // Archivo de saldo opcional

                    // // console.log("üöÄ INICIANDO PROCESAMIENTO DE CONCILIACI√ìN");
                    const mayorDataPEN = await this.readExcelFile(mayorFile);
                    
                    // Cargar MAYOR.USD si existe
                                    let mayorDataUSD = null;
                if (mayorFileUSD) {
                    mayorDataUSD = await this.readExcelFile(mayorFileUSD);
                    console.log(`üìã MAYOR.USD cargado: ${mayorDataUSD.length} filas`);
                    
                    // Verificar datos de SBP.USD espec√≠ficamente
                    console.log(`üîç DIAGN√ìSTICO COMPLETO MAYOR.USD - Estructura y Cuentas:`);
                    
                    // 1. Mostrar estructura del archivo
                    if (mayorDataUSD.length > 2) {
                        console.log(`üìã Headers MAYOR.USD (fila 2):`, mayorDataUSD[1]);
                        console.log(`üìä Primera fila datos:`, mayorDataUSD[2]);
                        console.log(`üìä Total filas: ${mayorDataUSD.length}`);
                    }
                    
                    // 2. Buscar columna CUENTA din√°micamente
                    const headerMayorUSD = mayorDataUSD.length > 1 ? mayorDataUSD[1] : [];
                    const indicesMayorUSD = this.buscarIndicesColumnas(headerMayorUSD, {
                        cuenta: ['CUENTA']
                    });
                    console.log(`üîç √çndice columna CUENTA: ${indicesMayorUSD.cuenta}`);
                    
                    // 3. Buscar SBP.USD usando la columna correcta
                    let filasSBPUSD = [];
                    if (indicesMayorUSD.cuenta !== -1) {
                        console.log(`üîç Buscando cuenta 1041302 en columna ${indicesMayorUSD.cuenta}`);
                        filasSBPUSD = mayorDataUSD.filter(fila => {
                            const cuenta = fila[indicesMayorUSD.cuenta] || '';
                            const cuentaStr = cuenta.toString().trim();
                            const contiene1041302 = cuentaStr.includes('1041302');
                            if (contiene1041302) {
                                console.log(`   ‚úÖ Encontrada cuenta: "${cuentaStr}" en fila:`, fila);
                            }
                            return contiene1041302;
                        });
                    } else {
                        // Fallback: buscar en todas las columnas
                        console.log(`üîç FALLBACK: Buscando 1041302 en TODAS las columnas`);
                        const filasData = mayorDataUSD.slice(2);
                        filasData.forEach((fila, idx) => {
                            fila.forEach((valor, colIdx) => {
                                const valorStr = (valor || '').toString().trim();
                                if (valorStr.includes('1041302')) {
                                    console.log(`   ‚úÖ Encontrada en fila ${idx + 3}, columna ${colIdx}: "${valorStr}"`);
                                    filasSBPUSD.push(fila);
                                }
                            });
                        });
                    }
                    
                    console.log(`üîç SBP.USD en MAYOR.USD: ${filasSBPUSD.length} filas`);
                    
                    // Si no encontramos, revisar todas las cuentas para diagnosticar
                    if (filasSBPUSD.length === 0 && mayorDataUSD.length > 0) {
                        console.log(`üîç Revisando primeras 5 filas para diagn√≥stico:`);
                        mayorDataUSD.slice(0, 5).forEach((fila, idx) => {
                            const cuenta = fila[7] || ''; // Columna H = √≠ndice 7
                            console.log(`   Fila ${idx}: cuenta="${cuenta}" (columna H)`);
                        });
                        
                        // Buscar cualquier cuenta que empiece con 1041
                        const cuentas1041 = mayorDataUSD.filter(fila => {
                            const cuenta = fila[7] || ''; // Columna H = √≠ndice 7
                            return cuenta.toString().startsWith('1041');
                        });
                        const cuentasUnicas = [...new Set(cuentas1041.map(fila => fila[7]))];
                        console.log(`üîç Cuentas 1041* encontradas:`, cuentasUnicas);
                    }
                    
                    if (filasSBPUSD.length > 0) {
                        console.log(`üìä Primera fila SBP.USD:`, filasSBPUSD[0]);
                    }
                }
                    
                    // Cargar archivo de saldo si est√° disponible
                    let saldoData = null;
                    if (saldoFile) {
                        // // console.log("üìö Cargando archivo de saldo...");
                        saldoData = await this.readExcelFile(saldoFile);
                    }
            
            if (!mayorDataPEN || extractosPorCuenta.size === 0) {
                throw new Error('Error al leer los archivos Excel');
            }
            
            // // console.log("üìö Archivos cargados correctamente");
            
            // MUESTRA DE DATOS CARGADOS PARA DEBUG
            // // console.log("üìã MUESTRA DATOS MAYOR:");
            // // console.log("   Primeras 3 filas completas:");
            mayorDataPEN.slice(0, 3).forEach((fila, idx) => {
                // // // console.log(`   Fila ${idx + 1}: [${fila.slice(0, 15).map(col => `"${col}"`).join(', ')}]`);
            });
            
            // // console.log("üìã MUESTRA DATOS EXTRACTOS POR CUENTA:");
            extractosPorCuenta.forEach((extractoInfo, codigoCuenta) => {
                // // // console.log(`   üìÇ ${extractoInfo.config.alias} (${codigoCuenta}): ${extractoInfo.datos.length} filas`);
                extractoInfo.datos.slice(0, 6).forEach((fila, idx) => {
                    // // // console.log(`      Fila ${idx + 1}: [${fila.slice(0, 8).map(col => `"${col}"`).join(', ')}]`);
                });
            });
            
            if (saldoData) {
                // // console.log("üìã MUESTRA DATOS SALDO:");
                // // console.log("   Primeras 3 filas completas:");
                saldoData.slice(0, 3).forEach((fila, idx) => {
                    // // // console.log(`   Fila ${idx + 1}: [${fila.slice(0, 15).map(col => `"${col}"`).join(', ')}]`);
                });
                
                // TEST ESPEC√çFICO PARA EL EJEMPLO DEL USUARIO
                // // console.log("\nüß™ TEST DE PARSEO PARA EJEMPLO:");
                // // console.log("   Testeando normalizaci√≥n de NUMDOC '00043335':");
                // // // console.log(`   Resultado: "${this.normalizarTexto('00043335')}"`);
                // // console.log("   Testeando normalizaci√≥n de monto '5.974,98':");
                // // // console.log(`   Resultado: ${this.normalizarMonto('5.974,98')}`);
                // // console.log("   Testeando normalizaci√≥n de monto '5974,98':");
                // // // console.log(`   Resultado: ${this.normalizarMonto('5974,98')}`);
                
                // TEST DE NORMALIZACI√ìN DE FECHAS PARA PASO 4
                // // console.log("\nüß™ TEST DE PARSEO DE FECHAS:");
                // // console.log("   Testeando '02/06/2025':");
                // // // console.log(`   Resultado: "${this.normalizarFecha('02/06/2025')}"`);
                // // console.log("   Testeando '2025-06-02':");
                // // // console.log(`   Resultado: "${this.normalizarFecha('2025-06-02')}"`); 
                // // console.log("   Testeando '2/6/2025':");
                // // // console.log(`   Resultado: "${this.normalizarFecha('2/6/2025')}"`); 
                // // console.log("   Testeando n√∫mero serial Excel '45809':");
                // // // console.log(`   Resultado: "${this.normalizarFecha('45809')}"`); 
                // // console.log("   Testeando n√∫mero serial Excel '45810':");
                // // // console.log(`   Resultado: "${this.normalizarFecha('45810')}"`); 
                
                // TEST DE MONTOS PARA TU EJEMPLO ESPEC√çFICO
                // // console.log("\nüß™ TEST DE PARSEO DE MONTOS:");
                // // console.log("   Testeando '396118,93' (Mayor - formato correcto):");
                // // // console.log(`   Resultado: ${this.normalizarMonto('396118,93')}`);
                // // console.log("   Testeando '396.118,93' (Extracto - formato correcto):");
                // // // console.log(`   Resultado: ${this.normalizarMonto('396.118,93')}`);
                // // console.log("   Diferencia entre ambos:");
                const monto1 = this.normalizarMonto('396118,93');
                const monto2 = this.normalizarMonto('396.118,93');
                const diferencia = Math.abs(monto1 - monto2);
                // // // console.log(`   |${monto1} - ${monto2}| = ${diferencia.toFixed(6)} (debe ser exacto)`);
                // // // console.log(`   ¬øCoincidencia exacta?: ${diferencia === 0 ? '‚úÖ S√ç' : '‚ùå NO'}`);
                
                // Test adicional del mapeo exacto
                // // console.log("\nüéØ VERIFICACI√ìN DE MAPEO:");
                // // // console.log(`   FDOC 45810 ‚Üí "${this.normalizarFecha('45810')}"`); 
                // // // console.log(`   Fecha extracto "02/06/2025" ‚Üí "${this.normalizarFecha('02/06/2025')}"`); 
                // // // console.log(`   ¬øFechas coinciden?: ${this.normalizarFecha('45810') === this.normalizarFecha('02/06/2025') ? '‚úÖ S√ç' : '‚ùå NO'}`);
            } else {
                // // console.log("‚ö†Ô∏è No hay archivo de saldo cargado");
            }
            
                    const resultado = this.procesarConciliacionMultiCuenta(extractosPorCuenta, mayorDataPEN, saldoData, mayorDataUSD);
            
            if (!resultado || !resultado.datosMayor || resultado.datosMayor.length === 0) {
                throw new Error('No se generaron datos de conciliaci√≥n');
            }
            
            // Verificar que tenemos extractos por cuenta
            if (!resultado.extractosPorCuenta || resultado.extractosPorCuenta.size === 0) {
                console.warn('‚ö†Ô∏è No se generaron extractos por cuenta, usando estructura de compatibilidad');
            }
            
            const fileName = `conciliacion_${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.xlsx`;
                    
                    // Mostrar resultados
                    this.conciliationResult = {
                        totalProcesados: resultado.totalProcesados,
                        conciliados: Math.floor(resultado.totalProcesados * 0.8), // Ejemplo
                        noConciliados: Math.floor(resultado.totalProcesados * 0.2), // Ejemplo
                        detalles: {
                            fecha: new Date().toISOString(),
                            archivo_generado: fileName,
                            registros_procesados: resultado.totalProcesados
                        }
                    };
                    
                    // Generar y descargar archivo Excel autom√°ticamente
                    this.generateExcelFile(resultado, fileName);
                    
                    this.showStatus(`Conciliaci√≥n completada exitosamente. Descargando: ${fileName}`, 'success');
            
                 } catch (error) {
            console.error("‚ùå Error en procesamiento:", error.message);
                    this.showStatus(`Error en conciliaci√≥n: ${error.message}`, 'error');
                } finally {
                    this.isLoading = false;
                }
            },

            readExcelFile(file, cuentaConfig = null) {
         return new Promise((resolve, reject) => {
             const reader = new FileReader();
             reader.onload = function(e) {
                 try {
                     const data = new Uint8Array(e.target.result);
                     const workbook = XLSX.read(data, { type: 'array' });
                     const sheetName = workbook.SheetNames[0];
                     const worksheet = workbook.Sheets[sheetName];
                    let jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: "" });
                    
                                // DIAGN√ìSTICO: Verificar cuentaConfig recibido
            console.log(`üîß DEBUG readExcelFile - cuentaConfig recibido:`, cuentaConfig ? cuentaConfig.alias : 'NULL');
            if (cuentaConfig) {
                console.log(`   üìã Config completo:`, cuentaConfig);
                console.log(`   üèóÔ∏è Tiene estructuraEspecial:`, !!cuentaConfig.estructuraEspecial);
                if (cuentaConfig.estructuraEspecial) {
                    console.log(`   üìä Estructura:`, cuentaConfig.estructuraEspecial);
                }
            }
            
            // Aplicar estructura especial si est√° configurada
            if (cuentaConfig && cuentaConfig.estructuraEspecial) {
                        const estructura = cuentaConfig.estructuraEspecial;
                        console.log(`üèóÔ∏è Aplicando estructura especial para ${cuentaConfig.alias}:`);
                        console.log(`   üìã Original: ${jsonData.length} filas`);
                        console.log(`   üîß Header en fila: ${estructura.headerFila}`);
                        console.log(`   üìä Datos desde fila: ${estructura.dataInicio}`);
                        
                        // Extraer header y datos seg√∫n configuraci√≥n
                        const headerFila = jsonData[estructura.headerFila - 1] || []; // Convertir a √≠ndice base 0
                        const datosDesde = estructura.dataInicio - 1; // Convertir a √≠ndice base 0
                        
                        console.log(`   üîç Header extra√≠do original:`, headerFila);
                        console.log(`   üîç Primera fila de datos:`, jsonData[datosDesde]);
                        
                        // VALIDAR QUE EL HEADER SEA REALMENTE UN HEADER (no datos)
                        console.log(`   üß™ VALIDANDO HEADER para ${cuentaConfig.alias}:`);
                        headerFila.forEach((col, idx) => {
                            const esString = typeof col === 'string';
                            const colStr = col ? col.toString().toUpperCase() : '';
                            const contieneTerminos = colStr.includes('FECHA') || colStr.includes('IMPORTE') || 
                                                   colStr.includes('MONTO') || colStr.includes('DESCRIPCION') || 
                                                   colStr.includes('REFERENCIA') || colStr.includes('MOVIMIENTO');
                            console.log(`      Col[${idx}]: "${col}" (tipo: ${typeof col}, string: ${esString}, t√©rminos: ${contieneTerminos})`);
                        });
                        
                        const esHeaderValido = headerFila.some(col => 
                            col && typeof col === 'string' && 
                            (col.toUpperCase().includes('FECHA') || 
                             col.toUpperCase().includes('IMPORTE') || 
                             col.toUpperCase().includes('MONTO') ||
                             col.toUpperCase().includes('DESCRIPCION') ||
                             col.toUpperCase().includes('REFERENCIA') ||
                             col.toUpperCase().includes('MOVIMIENTO'))
                        );
                        
                        console.log(`   üìä Header v√°lido: ${esHeaderValido}`);
                        
                        if (!esHeaderValido) {
                            console.log(`   ‚ö†Ô∏è Header no v√°lido detectado, usando header por defecto para ${cuentaConfig.alias}`);
                            // Generar header por defecto seg√∫n el banco
                            let headerPorDefecto;
                            if (cuentaConfig.alias === 'SBP' || cuentaConfig.alias === 'SBP.USD') {
                                headerPorDefecto = ['Fecha', 'Movimiento', 'Importe', 'Referencia', 'CDR', 'M√≥dulo', 'Transac.', 'Relaci√≥n'];
                            } else if (cuentaConfig.alias === 'SANT' || cuentaConfig.alias === 'SANT.USD') {
                                headerPorDefecto = ['Fecha', 'Fecha valuta', 'Descripci√≥n operaci√≥n', 'Monto', 'Saldo', 'Sucursal', 'Operaci√≥n - N√∫mero', 'Operaci√≥n - Hora', 'Usuario', 'UTC', 'Referencia2'];
                            } else if (cuentaConfig.alias === 'BBVA' || cuentaConfig.alias === 'BBVA.USD') {
                                headerPorDefecto = ['F. Operaci√≥n', 'F. Valor', 'Concepto', 'N√∫mero', 'Descripci√≥n', 'Importe', 'Saldo'];
                                                    } else if (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD') {
                            headerPorDefecto = ['Fecha', 'Fecha Valor', 'N√∫mero', 'Concepto', 'Descripci√≥n', 'C√≥d. Aux', 'Monto', 'Vencimiento', 'Saldo'];
                            } else {
                                headerPorDefecto = ['Fecha', 'Descripci√≥n', 'Monto', 'Referencia', 'Saldo'];
                            }
                            
                            // Crear nueva estructura: [header por defecto, ...datos desde dataInicio]
                            const datosEstructurados = [headerPorDefecto];
                            for (let i = datosDesde; i < jsonData.length; i++) {
                                datosEstructurados.push(jsonData[i]);
                            }
                            
                            console.log(`   ‚úÖ Reestructurado con header por defecto: ${datosEstructurados.length} filas`);
                            console.log(`   üìã Header por defecto:`, headerPorDefecto);
                            jsonData = datosEstructurados;
                        } else {
                            // Header v√°lido, usar estructura normal
                            const datosEstructurados = [headerFila];
                            for (let i = datosDesde; i < jsonData.length; i++) {
                                datosEstructurados.push(jsonData[i]);
                            }
                            
                            console.log(`   ‚úÖ Reestructurado con header original: ${datosEstructurados.length} filas`);
                            console.log(`   üìã Header extra√≠do:`, headerFila);
                            jsonData = datosEstructurados;
                        }
                    }
                    
                     resolve(jsonData);
                 } catch (error) {
                     reject(error);
                 }
             };
             reader.onerror = () => reject(new Error('Error al leer el archivo'));
             reader.readAsArrayBuffer(file);
         });
            },

            getFileIcon(fileName) {
                const extension = fileName.split('.').pop().toLowerCase();
                const icons = {
                    'xlsx': 'fas fa-file-excel',
                    'xls': 'fas fa-file-excel',
                    'csv': 'fas fa-file-csv'
                };
                return icons[extension] || 'fas fa-file';
            },

            getFileType(fileName) {
                const extension = fileName.split('.').pop().toLowerCase();
                return extension.toUpperCase();
            },

            getCategoryColor(category) {
                const colors = {
                    'mayor': 'bg-blue-100 text-blue-800',
                    'extracto': 'bg-green-100 text-green-800',
                    'resumen': 'bg-purple-100 text-purple-800',
                    'otro': 'bg-gray-100 text-gray-800'
                };
                return colors[category] || colors['otro'];
            },

            getFileCategory(fileName) {
                const name = fileName.toLowerCase();
                
                // === CATEGORIZACI√ìN BASADA EN CONFIGURACI√ìN DE CUENTAS ===
                
                // 1. Verificar si es archivo de extracto por cuenta espec√≠fica
                const cuentaDetectada = this.detectarCuentaPorArchivo(fileName);
                if (cuentaDetectada) {
                    const { config } = cuentaDetectada;
                    return `Extracto ${config.banco} - ${config.alias} (${config.moneda})`;
                }
                
                // 2. Patrones para Mayor: MAYOR.PEN.MMAAAA o MAYOR.USD.MMAAAA
                if (name.match(/^mayor\.(pen|usd)\.\d{6}/)) {
                    const match = name.match(/^mayor\.(pen|usd)\.\d{6}/);
                    const moneda = match[1].toUpperCase();
                    return `Mayor Anal√≠tico (${moneda})`;
                }
                
                // 3. Patrones para Saldo: SALDO.PEN.MMAAAA o SALDO.USD.MMAAAA
                if (name.match(/^saldo\.(pen|usd)\.\d{6}/)) {
                    const match = name.match(/^saldo\.(pen|usd)\.\d{6}/);
                    const moneda = match[1].toUpperCase();
                    return `Saldo Anterior (${moneda})`;
                }
                
                // 4. Patrones legacy para compatibilidad
                if (name.includes('mayor') || name.includes('analitico')) {
                    return 'Mayor Anal√≠tico';
                } else if (name.includes('extracto') || name.includes('banco')) {
                    return 'Extractos Bancarios';
                } else if (name.includes('resumen') || name.includes('saldo')) {
                    return 'Resumen de Saldos';
                } else {
                    return 'Archivo General';
                }
            },

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            },

            formatResultKey(key) {
                const labels = {
                    fecha: 'Fecha de Conciliaci√≥n',
                    archivo_generado: 'Archivo Generado',
                    registros_procesados: 'Registros Procesados'
                };
                return labels[key] || key.replace(/_/g, ' ').toUpperCase();
            },

            formatResultValue(key, value) {
                if (key === 'fecha') {
                    return new Date(value).toLocaleString();
                }
                return value;
            },

            showStatus(message, type) {
                this.statusMessage = {
                    show: true,
                    text: message,
                    type: type
                };

                setTimeout(() => {
                    this.statusMessage.show = false;
                }, 5000);
            },

            // === FUNCIONES DE FORMATO PARA RESULTADOS ===
            
            formatResultKey(key) {
                const labels = {
                    fecha: 'Fecha de Conciliaci√≥n',
                    archivo_generado: 'Archivo Generado',
                    registros_procesados: 'Registros Procesados'
                };
                return labels[key] || key.replace(/_/g, ' ').toUpperCase();
            },

            formatResultValue(key, value) {
                if (key === 'fecha') {
                    return new Date(value).toLocaleString('es-ES', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                }
                return value;
            },

            // === FUNCI√ìN PARA CARGAR ARCHIVOS DE PRUEBA ===
            loadTestFiles() {
                // Crear archivos de prueba simulados con la nomenclatura correcta
                const currentDate = new Date();
                const month = String(currentDate.getMonth() + 1).padStart(2, '0');
                const year = currentDate.getFullYear();
                const periodo = `${month}${year}`;
                
                const testFiles = [
                    {
                        name: `MAYOR.PEN.${periodo}.xlsx`,
                        size: 150000,
                        category: 'mayor',
                        content: 'Archivo simulado de Mayor Anal√≠tico'
                    },
                    {
                        name: `BCP.01.PEN.${periodo}.xlsx`,
                        size: 85000,
                        category: 'extracto',
                        content: 'Archivo simulado de Extracto BCP.01'
                    },
                    {
                        name: `BCP.02.PEN.${periodo}.xlsx`,
                        size: 82000,
                        category: 'extracto',
                        content: 'Archivo simulado de Extracto BCP.02'
                    },
                    {
                        name: `SANT.PEN.${periodo}.xlsx`,
                        size: 78000,
                        category: 'extracto',
                        content: 'Archivo simulado de Extracto Santander'
                    },
                    {
                        name: `BBVA.PEN.${periodo}.xlsx`,
                        size: 65000,
                        category: 'extracto',
                        content: 'Archivo simulado de Extracto BBVA'
                    },
                    {
                        name: `IBK.PEN.${periodo}.xlsx`,
                        size: 72000,
                        category: 'extracto',
                        content: 'Archivo simulado de Extracto Interbank'
                    },
                    {
                        name: `SALDO.PEN.${periodo}.xlsx`,
                        size: 25000,
                        category: 'resumen',
                        content: 'Archivo simulado de Saldo Anterior'
                    }
                ];
                
                // Crear objetos File simulados
                testFiles.forEach(testFile => {
                    const blob = new Blob([testFile.content], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
                    const file = new File([blob], testFile.name, { type: blob.type });
                    
                    const fileObj = {
                        id: Date.now() + Math.random(),
                        name: testFile.name,
                        size: testFile.size,
                        file: file,
                        category: testFile.category
                    };
                    
                    this.files.push(fileObj);
                });
                
                this.showStatus(`${testFiles.length} archivos de prueba cargados con nomenclatura ${periodo}`, 'success');
                this.saveFilesToStorage();
            },

            async descargarConciliacion() {
                if (!this.conciliationResult) {
                    this.showStatus('No hay conciliaci√≥n para descargar', 'error');
                    return;
                }

                try {
                                    const data = {
                    fecha_conciliacion: this.conciliationResult.detalles?.fecha || new Date().toISOString().split('T')[0],
                    registros_procesados: this.conciliationResult.totalProcesados || 0,
                    conciliados: this.conciliationResult.conciliados || 0,
                    no_conciliados: this.conciliationResult.noConciliados || 0
                };

                    const jsonString = JSON.stringify(data, null, 2);
                    const blob = new Blob([jsonString], { type: 'application/json' });
                    
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.style.display = 'none';
                    a.href = url;
                    a.download = `resumen_conciliacion_${new Date().toISOString().split('T')[0]}.json`;
                    
                    document.body.appendChild(a);
                    a.click();
                    window.URL.revokeObjectURL(url);
                    document.body.removeChild(a);
                    
                    this.showStatus('Resumen de conciliaci√≥n descargado exitosamente', 'success');
                } catch (error) {
                    this.showStatus('Error al descargar resumen de conciliaci√≥n', 'error');
                }
            },

    // === FUNCI√ìN MULTI-CUENTA NUEVA ===
            procesarConciliacionMultiCuenta(extractosPorCuenta, datosMayorPEN, datosSaldo = null, datosMayorUSD = null) {
                // // console.log("=== INICIANDO CONCILIACI√ìN MULTI-CUENTA ===");
                
                const resultadosPorCuenta = new Map();
                
                                    // Procesar cada cuenta por separado
                extractosPorCuenta.forEach((extractoInfo, codigoCuenta) => {
                    if (codigoCuenta === '1041302') {
                        console.log(`üí∞ SBP.USD INICIANDO PROCESAMIENTO: ${codigoCuenta} (${extractoInfo.config.alias})`);
                    }
                    // // // console.log(`\nüìÇ Procesando cuenta ${extractoInfo.config.alias} (${codigoCuenta})`);
                    
                    // Seleccionar el archivo mayor apropiado seg√∫n la cuenta
                    let datosMayorParaCuenta;
                    const cuentasUSDMaestras = ['1041502', '1041402', '1041202', '1041302', '1041102']; // Lista de referencia USD (BCP, SANT, BBVA, SBP, IBK)
                    
                    if (cuentasUSDMaestras.includes(codigoCuenta) && datosMayorUSD) {
                        // Cuentas USD: usar archivo MAYOR.USD
                        datosMayorParaCuenta = datosMayorUSD;
                        if (codigoCuenta === '1041302') {
                            console.log(`üí∞ SBP.USD PROCESANDO CUENTA USD: ${codigoCuenta} (${extractoInfo.config.alias}) con MAYOR.USD`);
                        }
                    } else {
                        // Cuentas PEN: usar archivo MAYOR.PEN
                        datosMayorParaCuenta = datosMayorPEN;
                        if (codigoCuenta === '1041302') {
                            console.log(`‚ùå SBP.USD ERROR: No deber√≠a usar MAYOR.PEN`);
                        }
                    }
                    
                    // Llamar a la funci√≥n de conciliaci√≥n pasando informaci√≥n de cuenta espec√≠fica
                    const resultadoCuenta = this.procesarConciliacion(
                        extractoInfo.datos, 
                        datosMayorParaCuenta, 
                        datosSaldo, 
                        extractoInfo.config // ‚Üê NUEVO: Pasar configuraci√≥n de cuenta
                    );
                    
                    resultadosPorCuenta.set(codigoCuenta, {
                        config: extractoInfo.config,
                        resultado: resultadoCuenta,
                        archivo: extractoInfo.archivo
                    });
                    
                    // Log espec√≠fico para SBP.USD
                    if (codigoCuenta === '1041302') {
                        console.log(`‚úÖ SBP.USD RESULTADO: ${resultadoCuenta?.datosMayor?.length || 0} filas Mayor procesadas`);
                        console.log(`‚úÖ SBP.USD EXTRACTO: ${resultadoCuenta?.datosExtracto?.length || 0} filas Extracto procesadas`);
                    }
                });
                
                // === VERIFICAR SBP.USD (DIAGN√ìSTICO MEJORADO) ===
                console.log(`üîç DIAGN√ìSTICO SBP.USD FINAL:`);
                console.log(`   datosMayorUSD existe: ${!!datosMayorUSD}`);
                console.log(`   extractosPorCuenta tiene 1041302: ${extractosPorCuenta.has('1041302')}`);
                console.log(`   Config 1041302 existe: ${!!this.cuentasConfig['1041302']}`);
                console.log(`   Config 1041302 activo: ${this.cuentasConfig['1041302']?.activo}`);
                
                if (extractosPorCuenta.has('1041302')) {
                    const sbpInfo = extractosPorCuenta.get('1041302');
                    console.log(`‚úÖ SBP.USD YA DETECTADO Y CARGADO:`);
                    console.log(`   üìÅ Archivo: ${sbpInfo.archivo}`);
                    console.log(`   üìä Datos: ${sbpInfo.datos.length} filas`);
                    console.log(`   üè¶ Config: ${sbpInfo.config.alias} (${sbpInfo.config.codigo})`);
                    console.log(`   ‚ö° NO NECESITA FORZADO - archivo extracto detectado correctamente`);
                } else if (datosMayorUSD && this.cuentasConfig['1041302'] && this.cuentasConfig['1041302'].activo) {
                    // Solo forzar si NO se detect√≥ archivo de extracto
                    console.log(`‚ö†Ô∏è SBP.USD NO DETECTADO - Iniciando forzado desde MAYOR.USD`);
                    
                    // Buscar columna CUENTA din√°micamente (igual que arriba)
                    const headerMayorUSD = datosMayorUSD.length > 1 ? datosMayorUSD[1] : [];
                    const indicesMayorUSD = this.buscarIndicesColumnas(headerMayorUSD, {
                        cuenta: ['CUENTA']
                    });
                    
                    let filasSBPUSD = [];
                    if (indicesMayorUSD.cuenta !== -1) {
                        filasSBPUSD = datosMayorUSD.filter(fila => {
                            const cuenta = fila[indicesMayorUSD.cuenta] || '';
                            const cuentaStr = cuenta.toString().trim();
                            return cuentaStr.includes('1041302');
                        });
                    } else {
                        console.log(`‚ùå No se encontr√≥ columna CUENTA en MAYOR.USD para forzado`);
                        filasSBPUSD = [];
                    }
                    
                    console.log(`üìã Filas SBP.USD encontradas en MAYOR.USD: ${filasSBPUSD.length}`);
                    
                    if (filasSBPUSD.length > 0) {
                        console.log(`üîß FORZANDO SBP.USD desde MAYOR.USD (fallback sin extracto)`);
                        extractosPorCuenta.set('1041302', {
                            config: this.cuentasConfig['1041302'],
                            datos: [], // Sin datos de extracto - solo fallback
                            archivo: 'FORZADO_MAYOR_USD'
                        });
                        console.log(`‚úÖ SBP.USD forzado agregado. Total cuentas: ${extractosPorCuenta.size}`);
                    } else {
                        console.log(`‚ùå No se encontraron filas SBP.USD en MAYOR.USD para forzar`);
                    }
                } else {
                    console.log(`‚ùå SBP.USD: condiciones no cumplidas (no hay MAYOR.USD o cuenta inactiva)`);
                }
                
                // Consolidar resultados
                return this.consolidarResultadosMultiCuenta(resultadosPorCuenta, datosMayorPEN, datosSaldo, datosMayorUSD);
            },

            // === FUNCI√ìN PARA CONSOLIDAR MAYOR DE M√öLTIPLES CUENTAS ===
            consolidarDatosMayorPorCuentas(resultadosPorCuenta) {
                if (resultadosPorCuenta.size === 0) {
                    return [];
                }

                let headerMayor = null;
                const registrosConsolidados = [];
                const registrosYaProcesados = new Set();

                let totalOriginal = 0;
                let duplicadosEliminados = 0;

                // Consolidaci√≥n Mayor Multi-cuenta

                // Recorrer cada cuenta y consolidar sus datos del mayor
                resultadosPorCuenta.forEach((cuentaInfo, codigoCuenta) => {
                    if (cuentaInfo.resultado && cuentaInfo.resultado.datosMayor) {
                        const datosMayorCuenta = cuentaInfo.resultado.datosMayor;
                        const registrosCuenta = datosMayorCuenta.length - 1; // Sin header
                        totalOriginal += registrosCuenta;
                        
                        // // console.log(`üìä Cuenta ${codigoCuenta}: ${registrosCuenta} registros`);
                        
                        // Tomar el header del primer resultado (todos deber√≠an ser iguales)
                        if (!headerMayor && datosMayorCuenta.length > 0) {
                            headerMayor = datosMayorCuenta[0];
                        }
                        
                        // Agregar registros de datos (saltando el header)
                        for (let i = 1; i < datosMayorCuenta.length; i++) {
                            const registro = datosMayorCuenta[i];
                            
                            // ‚≠ê CLAVE M√ÅS ESPEC√çFICA PARA EVITAR FALSOS DUPLICADOS
                            // Incluir m√°s columnas: DES_TDOP, NUMDOC, FDOC, LIBRO, COMPROB, CUENTA, GLOSA, DEBE, HABER
                            const claveRegistro = registro.slice(0, 13).join('|'); // Primeras 13 columnas en lugar de 8
                            
                            if (!registrosYaProcesados.has(claveRegistro)) {
                                registrosConsolidados.push(registro);
                                registrosYaProcesados.add(claveRegistro);
                            } else {
                                duplicadosEliminados++;
                                // Debug para SANT
                                if (codigoCuenta === '1041401' && duplicadosEliminados <= 3) {
                                    // // console.log(`üîç DUPLICADO eliminado ${duplicadosEliminados}: NUMDOC="${registro[1]}", FDOC="${registro[2]}", GLOSA="${registro[11]}"`);
                                }
                            }
                        }
                        
                        // // console.log(`üìã Consolidando Mayor de ${cuentaInfo.config.alias}: ${datosMayorCuenta.length - 1} registros`);
                    }
                });

                // Resumen consolidaci√≥n completo

                // Construir resultado final con header + todos los registros
                const resultado = headerMayor ? [headerMayor, ...registrosConsolidados] : registrosConsolidados;
                
                // Mayor consolidado
                
                return resultado;
            },

            // === FUNCI√ìN PARA FILTRAR MAYOR POR CUENTAS ESPEC√çFICAS ===
            // NOTA: Para MAYOR.USD ahora se usa el archivo completo sin filtrado
            filtrarMayorPorCuentas(datosMayor, cuentasPermitidas) {
                console.log(`üîç FILTRAR MAYOR POR CUENTAS - INICIANDO (LEGACY):`);
                console.log(`   üìã Cuentas a filtrar: [${cuentasPermitidas.join(', ')}]`);
                console.log(`   üìä Filas totales archivo: ${datosMayor?.length || 0}`);
                
                if (!datosMayor || datosMayor.length < 2) {
                    console.log(`‚ùå Archivo insuficiente: ${datosMayor?.length || 0} filas`);
                    return [];
                }
                
                // Obtener header del mayor (fila 2)
                const headerMayor = datosMayor[1];
                const indicesMayor = this.buscarIndicesColumnas(headerMayor, {
                    cuenta: ['CUENTA']
                });
                
                console.log(`   üìã Header encontrado:`, headerMayor);
                console.log(`   üîç √çndice columna CUENTA: ${indicesMayor.cuenta}`);
                
                if (indicesMayor.cuenta === -1) {
                    console.warn('‚ö†Ô∏è No se encontr√≥ columna CUENTA en el mayor');
                    return datosMayor; // Retornar todo si no se puede filtrar
                }
                
                // === DIAGN√ìSTICO: VER QU√â CUENTAS EXISTEN EN EL ARCHIVO ===
                const cuentasEncontradas = new Set();
                const filasData = datosMayor.slice(2);
                filasData.forEach((fila, idx) => {
                    const codigoCuenta = String(fila[indicesMayor.cuenta] || '').trim();
                    if (codigoCuenta) {
                        cuentasEncontradas.add(codigoCuenta);
                    }
                });
                
                console.log(`   üìä Cuentas existentes en archivo: [${Array.from(cuentasEncontradas).sort().join(', ')}]`);
                
                // === DIAGN√ìSTICO: VER CU√ÅLES DE LAS 5 USD EXISTEN ===
                const cuentasUSDRequeridas = ['1041502', '1041402', '1041202', '1041302', '1041102'];
                const cuentasUSDEncontradas = cuentasUSDRequeridas.filter(cuenta => cuentasEncontradas.has(cuenta));
                const cuentasUSDFaltantes = cuentasUSDRequeridas.filter(cuenta => !cuentasEncontradas.has(cuenta));
                
                console.log(`   ‚úÖ Cuentas USD ENCONTRADAS: [${cuentasUSDEncontradas.join(', ')}]`);
                console.log(`   ‚ùå Cuentas USD FALTANTES: [${cuentasUSDFaltantes.join(', ')}]`);
                
                // Filtrar filas seg√∫n las cuentas permitidas
                const filasFiltered = [];
                
                // Agregar filas de encabezado (fila 0 y 1)
                filasFiltered.push(datosMayor[0]);
                filasFiltered.push(datosMayor[1]);
                
                // Filtrar filas de datos (desde fila 2) con conteo por cuenta
                const contadorPorCuenta = {};
                filasData.forEach((fila, idx) => {
                    const codigoCuenta = String(fila[indicesMayor.cuenta] || '').trim();
                    
                    // Verificar si la cuenta est√° en la lista de cuentas permitidas
                    if (cuentasPermitidas.includes(codigoCuenta)) {
                        filasFiltered.push(fila);
                        contadorPorCuenta[codigoCuenta] = (contadorPorCuenta[codigoCuenta] || 0) + 1;
                    }
                });
                
                console.log(`   üìä RESULTADO FILTRADO:`);
                console.log(`      üìã Filas filtradas: ${filasFiltered.length - 2} de ${filasData.length} totales`);
                Object.entries(contadorPorCuenta).forEach(([cuenta, cantidad]) => {
                    console.log(`      üí∞ ${cuenta}: ${cantidad} filas`);
                });
                
                return filasFiltered;
            },

            // === FUNCI√ìN PARA EXCLUIR CUENTAS ESPEC√çFICAS DEL MAYOR ===
            excluirCuentaDelMayor(datosMayor, cuentasExcluir) {
                if (!datosMayor || datosMayor.length < 2) {
                    return [];
                }
                
                // Obtener header del mayor (fila 2)
                const headerMayor = datosMayor[1];
                const indicesMayor = this.buscarIndicesColumnas(headerMayor, {
                    cuenta: ['CUENTA']
                });
                
                if (indicesMayor.cuenta === -1) {
                    console.warn('‚ö†Ô∏è No se encontr√≥ columna CUENTA en el mayor');
                    return datosMayor; // Retornar todo si no se puede filtrar
                }
                
                // Filtrar filas excluyendo las cuentas especificadas
                const filasFiltered = [];
                
                // Agregar filas de encabezado (fila 0 y 1)
                filasFiltered.push(datosMayor[0]);
                filasFiltered.push(datosMayor[1]);
                
                // Filtrar filas de datos (desde fila 2)
                const filasData = datosMayor.slice(2);
                filasData.forEach((fila, idx) => {
                    const codigoCuenta = String(fila[indicesMayor.cuenta] || '').trim();
                    
                    // Verificar si la cuenta NO est√° en la lista de cuentas a excluir
                    if (!cuentasExcluir.includes(codigoCuenta)) {
                        filasFiltered.push(fila);
                    }
                });
                
                // // console.log(`üìã Exclusi√≥n de cuentas [${cuentasExcluir.join(', ')}]: ${filasFiltered.length - 2} filas mantenidas de ${filasData.length} originales`);
                
                return filasFiltered;
            },

            // Consolidar todos los resultados en estructura final
            consolidarResultadosMultiCuenta(resultadosPorCuenta, datosMayorPEN, datosSaldo, datosMayorUSD = null) {
                let totalProcesados = 0;
                
                // === CONSOLIDAR DATOS MAYOR PEN (solo cuentas PEN) ===
                const resultadosPEN = new Map();
                const resultadosUSD = new Map();
                
                // Separar resultados por moneda usando funci√≥n maestra
                // console.log(`üîç Separando resultados por moneda. Total cuentas: ${resultadosPorCuenta.size}`);
                const cuentasUSDMaestras = ['1041502', '1041402', '1041202', '1041302', '1041102']; // Lista de referencia USD (BCP, SANT, BBVA, SBP, IBK)
                
                resultadosPorCuenta.forEach((valor, codigo) => {
                    if (cuentasUSDMaestras.includes(codigo)) {
                        resultadosUSD.set(codigo, valor);
                        if (codigo === '1041302') {
                            console.log(`   SBP.USD agregado a resultadosUSD: ${codigo} (${valor.config?.alias || 'sin alias'})`);
                        }
                    } else {
                        resultadosPEN.set(codigo, valor);
                        // console.log(`   PEN: ${codigo} (${valor.config?.alias || 'sin alias'})`);
                    }
                });
                if (resultadosUSD.has('1041302')) {
                    console.log(`üìä SBP.USD est√° en resultadosUSD. Total USD: ${resultadosUSD.size} cuentas`);
                } else {
                    console.log(`‚ùå SBP.USD NO est√° en resultadosUSD. Total USD: ${resultadosUSD.size} cuentas`);
                }
                
                // Consolidar MAYOR.PEN (solo cuentas PEN)
                const datosMayorConsolidadoPEN = this.consolidarDatosMayorPorCuentas(resultadosPEN);
                
                // === CONSOLIDAR MAYOR.USD CON L√ìGICA DE CONCILIACI√ìN RESTAURADA ===
                console.log(`üîÑ CONSOLIDANDO MAYOR.USD con l√≥gica de conciliaci√≥n + filtrado final`);
                let datosMayorUSDFinal = null;
                
                if (resultadosUSD.size > 0) {
                    // OPCI√ìN 1: Usar consolidaci√≥n cuenta por cuenta (como antes)
                    console.log(`‚úÖ SBP.USD Consolidando ${resultadosUSD.size} cuentas USD con l√≥gica de conciliaci√≥n`);
                    
                    // DEBUG: Ver solo SBP.USD
                    if (resultadosUSD.has('1041302')) {
                        const sbpInfo = resultadosUSD.get('1041302');
                        const mayorLength = sbpInfo.resultado?.datosMayor?.length || 0;
                        const extractoLength = sbpInfo.resultado?.datosExtracto?.length || 0;
                        console.log(`   SBP.USD (1041302): Mayor=${mayorLength}, Extracto=${extractoLength}`);
                    } else {
                        console.log(`‚ùå SBP.USD NO encontrado en resultadosUSD`);
                    }
                    
                    datosMayorUSDFinal = this.consolidarDatosMayorPorCuentas(resultadosUSD);
                    console.log(`‚úÖ SBP.USD MAYOR.USD consolidado: ${datosMayorUSDFinal?.length || 0} filas de ${resultadosUSD.size} cuenta(s) USD`);
                } else if (datosMayorUSD) {
                    // OPCI√ìN 2: Filtrado directo con estructura correcta (fallback)
                    console.log(`‚ö†Ô∏è No hay cuentas USD procesadas, usando filtrado directo con estructura correcta`);
                    
                    // Buscar header real en MAYOR.USD
                    let filaHeaderReal = -1;
                    for (let i = 0; i < Math.min(5, datosMayorUSD.length); i++) {
                        const fila = datosMayorUSD[i];
                        if (fila && fila.length > 7 && 
                            (String(fila[7]).includes('CUENTA') || String(fila[0]).includes('DES_TDOC'))) {
                            filaHeaderReal = i;
                            break;
                        }
                    }
                    
                    if (filaHeaderReal !== -1) {
                        const cuentasUSDFiltro = ['1041502', '1041402', '1041202', '1041302', '1041102'];
                        const filasFiltradas = [];
                        
                        // Header con ESTADO y #REF en columnas O y P
                        const headerOriginal = datosMayorUSD[filaHeaderReal];
                        const headerAjustado = [...headerOriginal];
                        while (headerAjustado.length < 14) headerAjustado.push('');
                        headerAjustado[14] = 'ESTADO'; // Columna O
                        headerAjustado[15] = '#REF';   // Columna P
                        filasFiltradas.push(headerAjustado);
                        
                        // Datos filtrados por cuenta
                        for (let i = filaHeaderReal + 1; i < datosMayorUSD.length; i++) {
                            const fila = datosMayorUSD[i];
                            const cuentaColumnaH = String(fila[7] || '').trim();
                            
                            if (cuentasUSDFiltro.includes(cuentaColumnaH)) {
                                const filaAjustada = [...fila];
                                while (filaAjustada.length < 14) filaAjustada.push('');
                                filaAjustada[14] = 'Pendiente'; // Columna O
                                filaAjustada[15] = '';          // Columna P
                                filasFiltradas.push(filaAjustada);
                            }
                        }
                        
                        datosMayorUSDFinal = filasFiltradas;
                        console.log(`‚úÖ MAYOR.USD filtrado directo: ${filasFiltradas.length - 1} filas`);
                    }
                } else {
                    console.log(`‚ùå No hay MAYOR.USD disponible`);
                }
                
                // Preparar extractos por cuenta
                const extractosPorCuentaResultado = new Map();
                
                resultadosPorCuenta.forEach((cuentaInfo, codigoCuenta) => {
                    if (codigoCuenta === '1041302') {
                        console.log(`üîç SBP.USD CONSOLIDANDO ${codigoCuenta} (${cuentaInfo.config.alias}):`);
                        console.log(`   üìÅ SBP.USD Archivo: ${cuentaInfo.archivo}`);
                        console.log(`   üìä SBP.USD Resultado existe: ${!!cuentaInfo.resultado}`);
                        console.log(`   üìã SBP.USD datosExtracto existe: ${!!(cuentaInfo.resultado && cuentaInfo.resultado.datosExtracto)}`);
                    }
                    
                    if (cuentaInfo.resultado && cuentaInfo.resultado.datosExtracto) {
                        if (codigoCuenta === '1041302') {
                            console.log(`   üìä SBP.USD datosExtracto longitud: ${cuentaInfo.resultado.datosExtracto.length}`);
                            if (cuentaInfo.resultado.datosExtracto.length > 0) {
                                console.log(`   üìã SBP.USD Primera fila (header):`, cuentaInfo.resultado.datosExtracto[0]);
                            }
                        }
                        
                        extractosPorCuentaResultado.set(codigoCuenta, {
                            config: cuentaInfo.config,
                            datosExtracto: cuentaInfo.resultado.datosExtracto, // ‚úÖ DEBE INCLUIR HEADERS
                            archivo: cuentaInfo.archivo
                        });
                        totalProcesados += cuentaInfo.resultado.totalProcesados || 0;
                        if (codigoCuenta === '1041302') {
                            console.log(`   ‚úÖ SBP.USD Agregado a extractosPorCuentaResultado`);
                        }
                    } else if (cuentaInfo.archivo === 'MAYOR_USD_ONLY' || cuentaInfo.archivo === 'FORZADO_MAYOR_USD') {
                        // Para cuentas USD sin extracto real, crear entrada vac√≠a
                        extractosPorCuentaResultado.set(codigoCuenta, {
                            config: cuentaInfo.config,
                            datosExtracto: [], // Sin datos de extracto
                            archivo: cuentaInfo.archivo
                        });
                        console.log(`üìã ${codigoCuenta} (${cuentaInfo.config.alias}): Pesta√±a preparada desde ${cuentaInfo.archivo}`);
                        totalProcesados += cuentaInfo.resultado?.totalProcesados || 0;
                    } else {
                        console.log(`   ‚ùå No se pudo procesar: resultado o datosExtracto faltante`);
                    }
                });
                
                // Usar saldo del primer resultado (todos los saldos deber√≠an ser iguales)
                const primerResultado = Array.from(resultadosPorCuenta.values())[0];
                const datosSaldoConsolidado = primerResultado ? primerResultado.resultado.datosSaldo : [];
                
                return {
                    datosMayor: datosMayorConsolidadoPEN, // MAYOR.PEN (solo cuentas PEN procesadas)
                    datosMayorUSD: datosMayorUSDFinal, // MAYOR.USD (cuenta 1041502 desde archivo propio)
                    extractosPorCuenta: extractosPorCuentaResultado, // Nueva estructura
                    datosSaldo: datosSaldoConsolidado,
                    totalProcesados: totalProcesados
                };
            },

    // --- L√≥gica de Conciliaci√≥n Principal (mantenida del c√≥digo original) ---
            procesarConciliacion(datosExtracto, datosMayor, datosSaldo = null, cuentaConfig = null) {
        // === LOGS DE DIAGN√ìSTICO DE ENTRADA ===
        console.log(`üöÄ INICIANDO procesarConciliacion para ${cuentaConfig ? cuentaConfig.alias : 'SIN_CONFIG'}`);
        console.log(`üìä datosExtracto recibido: ${datosExtracto?.length || 0} filas`);
        if (datosExtracto && datosExtracto.length > 0) {
            console.log(`üîç PRIMERA FILA ENTRADA (deber√≠a ser header):`, datosExtracto[0]);
            if (datosExtracto.length > 1) {
                console.log(`üîç SEGUNDA FILA ENTRADA (deber√≠a ser datos):`, datosExtracto[1]);
            }
        }
        
        // // console.log("=== INICIANDO CONCILIACI√ìN ===");
        // // // console.log(`üìä Extracto: ${datosExtracto.length} filas | Mayor: ${datosMayor.length} filas`);

        // --- MAPEO DE √çNDICES ---
        const headersMayorRow = datosMayor.length > 1 ? datosMayor[1] : [];
        
        // // // console.log(`üìã HEADERS MAYOR (fila 2):`, headersMayorRow);
        // // // console.log(`   Total de columnas en header: ${headersMayorRow.length}`);
                const indicesMayor = this.buscarIndicesColumnas(headersMayorRow, {
            cuenta: ['CUENTA'], glosa: ['GLOSA'], paso: ['PASO'], fdoc: ['FDOC', 'FECHA'],
            debe: ['DEBE'], haber: ['HABER'], numdoc: ['NUMDOC'], libro: ['LIBRO'], 
            desTdop: ['DES_TDOP'], comprob: ['COMPROB']
        });

        // === HEADERS DIN√ÅMICOS SEG√öN CUENTA ===
        // Determinar fila del header seg√∫n configuraci√≥n de cuenta
        let filaHeader = 4; // Por defecto fila 5 (√≠ndice 4) para BCP
        let filaDataInicio = 5; // Por defecto fila 6 (√≠ndice 5) para BCP
        
        if (cuentaConfig && cuentaConfig.estructuraEspecial) {
            // IMPORTANTE: Si readExcelFile aplic√≥ estructuraEspecial, los datos YA est√°n reestructurados
            // con header en fila 0 y datos desde fila 1. NO recalcular las posiciones.
            console.log(`üîß NOTA: ${cuentaConfig.alias} tiene estructuraEspecial - readExcelFile ya reestructur√≥ los datos`);
            console.log(`   ‚ûú Header ya est√° en fila 0, datos desde fila 1`);
            filaHeader = 0; // Header ya reestructurado en fila 0 por readExcelFile
            filaDataInicio = 1; // Datos ya reestructurados desde fila 1 por readExcelFile
        }
        
        const headersExtracto = datosExtracto.length > filaHeader ? datosExtracto[filaHeader] : [];
                // === MAPEO DIN√ÅMICO DE COLUMNAS SEG√öN EL BANCO ===
        let camposMapeados = {
            fecha: ['FECHA'], 
            monto: ['MONTO', 'IMPORTE'], 
            operacion: ['OPERACION', 'NUMERO'],
            descripcion: ['DESCRIPCION OPERACION', 'DESCRIPCI√ìN OPERACI√ìN', 'DESCRIPCION', 'DESC', 'MOVIMIENTO']
        };
        
        // Ajustar mapeo espec√≠fico por banco
        if (cuentaConfig && (cuentaConfig.alias === 'SBP' || cuentaConfig.alias === 'SBP.USD')) {
            camposMapeados = {
                fecha: ['FECHA'],
                monto: ['IMPORTE'],
                operacion: ['REFERENCIA'],
                descripcion: ['MOVIMIENTO']
            };
        } else if (cuentaConfig && (cuentaConfig.alias === 'SANT' || cuentaConfig.alias === 'SANT.USD')) {
            camposMapeados = {
                fecha: ['FECHA'],
                monto: ['IMPORTE', 'MONTO'],
                operacion: ['REFERENCIA', 'NUMERO'],
                descripcion: ['DESCRIPCION', 'CONCEPTO']
            };
        } else if (cuentaConfig && (cuentaConfig.alias === 'BBVA' || cuentaConfig.alias === 'BBVA.USD')) {
            camposMapeados = {
                fecha: ['F. OPERACION', 'FECHA'],
                monto: ['IMPORTE', 'MONTO'],
                operacion: ['NUMERO', 'REFERENCIA'],
                descripcion: ['CONCEPTO', 'DESCRIPCION']
            };
        }
        
        const indicesExtracto = this.buscarIndicesColumnas(headersExtracto, camposMapeados);
        
        // // console.log(`üìã HEADERS EXTRACTO (${cuentaConfig?.alias || 'GEN√âRICO'} - Fila ${filaHeader + 1}):`, headersExtracto);
        
        // // console.log("üîç √çndices mapeados correctamente");
        // // // console.log(`üìã √çndices Mayor:`, indicesMayor);
        // // // console.log(`üìã √çndices Extracto:`, indicesExtracto);
        // // // console.log(`üìã Archivo Saldo disponible: ${datosSaldo ? 'S√ç' : 'NO'} ${datosSaldo ? '(' + datosSaldo.length + ' filas)' : ''}`);
        
        // --- ESTRUCTURA GLOBAL PARA ESTADOS DEL SALDO ---
        let estadosSaldo = new Map();
        // Inicializar estados del saldo si hay datos
        if (datosSaldo && datosSaldo.length > 1) {
            const filasSaldo = datosSaldo.slice(1);
            for (let i = 0; i < filasSaldo.length; i++) {
                estadosSaldo.set(i, { estado: 'Pendiente', ref: '' });
            }
            // // // console.log(`üìä Inicializado estadosSaldo con ${estadosSaldo.size} entradas`);
        }
        
        // VERIFICAR QUE LOS √çNDICES CR√çTICOS EST√âN BIEN MAPEADOS
        const indicesCriticos = ['numdoc', 'glosa', 'debe', 'haber', 'comprob'];
        indicesCriticos.forEach(campo => {
            if (indicesMayor[campo] === -1) {
                // // // console.log(`‚ùå ERROR: No se encontr√≥ √≠ndice para ${campo.toUpperCase()}`);
            } else {
                // // // console.log(`‚úÖ ${campo.toUpperCase()} mapeado en √≠ndice ${indicesMayor[campo]}`);
            }
        });
        
        // --- FILTROS APLICADOS ---
        let dataRowsMayor = datosMayor.slice(2);
        
        // === PASO 1: Filtro por Cuenta Espec√≠fica (si se proporciona) ===
        let filasFiltradasMayor = dataRowsMayor;
        
        if (indicesMayor.cuenta !== -1) {
            const countInicial = filasFiltradasMayor.length;
            
            if (cuentaConfig && cuentaConfig.codigo) {
                // Filtrar SOLO por la cuenta espec√≠fica que se est√° procesando
                const codigoCuentaEspecifica = cuentaConfig.codigo;
                
                // üîç DEBUG PASO 1 - FILTRO CUENTA SANT
                if (codigoCuentaEspecifica === '1041401') {
                    // // console.log(`\nüîç === DEBUG PASO 1 - FILTRO CUENTA SANT ===`);
                    // // console.log(`üìä Total filas antes del filtro: ${countInicial}`);
                    // // console.log(`üéØ Buscando cuenta: "${codigoCuentaEspecifica}"`);
                    
                    // Mostrar ejemplos de cuentas en las primeras 10 filas
                    // // console.log(`üìã Muestra de cuentas en primeras 10 filas:`);
                    for (let i = 0; i < Math.min(10, filasFiltradasMayor.length); i++) {
                        const cuentaEjemplo = (filasFiltradasMayor[i][indicesMayor.cuenta] || '').toString();
                        const coincide = cuentaEjemplo === codigoCuentaEspecifica;
                        // // console.log(`   Fila ${i}: "${cuentaEjemplo}" ${coincide ? '‚úÖ' : '‚ùå'}`);
                    }
                }
                
            filasFiltradasMayor = filasFiltradasMayor.filter(fila => {
                const cuenta = (fila[indicesMayor.cuenta] || '').toString();
                    return cuenta === codigoCuentaEspecifica;
                });
                
                // üîç DEBUG PASO 1 - RESULTADO FILTRO SANT
                if (codigoCuentaEspecifica === '1041401') {
                    // // console.log(`üìä Total filas despu√©s del filtro: ${filasFiltradasMayor.length}`);
                    // // console.log(`üéØ Deber√≠an ser 44 registros para SANT`);
                    // // console.log(`===============================================`);
                }
                
                // // // console.log(`üîß PASO 1 - Filtro Cuenta Espec√≠fica: ${countInicial} ‚Üí CUENTA=${codigoCuentaEspecifica} (${cuentaConfig.alias}) ‚Üí ${filasFiltradasMayor.length} filas`);
        } else {
                // Fallback: Filtrar por todas las cuentas activas (para compatibilidad)
                const cuentasActivas = this.getCuentasFiltro();
                
                filasFiltradasMayor = filasFiltradasMayor.filter(fila => {
                    const cuenta = (fila[indicesMayor.cuenta] || '').toString();
                    return cuentasActivas.includes(cuenta);
                });
                
                // // // console.log(`üîß PASO 1 - Filtro Cuentas Activas (fallback): ${countInicial} ‚Üí CUENTAS=${cuentasActivas.join(',')} ‚Üí ${filasFiltradasMayor.length} filas`);
            }
        } else {
            // // // console.log(`üîß PASO 1 - Filtro Cuentas: ${filasFiltradasMayor.length} filas (columna CUENTA no encontrada)`);
        }
        
        // PASO 2: Omisiones Globales - Excluir t√©rminos espec√≠ficos en GLOSA
        const terminosExclusion = ["AMERICAN EXP", "CALIDDA", "DINERS", "MASTER CARD", "MERCADOPAGO", "VISANET"];
        
        // // // console.log(`üîç VERIFICACI√ìN PASO 2 - GLOSA √≠ndice: ${indicesMayor.glosa}`);
        
        if (indicesMayor.glosa !== -1) {
            const countAntesFiltro = filasFiltradasMayor.length;
            
            // Debug: Mostrar muestra de valores GLOSA
            // // // console.log(`üîç Primeras 3 filas GLOSA antes del filtro:`);
            filasFiltradasMayor.slice(0, 3).forEach((fila, idx) => {
                const glosa = fila[indicesMayor.glosa] || '';
                // // // console.log(`  Fila ${idx}: "${glosa}"`);
            });
            
            let filasExcluidas = 0;
            filasFiltradasMayor = filasFiltradasMayor.filter(fila => {
                const glosa = (fila[indicesMayor.glosa] || '').toString().toUpperCase();
                const excluir = terminosExclusion.some(termino => glosa.startsWith(termino.toUpperCase()));
                if (excluir) {
                    filasExcluidas++;
                    if (filasExcluidas <= 3) {
                        // // // console.log(`  ‚ùå EXCLUIDA: "${glosa}"`);
                    }
                }
                return !excluir;
            });
            
            // // // console.log(`üîß PASO 2 - Omisiones Globales: ${countAntesFiltro} ‚Üí Excluidas ${filasExcluidas} ‚Üí ${filasFiltradasMayor.length} filas`);
        } else {
            // // // console.log(`‚ùå PASO 2 - ERROR: Columna GLOSA no encontrada en √≠ndice ${indicesMayor.glosa}`);
            // // // console.log(`üìã Headers disponibles:`, headersMayorRow);
        }
        
        // // // console.log(`‚úÖ FILTROS COMPLETADOS: ${dataRowsMayor.length} ‚Üí ${filasFiltradasMayor.length} filas finales`)

        // Preparar extracto para conciliaci√≥n (datos empiezan din√°micamente seg√∫n cuenta)
        let extractoProcesable = datosExtracto.slice(filaDataInicio).map(fila => ({ fila, conciliado: false }));
        
        // // console.log(`üìä EXTRACTO PROCESABLE (${cuentaConfig?.alias || 'GEN√âRICO'}): ${extractoProcesable.length} filas desde fila ${filaDataInicio + 1}`);

        // VERIFICAR CU√ÅNTAS ANULACIONES HAY EN TOTAL
        const anulacionesEncontradas = filasFiltradasMayor.filter(fila => {
            const glosa = fila[indicesMayor.glosa] || '';
            return glosa.toUpperCase().includes('ANULADO');
        });
        
        // // // console.log(`üîç ANULACIONES DETECTADAS EN FILTRADO: ${anulacionesEncontradas.length} de ${filasFiltradasMayor.length} filas totales`);
        
        // Mostrar primeras 3 anulaciones como muestra
        anulacionesEncontradas.slice(0, 3).forEach((fila, idx) => {
            const numdoc = fila[indicesMayor.numdoc] || '';
            const glosa = fila[indicesMayor.glosa] || '';
            const debe = fila[indicesMayor.debe] || '';
            const haber = fila[indicesMayor.haber] || '';
            // // // console.log(`   Anulaci√≥n ${idx + 1}: NUMDOC=${numdoc}, DEBE=${debe}, HABER=${haber}, GLOSA="${glosa}"`);
        });

        // === PREPARACI√ìN PARA PROCESAMIENTO MULTI-CUENTA ===
        // Agrupar filas por cuenta para futuro procesamiento paralelo
        const filasPorCuenta = new Map();
        filasFiltradasMayor.forEach((fila, index) => {
            const cuenta = (fila[indicesMayor.cuenta] || '').toString();
            if (!filasPorCuenta.has(cuenta)) {
                filasPorCuenta.set(cuenta, []);
            }
            filasPorCuenta.get(cuenta).push({ fila, index });
        });
        
        // // // console.log(`üìä AGRUPACI√ìN POR CUENTA: ${filasPorCuenta.size} cuentas detectadas`);
        // filasPorCuenta.forEach((filas, cuenta) => {
        //     // // console.log(`   Cuenta ${cuenta}: ${filas.length} registros`);
        // });

        // --- PROCESO DE CONCILIACI√ìN ---
        const resultados = [];
        let paso3Procesados = 0;
        let paso3Conciliados = 0;
        let paso3Etapa2 = 0; // Etapa 3b: Anulado Saldo
        let paso3Etapa3 = 0; // Etapa 3c: Anulaciones en Mayor
        
        // NUEVO ENFOQUE: Mapear estados para todas las filas primero
        const estadosFilas = new Map(); // √≠ndice ‚Üí {estado, ref}
        
        for (let i = 0; i < filasFiltradasMayor.length; i++) {
            const filaMayor = filasFiltradasMayor[i];
            const glosa = filaMayor[indicesMayor.glosa] || '';
            const numdoc = filaMayor[indicesMayor.numdoc] || '';
            
            // Si ya fue procesada como parte de un par, continuar
            if (estadosFilas.has(i)) continue;
            
            // Verificar si es anulaci√≥n por GLOSA
            const esAnulacion = glosa.toUpperCase().includes('ANULADO');

            // DEBUG: Log para las primeras 3 filas de anulaciones solamente
            if (esAnulacion && paso3Procesados < 3) {
                // // // console.log(`üîç DEBUG Anulaci√≥n ${paso3Procesados + 1}:`);
                // // // console.log(`   NUMDOC: "${numdoc}"`);
                // // // console.log(`   GLOSA: "${glosa}"`);
                // // // console.log(`   √çndice en array: ${i}`);
            }
            
            if (esAnulacion) {
                paso3Procesados++;
                const resultadoPaso3 = this.procesarPaso3(filaMayor, extractoProcesable, indicesMayor, indicesExtracto, filasFiltradasMayor, datosSaldo, i);
                
                if (resultadoPaso3.estado) {
                    // Asignar estado a la fila actual
                    estadosFilas.set(i, {
                        estado: resultadoPaso3.estado,
                        ref: resultadoPaso3.ref || ''
                    });
                    
                    paso3Conciliados++;
                    
                    // Si hay pareja interna (ETAPA 3c), asignar estado tambi√©n a la pareja
                    if (resultadoPaso3.etapa === 3 && resultadoPaso3.indiceParejaEncontrada !== -1) {
                        const indicePareja = resultadoPaso3.indiceParejaEncontrada;
                        estadosFilas.set(indicePareja, {
                            estado: resultadoPaso3.estadoPareja,
                            ref: resultadoPaso3.refPareja
                        });
                        
                        // // // console.log(`‚úÖ PASO 3c - PAR PROCESADO:`);
                        // // // console.log(`   Fila ${i + 1}: ESTADO="${resultadoPaso3.estado}", REF="${resultadoPaso3.ref}"`);
                        // // // console.log(`   Fila ${indicePareja + 1}: ESTADO="${resultadoPaso3.estadoPareja}", REF="${resultadoPaso3.refPareja}"`);
                        
                        paso3Conciliados++; // Contar tambi√©n la pareja
                    }
                    
                    // Contar por etapa
                    if (resultadoPaso3.etapa === 2) {
                        paso3Etapa2++; // Etapa 3b: Anulado Saldo
                        
                        // Actualizar estado del saldo si hay un match encontrado (ETAPA 3b)
                        if (resultadoPaso3.indiceParejaEncontrada !== -1 && datosSaldo && datosSaldo.length > 1) {
                            // Actualizar estado de la fila correspondiente en saldo
                            estadosSaldo.set(resultadoPaso3.indiceParejaEncontrada, {
                                estado: resultadoPaso3.estadoPareja,
                                ref: resultadoPaso3.refPareja
                            });
                            
                            // // // console.log(`‚úÖ PASO 3b - SALDO ACTUALIZADO:`);
                            // // // console.log(`   Saldo fila ${resultadoPaso3.indiceParejaEncontrada + 1}: ESTADO="${resultadoPaso3.estadoPareja}", REF="${resultadoPaso3.refPareja}"`);
                        }
                        
                    } else if (resultadoPaso3.etapa === 3) {
                        paso3Etapa3++; // Etapa 3c: Anulaciones en Mayor
                    }
                } else {
                    // Caso por defecto para anulados no procesados
                    estadosFilas.set(i, {
                        estado: 'Anulado Sin Procesar',
                        ref: numdoc
                    });
                }
            }
        }
        
        // PASO 4: Operaciones BNA (Banco de la Naci√≥n)
        // // // console.log(`\nüè¶ INICIANDO PASO 4: Operaciones BNA`);
        // // // console.log(`   üìã Extracto procesable: ${extractoProcesable.length} filas disponibles`);
        const estadosExtracto = new Map(); // Para rastrear estados del extracto
        
        const resultadosPaso4 = this.procesarPaso4(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        // // // console.log(`üìä PASO 4 COMPLETADO: ${resultadosPaso4.conciliados} conciliaciones BNA procesadas`);
        
        // PASO 5: Operaciones PROT y DEV (Agrupaci√≥n por totales diarios)
        // // // console.log(`\nüìà INICIANDO PASO 5: Operaciones PROT y DEV`);
        // // // console.log(`   üìã Extracto procesable: ${extractoProcesable.length} filas disponibles`);
        
        const resultadosPaso5 = this.procesarPaso5(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        // // // console.log(`üìä PASO 5 COMPLETADO: ${resultadosPaso5.conciliados} conciliaciones PROT/DEV procesadas`);
        
        // // // console.log(`\nüè¶ INICIANDO PASO 6: Dep√≥sitos Bancarios`);
        // // // console.log(`   üìã Extracto procesable: ${extractoProcesable.length} filas disponibles`);
        
        const resultadosPaso6 = this.procesarPaso6(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        // // // console.log(`üìä PASO 6 COMPLETADO: ${resultadosPaso6.conciliados} conciliaciones DEP√ìSITOS procesadas`);
        
        // // // console.log(`\nüìã INICIANDO PASO 7: Operaciones Libro 3`);
        // // // console.log(`   üìã Extracto procesable: ${extractoProcesable.length} filas disponibles`);
        
        const resultadosPaso7 = this.procesarPaso7(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        // // // console.log(`üìä PASO 7 COMPLETADO: ${resultadosPaso7.conciliados} conciliaciones LIBRO 3 procesadas`);
        
        // // // console.log(`\nüìö INICIANDO PASO 8: Operaciones M√∫ltiples Libros`);
        // // // console.log(`   üìã Extracto procesable: ${extractoProcesable.length} filas disponibles`);
        
        const resultadosPaso8 = this.procesarPaso8(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        // // // console.log(`üìä PASO 8 COMPLETADO: ${resultadosPaso8.conciliados} conciliaciones M√öLTIPLES LIBROS procesadas`);
        
        // // // console.log(`\nüîó INICIANDO PASO 9: Operaciones M√∫ltiples Libros Agrupadas`);
        // // // console.log(`   üìã Extracto procesable: ${extractoProcesable.length} filas disponibles`);
        
        const resultadosPaso9 = this.procesarPaso9(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        // Paso 9 completado
        
        // // // console.log(`\nüìù INICIANDO PASO 10: Operaciones de Cheques`);
        // // // console.log(`   üìã Extracto procesable: ${extractoProcesable.length} filas disponibles`);
        
        const resultadosPaso10 = this.procesarPaso10(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, datosSaldo, estadosSaldo);
        // // // console.log(`üìä PASO 10 COMPLETADO: ${resultadosPaso10.conciliados} conciliaciones CHEQUES procesadas`);
        
        // // // console.log(`\nüí∞ INICIANDO PASO 11: ITF (Impuesto a las Transacciones Financieras)`);
        // // // console.log(`   üìã Extracto procesable: ${extractoProcesable.length} filas disponibles`);
        
        const resultadosPaso11 = this.procesarPaso11(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        // // // console.log(`üìä PASO 11 COMPLETADO: ${resultadosPaso11.conciliados} conciliaciones ITF procesadas`);
        
        // === PASO 12 - AGRUPACI√ìN POR BANCO (DESPU√âS DE ITF) ===
        // // console.log(`\nüîó INICIANDO PASO 12: Agrupaci√≥n por banco (despu√©s de ITF) - CUENTA: ${cuentaConfig.alias}`);
        // // console.log(`   üìã Extracto procesable: ${extractoProcesable.length} filas disponibles`);
        
        // Detectar banco espec√≠fico para l√≥gica especializada
        const esBBVA = cuentaConfig && (cuentaConfig.codigo === '1041201' || cuentaConfig.codigo === '1041202');
        const esSBP = cuentaConfig && (cuentaConfig.alias === 'SBP' || cuentaConfig.alias === 'SBP.USD');
        const esBCP = cuentaConfig && (cuentaConfig.codigo === '1041501' || cuentaConfig.codigo === '1041505' || cuentaConfig.codigo === '1041502');
        const esIBK = cuentaConfig && (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD');
        
        let resultadosPaso12;
        if (esBBVA) {
            resultadosPaso12 = this.procesarPaso12BBVA(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        } else if (esSBP) {
            resultadosPaso12 = this.procesarPaso12SBP(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        } else if (esBCP) {
            resultadosPaso12 = this.procesarPaso12BCP(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        } else if (esIBK) {
            resultadosPaso12 = this.procesarPaso12IBK(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        } else {
            resultadosPaso12 = this.procesarPaso12Santander(filasFiltradasMayor, extractoProcesable, indicesMayor, indicesExtracto, estadosFilas, estadosExtracto, cuentaConfig);
        }
        // Paso 12 completado
        
        // Crear resultados finales con estados asignados
        for (let i = 0; i < filasFiltradasMayor.length; i++) {
            const filaMayor = filasFiltradasMayor[i];
            const estadoInfo = estadosFilas.get(i);
            
            const estadoAsignado = estadoInfo ? estadoInfo.estado : 'Pendiente';
            const refAsignada = estadoInfo ? estadoInfo.ref : '';

            // DEBUG: Para registros P5, mostrar el proceso
            if (estadoInfo && estadoInfo.estado === 'P5 - Conciliada') {
                // // // console.log(`   üîß DEBUG LECTURA: √çndice ${i} ‚Üí estadoInfo.estado="${estadoInfo.estado}", estadoInfo.ref="${estadoInfo.ref}"`);
                // // // console.log(`   üîß DEBUG ASIGNACI√ìN: estadoAsignado="${estadoAsignado}", refAsignada="${refAsignada}"`);
            }

            // Agregar estado y referencia a la fila
            const filaCompleta = [...filaMayor, estadoAsignado, refAsignada];
            resultados.push(filaCompleta);
            
            // LOG PARA PRIMERA FILA (solo para verificaci√≥n)
            if (resultados.length === 1) {
                // // // console.log(`üîç VERIFICACI√ìN PRIMERA FILA (antes del filtrado):`);
                // // // console.log(`   üìã Fila original mayor: ${filaMayor.length} columnas (ser√° filtrada a 14)`);
                // // // console.log(`   üìã Fila completa: ${filaCompleta.length} columnas (se filtrar√° a 16)`);
                // // // console.log(`   üìã ESTADO (pen√∫ltima): "${filaCompleta[filaCompleta.length - 2]}"`);
                // // // console.log(`   üìã #REF (√∫ltima): "${filaCompleta[filaCompleta.length - 1]}"`);
                // // // console.log(`   üìã Nota: Solo las primeras 14 columnas del mayor + ESTADO + #REF ir√°n al Excel final`);
            }
        }

        // USAR SOLO LAS PRIMERAS 14 COLUMNAS EST√ÅNDAR DEL MAYOR
        const columnasEstandar = [
            'DES_TDOP', 'NUMDOC', 'FDOC', 'CUO', 'LIBRO', 'COMPROB', 
            'FECHCON', 'CUENTA', 'DESCRIP', 'CODAUX', 'RAZON SOCI', 
            'GLOSA', 'DEBE', 'HABER'
        ];
        
        // Agregar las nuevas columnas al final (columnas O y P)
        const cabeceraFinal = [...columnasEstandar, 'ESTADO', '#REF'];
        
        // Filtrar solo las primeras 14 columnas de cada fila + las 2 nuevas
        const resultadosFiltrados = resultados.map(fila => {
            const filaBase = fila.slice(0, 14); // Solo primeras 14 columnas
            const estado = fila[fila.length - 2]; // ESTADO (pen√∫ltima)
            const ref = fila[fila.length - 1]; // #REF (√∫ltima)
            return [...filaBase, estado, ref];
        });
        
        const datosFinales = [cabeceraFinal, ...resultadosFiltrados];
        
        // LOG PARA VERIFICACI√ìN COMPLETA
        // // // console.log(`üîç VERIFICACI√ìN DE COLUMNAS (FILTRADAS):`);
        // // // console.log(`   üìã Columnas est√°ndar del mayor: ${columnasEstandar.length} columnas`);
        // // // console.log(`   üìã Headers finales: ${cabeceraFinal.length} columnas (A-N + O,P)`);
        // // // console.log(`   üìã Primera fila filtrada: ${resultadosFiltrados[0] ? resultadosFiltrados[0].length : 0} columnas`);
        // // // console.log(`   üìã Columnas O y P del header: ["${cabeceraFinal.slice(-2).join('", "')}"]`);
        if (resultadosFiltrados[0]) {
            // // // console.log(`   üìã Columnas O y P de datos: ["${resultadosFiltrados[0].slice(-2).join('", "')}"]`);
        }
        
        // MUESTRA DE PRIMERAS 3 FILAS PARA VERIFICACI√ìN
        // // // console.log(`üìã MUESTRA DE DATOS FILTRADOS (primeras 3 filas):`);
        datosFinales.slice(0, 3).forEach((fila, index) => {
            if (index === 0) {
                // // // console.log(`   Header (${fila.length} cols): [${fila.slice(-4).map(col => `"${col}"`).join(', ')}] (√∫ltimas 4)`);
            } else {
                // // console.log(`   Fila ${index} (${fila.length} cols): [${fila.slice(-4).map(col => `"${col}"`).join(', ')}] (√∫ltimas 4)`);
            }
        });
        
        // // console.log(`‚úÖ CONCILIACI√ìN COMPLETADA:`);
        // // console.log(`   üìà Registros procesados: ${resultadosFiltrados.length}`);
        // // console.log(`   üîç Anulaciones esperadas: ${anulacionesEncontradas.length}`);
        // // // console.log(`   üîÑ Paso 3 procesados: ${paso3Procesados} | Conciliados: ${paso3Conciliados}`);
        // // // console.log(`      ‚Ü≥ Etapa 3b (Anulado Saldo): ${paso3Etapa2}`);
        // // // console.log(`      ‚Ü≥ Etapa 3c (Anulaciones en Mayor): ${paso3Etapa3}`);
        // // console.log(`   üìä Archivo final: ${datosFinales.length} filas (incluye header) | ${cabeceraFinal.length} columnas (A-N + O,P)`);
        // // console.log(`   üéØ ESTADO en columna O | #REF en columna P`);
        
        // CONTEO FINAL DE ESTADOS
        const estadosContados = {};
        resultadosFiltrados.forEach(fila => {
            const estado = fila[fila.length - 2]; // Pen√∫ltima columna (ESTADO)
            estadosContados[estado] = (estadosContados[estado] || 0) + 1;
        });
        
        // // // console.log(`üè¶ PASO 4 - RESUMEN: ${resultadosPaso4.candidatos} candidatos, ${resultadosPaso4.conciliados} conciliados total`);
        // // // console.log(`   üÖ∞Ô∏è Etapa 4A (BNA+Extracto): ${resultadosPaso4.etapa4a} conciliaciones`);
        // // // console.log(`   üÖ±Ô∏è Etapa 4B (L04 vs L09): ${resultadosPaso4.etapa4b} conciliaciones`);
        
        // // // console.log(`üìà PASO 5 - RESUMEN: ${resultadosPaso5.candidatos} candidatos, ${resultadosPaso5.grupos} grupos, ${resultadosPaso5.conciliados} conciliados`);
        // // // console.log(`   üìö Agrupaci√≥n por fechas con sumas de HABER`);
        
        // // // console.log(`üè¶ PASO 6 - RESUMEN: ${resultadosPaso6.candidatos} candidatos, ${resultadosPaso6.conciliados} conciliados total`);
        // // // console.log(`   üÖ∞Ô∏è Etapa 6A (NUMDOC): ${resultadosPaso6.etapa6a} conciliaciones`);
        // // // console.log(`   üÖ±Ô∏è Etapa 6B (FDOC+DEBE): ${resultadosPaso6.etapa6b} conciliaciones`);
        
        // // // console.log(`üìã PASO 7 - RESUMEN: ${resultadosPaso7.candidatos} candidatos, ${resultadosPaso7.conciliados} conciliados total`);
        // // // console.log(`   üìã Mapeo √∫nico: FDOC+DEBE vs FECHA+MONTO`);
        
        // // // console.log(`üìö PASO 8 - RESUMEN: ${resultadosPaso8.candidatos} candidatos, ${resultadosPaso8.conciliados} conciliados total`);
        // // // console.log(`   üìã Mapeo √∫nico: FDOC+HABER vs FECHA+|MONTO| (m√∫ltiples libros)`);
        // // // console.log(`   üìà Distribuci√≥n: L03=${resultadosPaso8.libro03}, L09=${resultadosPaso8.libro09}, L14=${resultadosPaso8.libro14}, L15=${resultadosPaso8.libro15}`);
        
        // // // console.log(`üîó PASO 9 - RESUMEN: ${resultadosPaso9.candidatos} candidatos, ${resultadosPaso9.grupos} grupos, ${resultadosPaso9.conciliados} conciliados`);
        // // // console.log(`   üìã Agrupaci√≥n por NUMDOC con suma de TOTAL HABER (m√∫ltiples libros)`);
        // // // console.log(`   üìà Distribuci√≥n: L03=${resultadosPaso9.libro03}, L09=${resultadosPaso9.libro09}, L14=${resultadosPaso9.libro14}, L15=${resultadosPaso9.libro15}`);
        
        // // // console.log(`üìù PASO 10 - RESUMEN: ${resultadosPaso10.candidatos} candidatos mayor, ${resultadosPaso10.candidatosExtracto} candidatos extracto, ${resultadosPaso10.conciliados} conciliados`);
        // // // console.log(`   üìù Mapeo NUMDOC+HABER vs √∫ltimos 8 chars + |MONTO| (cheques LIBRO 02)`);
        
        // // // console.log(`üí∞ PASO 11 - RESUMEN: ${resultadosPaso11.candidatos} candidatos mayor, ${resultadosPaso11.candidatosExtracto} candidatos extracto, ${resultadosPaso11.conciliados} conciliados`);
        // // // console.log(`   üí∞ Agrupaci√≥n ITF por cuenta ${cuentaConfig?.alias || 'GLOBAL'}: Mayor ${resultadosPaso11.totalMayor?.toFixed(2) || 0} vs Extracto ${resultadosPaso11.totalExtracto?.toFixed(2) || 0} (diferencia: ${resultadosPaso11.diferencia?.toFixed(4) || 0})`);
        
        // // // console.log(`üéØ PASO 12 - RESUMEN: ${resultadosPaso12.candidatos} candidatos pendientes, ${resultadosPaso12.totalConciliados} conciliados total`);
        // // console.log(`   üÖ∞Ô∏è Etapa 12A (Tolerancia ¬±5.0): ${resultadosPaso12.etapa12a} conciliaciones`);
        // // console.log(`   üÖ±Ô∏è Etapa 12B (Fechas ¬±2 d√≠as): ${resultadosPaso12.etapa12b} conciliaciones`);
        // // console.log(`   üÖ≤ Etapa 12C (Solo montos): ${resultadosPaso12.etapa12c} conciliaciones`);
        // // console.log(`   üí∞ Estrategia progresiva: A ‚Üí B ‚Üí C (multi-criterio)`);
        
        // // console.log(`üìä DISTRIBUCI√ìN DE ESTADOS:`);
        Object.entries(estadosContados).forEach(([estado, cantidad]) => {
            // // console.log(`   ${estado}: ${cantidad} registros`);
        });
        
        // MOSTRAR MUESTRA DE ANULACIONES PROCESADAS
        const anulacionesProcesadas = resultadosFiltrados.filter(fila => {
            const estado = fila[fila.length - 2];
            const ref = fila[fila.length - 1];
            return estado === 'P3 - Conciliada' || estado.includes('Anulado') || estado.includes('Anula a');
        });
        
        // // // console.log(`\nüîç MUESTRA DE ANULACIONES PROCESADAS (${anulacionesProcesadas.length} total):`);
        // anulacionesProcesadas.slice(0, 10).forEach((fila, idx) => {
        //     const numdoc = fila[1] || ''; // NUMDOC en √≠ndice 1
        //     const debe = fila[12] || ''; // DEBE en √≠ndice 12  
        //     const haber = fila[13] || ''; // HABER en √≠ndice 13
        //     const estado = fila[fila.length - 2]; // ESTADO
        //     const ref = fila[fila.length - 1]; // #REF
        //     // // console.log(`   ${idx + 1}. NUMDOC=${numdoc}, DEBE=${debe}, HABER=${haber} ‚Üí ESTADO="${estado}", REF="${ref}"`);
        // });
        
        // MOSTRAR CASOS ESPEC√çFICOS DEL USUARIO
        const caso43335 = resultadosFiltrados.find(fila => {
            const numdoc = this.normalizarTexto(fila[1] || '');
            return numdoc === '43335';
        });
        
        const casos43676 = resultadosFiltrados.filter(fila => {
            const numdoc = this.normalizarTexto(fila[1] || '');
            return numdoc === '43676';
        });
        
        // if (caso43335) {
        //     // // console.log(`\nüéØ CASO ESPEC√çFICO 00043335 (debe mapear con saldo):`);
        //     const estado = caso43335[caso43335.length - 2];
        //     const ref = caso43335[caso43335.length - 1];
        //     // // console.log(`   Estado: "${estado}", REF: "${ref}"`);
        // }
        
        // if (casos43676.length > 0) {
        //     // // console.log(`\nüéØ CASOS ESPEC√çFICOS 00043676 (${casos43676.length} registros, deben mapear internamente):`);
        //     casos43676.forEach((fila, idx) => {
        //         const debe = fila[12] || '';
        //         const haber = fila[13] || '';
        //         const estado = fila[fila.length - 2];
        //         const ref = fila[fila.length - 1];
        //         // // console.log(`   ${idx + 1}. DEBE=${debe}, HABER=${haber} ‚Üí ESTADO="${estado}", REF="${ref}"`);
        //     });
        // }
        
        // MOSTRAR RESULTADOS DEL PASO 4
        const casosPaso4 = resultadosFiltrados.filter(fila => {
            const estado = fila[fila.length - 2];
            return estado.includes('P4 - Conciliada');
        });
        
        if (casosPaso4.length > 0) {
            // // // console.log(`\nüè¶ CASOS PASO 4 - BNA (${casosPaso4.length} registros conciliados):`);
            casosPaso4.slice(0, 5).forEach((fila, idx) => {
                const fdoc = fila[2] || ''; // FDOC
                const debe = fila[12] || ''; // DEBE 
                const estado = fila[fila.length - 2];
                const ref = fila[fila.length - 1];
                // // // console.log(`   ${idx + 1}. FDOC=${fdoc}, DEBE=${debe} ‚Üí ESTADO="${estado}", REF="${ref}"`);
            });
        }
        
        // MOSTRAR CASOS ESPEC√çFICOS DEL PASO 5
        const casosPaso5 = resultadosFiltrados.filter(fila => {
            const estado = fila[fila.length - 2];
            return estado.includes('P5 - Conciliada');
        });
        
        if (casosPaso5.length > 0) {
            // // // console.log(`\nüìà CASOS PASO 5 - PROT/DEV (${casosPaso5.length} registros conciliados):`);
            casosPaso5.slice(0, 5).forEach((fila, idx) => {
                const fdoc = fila[2] || ''; // FDOC
                const libro = fila[4] || ''; // LIBRO
                const glosa = (fila[11] || '').substring(0, 20); // GLOSA truncada
                const haber = fila[13] || ''; // HABER 
                const estado = fila[fila.length - 2];
                const ref = fila[fila.length - 1];
                
                // DEBUG: Mostrar toda la estructura de la fila para diagnosticar
                // // console.log(`   üîß DEBUG FILA ${idx + 1}: longitud=${fila.length}, estado="${estado}", ref="${ref}"`);
                // // console.log(`   ${idx + 1}. FDOC=${fdoc}, LIBRO=${libro}, GLOSA="${glosa}...", HABER=${haber} ‚Üí REF="${ref}"`);
            });
        }

        // PREPARAR DATOS PARA LAS 3 HOJAS
        
        // HOJA 1: MAYOR (filas filtradas despu√©s del paso 2)
        const datosMayorHoja = [cabeceraFinal, ...resultadosFiltrados];
        
        // HOJA 2: EXTRACTO (din√°mico seg√∫n estructura de cuenta + agregar ESTADO y #REF procesados)
        let datosExtractoHoja;
        if (datosExtracto.length > filaHeader) {
            // Header del extracto (din√°mico seg√∫n cuenta) + columnas ESTADO y #REF
            let headerExtracto;
            if (cuentaConfig && (cuentaConfig.alias === 'SBP' || cuentaConfig.alias === 'SBP.USD')) {
                // Para SBP: asegurar que ESTADO est√© en columna I y #REF en columna J
                const headerOriginal = datosExtracto[filaHeader] || [];
                headerExtracto = [...headerOriginal];
                // Rellenar hasta la columna I (8) si es necesario
                while (headerExtracto.length < 8) {
                    headerExtracto.push('');
                }
                headerExtracto[8] = 'ESTADO'; // Columna I
                headerExtracto[9] = '#REF';   // Columna J
            } else if (cuentaConfig && (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD')) {
                // Para IBK: mapear headers desde B12-J12 a A1-I1, luego ESTADO en J1 y #REF en K1
                const headerOriginal = datosExtracto[filaHeader] || [];
                // Tomar datos desde columna B hasta J (√≠ndices 1-9) del archivo original
                const headersIBK = headerOriginal.slice(1, 10); // B12 hasta J12
                headerExtracto = [...headersIBK, 'ESTADO', '#REF']; // Reorganizar en A1-K1
            } else {
                // Para otros bancos (SANT, BBVA, etc.): extraer header y a√±adir columnas adicionales
                const headerOriginal = datosExtracto[filaHeader] || [];
                
                // Headers por defecto si no se pueden extraer del archivo
                const headersDefault = ['Fecha', 'Fecha valuta', 'Descripci√≥n operaci√≥n', 'Monto', 'Saldo', 'Sucursal - agencia', 'Operaci√≥n - N√∫mero', 'Operaci√≥n - Hora', 'Usuario', 'UTC', 'Referencia2'];
                
                if (headerOriginal.length > 0) {
                    // Si hay header en el archivo, usarlo
                    headerExtracto = [...headerOriginal, 'ESTADO', '#REF'];
                } else {
                    // Si no hay header, usar headers por defecto
                    console.log(`‚ö†Ô∏è No se encontr√≥ header en fila ${filaHeader + 1} para ${cuentaConfig?.alias || 'cuenta desconocida'}, usando headers por defecto`);
                    headerExtracto = [...headersDefault, 'ESTADO', '#REF'];
                }
                
                console.log(`üìã Header procesado para ${cuentaConfig?.alias || 'GEN√âRICO'}:`, headerExtracto);
                console.log(`   üìä Total columnas header: ${headerExtracto.length}`);
                console.log(`   üîß Estructura extracto: filaHeader=${filaHeader}, datosDisponibles=${datosExtracto.length}`);
            }
            
            // Verificar que extractoProcesable existe y es un array
            if (extractoProcesable && Array.isArray(extractoProcesable)) {
                // Datos del extracto (din√°mico seg√∫n cuenta) con estados procesados
                const datosExtractoSinHeader = extractoProcesable.map((item, idx) => {
                    // Verificar si esta fila fue procesada en PASO 4
                    const estadoInfo = estadosExtracto.get(idx);
                    
                    // ‚≠ê VERIFICAR QUE TENGA DATOS REALES ANTES DE ASIGNAR "Pendiente"
                    const filaOriginal = item.fila;
                    let fechaExtracto, importeExtracto;
                    
                    if (cuentaConfig && cuentaConfig.alias === 'IBK') {
                        // Para IBK: estructura original - B=Fecha operaci√≥n, H=Cargo
                        fechaExtracto = filaOriginal[1] || '';     // B=Fecha operaci√≥n
                        importeExtracto = filaOriginal[7] || '0';  // H=Cargo
                    } else {
                        // Para otros bancos: usar estructura est√°ndar
                        fechaExtracto = filaOriginal[0] || '';
                        importeExtracto = filaOriginal[6] || '0';
                    }
                    
                    const tieneFecha = fechaExtracto && fechaExtracto.toString().trim() !== '';
                    const tieneImporte = importeExtracto && importeExtracto.toString().trim() !== '' && importeExtracto.toString() !== '0';
                    const tieneDatosReales = tieneFecha && tieneImporte;
                    
                    // Solo asignar "Pendiente" si tiene datos reales y no tiene estado procesado
                    // Para DET, BN e IBK: siempre asignar "Pendiente" a todos los registros
                    let estado;
                    if (estadoInfo) {
                        estado = estadoInfo.estado;
                    } else if (cuentaConfig && (cuentaConfig.alias === 'DET' || cuentaConfig.alias === 'BN' || cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD')) {
                        estado = 'Pendiente'; // Para DET, BN e IBK: siempre Pendiente
                    } else {
                        estado = tieneDatosReales ? 'Pendiente' : ''; // Para otros bancos: solo si tiene datos reales
                    }
                    const ref = estadoInfo ? estadoInfo.ref : '';
                    
                    // ‚≠ê CREAR NUEVA FILA SEG√öN EL BANCO
                    let filaNueva;
                    
                    if (cuentaConfig && (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD')) {
                        // Para IBK: reorganizar datos desde B12-J12 a A1-I1, luego ESTADO en J1 y #REF en K1
                        // Tomar datos desde columna B hasta J (√≠ndices 1-9) del archivo original
                        const datosIBK = filaOriginal.slice(1, 10); // B12 hasta J12
                        filaNueva = [...datosIBK, estado, ref]; // Reorganizar en A1-K1
                    } else if (cuentaConfig && cuentaConfig.alias === 'DET') {
                        // Para DET: usar estructura espec√≠fica con 7 columnas originales + columna H + ESTADO + #REF
                        // Nro, Fecha, Trans, Documento, Oficina, Cargo, Abono, [H], ESTADO, #REF
                        filaNueva = [...filaOriginal]; // Copia todas las columnas originales
                        // Asegurar que las columnas ESTADO y #REF est√©n en las posiciones correctas
                        while (filaNueva.length < 10) {
                            filaNueva.push(''); // Rellenar hasta tener 10 columnas
                        }
                        filaNueva[8] = estado; // Columna I - ESTADO
                        filaNueva[9] = ref;    // Columna J - #REF
                    } else if (cuentaConfig && cuentaConfig.alias === 'BN') {
                        // Para BN: estructura pendiente de definir
                        filaNueva = [...filaOriginal]; // Copia todas las columnas originales
                        // Agregar ESTADO y #REF al final hasta tener la estructura espec√≠fica
                        filaNueva.push(estado); // ESTADO
                        filaNueva.push(ref);    // #REF
                    } else {
                        // Para SANT/SBP y otros bancos: preservar columnas originales
                        filaNueva = [...filaOriginal]; // Copia todas las columnas originales
                        
                    if (cuentaConfig && (cuentaConfig.alias === 'SBP' || cuentaConfig.alias === 'SBP.USD')) {
                        // SBP tiene 8 columnas (A-H), rellenar hasta la columna I (8) y J (9)
                        while (filaNueva.length < 8) {
                            filaNueva.push(''); // Rellenar columnas faltantes si es necesario
                        }
                        filaNueva[8] = estado; // ESTADO en columna I (√≠ndice 8)
                        filaNueva[9] = ref;    // #REF en columna J (√≠ndice 9)
                    } else {
                        // SANT y otros bancos: a√±adir ESTADO y #REF al final
                        filaNueva.push(estado); // A√±adir ESTADO como nueva columna
                        filaNueva.push(ref);    // A√±adir #REF como nueva columna
                        }
                    }
                    
                    return filaNueva;
                });
                
                datosExtractoHoja = [headerExtracto, ...datosExtractoSinHeader];
                console.log(`‚úÖ datosExtractoHoja generada: ${datosExtractoHoja.length} filas (1 header + ${datosExtractoSinHeader.length} datos)`);
            } else {
                console.error('‚ö†Ô∏è extractoProcesable no est√° disponible, usando datos b√°sicos del extracto');
                // Fallback: usar datos b√°sicos del extracto (din√°mico seg√∫n cuenta)
                let datosExtractoSinHeader;
                if (cuentaConfig && cuentaConfig.alias === 'IBK') {
                    // Para IBK: reorganizar datos desde B12-J12 a A1-I1 en fallback tambi√©n
                    datosExtractoSinHeader = datosExtracto.slice(filaDataInicio).map(fila => {
                        const datosIBK = fila.slice(1, 10); // B hasta J
                        return [...datosIBK, 'Pendiente', '']; // Reorganizar + ESTADO + #REF
                    });
                } else if (cuentaConfig && cuentaConfig.alias === 'DET') {
                    // Para DET: asegurar estructura correcta con ESTADO y #REF en posiciones espec√≠ficas
                    datosExtractoSinHeader = datosExtracto.slice(filaDataInicio).map(fila => {
                        const filaNueva = [...fila];
                        // Asegurar que hay 10 columnas (A-J) para DET
                        while (filaNueva.length < 10) {
                            filaNueva.push('');
                        }
                        filaNueva[8] = 'Pendiente'; // Columna I - ESTADO
                        filaNueva[9] = '';          // Columna J - #REF
                        return filaNueva;
                    });
                } else if (cuentaConfig && cuentaConfig.alias === 'BN') {
                    // Para BN: estructura pendiente de definir
                    datosExtractoSinHeader = datosExtracto.slice(filaDataInicio).map(fila => [
                        ...fila, 
                        'Pendiente', // ESTADO al final
                        '' // #REF al final
                    ]);
                } else {
                    datosExtractoSinHeader = datosExtracto.slice(filaDataInicio).map(fila => [
                    ...fila, 
                    'Pendiente', // ESTADO por defecto
                    '' // #REF vac√≠o
                ]);
                }
                datosExtractoHoja = [headerExtracto, ...datosExtractoSinHeader];
                console.log(`‚úÖ datosExtractoHoja fallback generada: ${datosExtractoHoja.length} filas`);
            }
        } else {
            // Fallback: generar header por defecto seg√∫n el banco
            let headerFallback;
            if (cuentaConfig && (cuentaConfig.alias === 'SBP' || cuentaConfig.alias === 'SBP.USD')) {
                headerFallback = ['Fecha', 'Movimiento', 'Importe', 'Referencia', 'CDR', 'M√≥dulo', 'Transac.', 'Relaci√≥n', 'ESTADO', '#REF'];
            } else if (cuentaConfig && (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD')) {
                headerFallback = ['Fecha', 'Concepto', 'N√∫mero', 'Descripci√≥n', 'Monto', 'C√≥d. Aux', 'Vencimiento', 'Relac.', 'Agencia', 'ESTADO', '#REF'];
            } else if (cuentaConfig && (cuentaConfig.alias === 'SANT' || cuentaConfig.alias === 'SANT.USD')) {
                headerFallback = ['Fecha', 'Importe', 'Descripci√≥n', 'Referencia', 'Saldo', 'Sucursal', 'N√∫mero', 'Hora', 'Usuario', 'ESTADO', '#REF'];
            } else if (cuentaConfig && (cuentaConfig.alias === 'BBVA' || cuentaConfig.alias === 'BBVA.USD')) {
                headerFallback = ['F. Operaci√≥n', 'Concepto', 'Importe', 'N√∫mero', 'Descripci√≥n', 'Saldo', 'Sucursal', 'Hora', 'Referencia', 'ESTADO', '#REF'];
            } else {
                // BCP y otros bancos est√°ndar
                headerFallback = ['Fecha', 'Fecha valuta', 'Descripci√≥n operaci√≥n', 'Monto', 'Saldo', 'Sucursal - agencia', 'Operaci√≥n - N√∫mero', 'Operaci√≥n - Hora', 'Usuario', 'UTC', 'Referencia2', 'ESTADO', '#REF'];
            }
            
            console.log(`‚ö†Ô∏è No hay datos de extracto para ${cuentaConfig?.alias || 'cuenta desconocida'}, usando header fallback:`, headerFallback);
            datosExtractoHoja = [headerFallback];
        }
        
        // HOJA 3: SALDO (usar datos reales si est√°n disponibles + agregar ESTADO y #REF en columna P)
        let datosSaldoHoja;
        if (datosSaldo && datosSaldo.length > 0) {
            // Header del saldo con padding hasta columna P (√≠ndice 15)
            const headerSaldoOriginal = datosSaldo[0] || [];
            const headerSaldoPadded = [...headerSaldoOriginal];
            
            // Asegurar que hay exactamente 15 columnas antes de ESTADO (columna P)
            while (headerSaldoPadded.length < 15) {
                headerSaldoPadded.push(''); // Rellenar con columnas vac√≠as
            }
            
            const headerSaldo = [...headerSaldoPadded.slice(0, 15), 'ESTADO', '#REF'];
            
            // Datos del saldo con padding hasta columna P
            const datosSaldoSinHeader = datosSaldo.slice(1).map(fila => {
                const filaPadded = [...fila];
                
                // Asegurar que hay exactamente 15 columnas antes de ESTADO
                while (filaPadded.length < 15) {
                    filaPadded.push(''); // Rellenar con datos vac√≠os
                }
                
                // Solo asignar "Pendiente" si la fila tiene datos reales (no est√° vac√≠a)
                const tieneDatos = filaPadded.some(celda => celda && celda.toString().trim() !== '');
                const estado = tieneDatos ? 'Pendiente' : '';
                
                return [...filaPadded.slice(0, 15), estado, ''];
            });
            
            datosSaldoHoja = [headerSaldo, ...datosSaldoSinHeader];
        } else {
            // Datos simulados si no hay archivo de saldo (15 columnas + ESTADO + #REF)
            const headerSimulado = [
                'CUENTA', 'DESCRIP', 'Banco', 'Concepto Reporte Final', 'FDOC', 
                'GLOSA 1', 'NUMDOC', 'DEBE', 'HABER', '', '', '', '', '', '', 
                'ESTADO', '#REF'
            ];
            datosSaldoHoja = [headerSimulado];
        }
        
        // --- APLICAR ESTADOS FINALES AL SALDO ---
        if (datosSaldo && datosSaldo.length > 1 && estadosSaldo.size > 0) {
            // // console.log(`üìä Aplicando ${estadosSaldo.size} estados finales al saldo...`);
            this.aplicarEstadosASaldo(datosSaldoHoja, estadosSaldo);
            // // console.log(`‚úÖ Estados aplicados exitosamente a datosSaldoHoja`);
        }

        // // console.log(`üìä DATOS PREPARADOS PARA 3 HOJAS:`);
        // // console.log(`   üìã Mayor: ${datosMayorHoja.length} filas (incluye header)`);
        // // console.log(`   üìã Extracto: ${datosExtractoHoja.length} filas (incluye header)`);
        // // console.log(`   üìã Saldo: ${datosSaldoHoja.length} filas ${datosSaldo ? '(datos reales)' : '(solo header simulado)'}`);

        console.log(`‚úÖ RESULTADO PROCESARCONCILIACION:`);
        console.log(`   üìä datosMayorHoja: ${datosMayorHoja.length} filas`);
        console.log(`   üìä datosExtractoHoja: ${datosExtractoHoja.length} filas (con headers)`);
        console.log(`   üìã Header extracto:`, datosExtractoHoja[0]);
        console.log(`   üìä datosSaldoHoja: ${datosSaldoHoja.length} filas`);

        return {
            datosMayor: datosMayorHoja,
            datosExtracto: datosExtractoHoja, // ‚úÖ INCLUYE HEADERS
            datosSaldo: datosSaldoHoja,
            totalProcesados: filasFiltradasMayor.length
        };
            },

            procesarPaso4(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 4 - OPERACIONES ESPEC√çFICAS POR BANCO:
                
                BCP (GENERAL) - OPERACIONES BNA (BANCO DE LA NACI√ìN):
                ETAPA 4A - MAPEO CON EXTRACTO BANCARIO:
                - DES_TDOP = "Bna", LIBRO = "04"
                - MAPEO: FDOC + DEBE vs FECHA + MONTO
                
                BBVA (CONTINENTAL) - OPERACIONES ABONO/CARGO CART:
                
                ETAPA 1 - MAPEO CON EXTRACTO:
                Mayor: 
                1. Filtrar por DES_TDOP = "Bna"
                2. Agrupar por FDOC
                3. FDOC + DEBE
                
                Extracto:
                1. Identificar Concepto que INICIEN con "ABONO CART" y "CARGO CART"
                2. Agrupar por F. Operaci√≥n  
                3. F. Operaci√≥n + |Importe| (suma con signo, luego valor absoluto)
                
                ETAPA 2 - MAPEO INTERNO MAYOR:
                Candidatos: DES_TDOP = "Bna" + DEBE > 0 + pendientes
                Destinos: CUALQUIER registro pendiente (sin filtro DES_TDOP)
                Criterio: mismo FDOC + DEBE candidato = HABER destino
                
                ESTADOS RESULTANTES:
                - "P4 - Conciliada" para registros mapeados
                */
                
                // ‚≠ê VERIFICAR SI ES BBVA, SBP O IBK PARA USAR L√ìGICA ESPEC√çFICA
                const esBBVA = cuentaConfig && (cuentaConfig.codigo === '1041201' || cuentaConfig.codigo === '1041202');
                const esSBP = cuentaConfig && (cuentaConfig.alias === 'SBP' || cuentaConfig.alias === 'SBP.USD');
                const esIBK = cuentaConfig && (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD');
                const esBCPUSD = cuentaConfig && cuentaConfig.codigo === '1041502';
                
                if (esBBVA) {
                    return this.procesarPaso4BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (esSBP) {
                    return this.procesarPaso4SBP(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (esIBK) {
                    return this.procesarPaso4IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else {
                    // L√≥gica est√°ndar BCP (incluyendo BCP.USD)
                    if (esBCPUSD) {
                        console.log(`üè¶ DIAGN√ìSTICO BCP.USD - PASO 4:`);
                        console.log(`   Total filas Mayor: ${filasFiltradasMayor.length}`);
                        console.log(`   Cuenta configurada: ${cuentaConfig.codigo} (${cuentaConfig.alias})`);
                    }
                }
                // // // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                // ETAPA 4A - Contadores
                let candidatosBNA = 0;
                let conciliadosExtracto = 0;
                let filasPendientes = 0;
                let filasConBNA = 0;
                let filasConLibro04 = 0;
                let filasConDebe = 0;
                
                // ETAPA 4B - Contadores  
                let candidatosLibro04 = 0;
                let candidatosLibro09 = 0;
                let conciliadosInternos = 0;
                
                // =======================================================
                // ETAPA 4A: MAPEO CON EXTRACTO BANCARIO (BNA + LIBRO 04)
                // =======================================================
                // // // console.log(`\nüÖ∞Ô∏è ETAPA 4A: Mapeo BNA con Extracto Bancario`);
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    const filaMayor = filasFiltradasMayor[i];
                    
                    // Solo procesar si no tiene estado asignado (Pendiente)
                    if (estadosFilas.has(i)) continue;
                    filasPendientes++;
                    
                    const desTdop = filaMayor[idxM.desTdop] || '';
                    const libro = filaMayor[idxM.libro] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Debug: Mostrar las primeras 10 filas para entender el formato
                    if (i < 10) {
                        // // // console.log(`üîç Fila ${i}: DES_TDOP="${desTdop}", LIBRO="${libro}", DEBE=${debe}`);
                    }
                    
                    // Diagn√≥stico espec√≠fico para BCP.USD
                    if (esBCPUSD && i < 20) {
                        console.log(`üîç BCP.USD Fila ${i}: DES_TDOP="${desTdop}", LIBRO="${libro}", DEBE=${debe}, FDOC="${fdoc}"`);
                    }
                    
                    // Verificar criterios del PASO 4
                    const esBNA = String(desTdop || '').trim().toUpperCase() === 'BNA';
                    const esLibro4 = String(libro || '').trim() === '04';
                    
                    // Contar cu√°ntas filas cumplen cada criterio
                    if (esBNA) filasConBNA++;
                    if (esLibro4) filasConLibro04++;
                    if (debe > 0) filasConDebe++;
                    
                    // Diagn√≥stico adicional para BCP.USD
                    if (esBCPUSD && (esBNA || esLibro4 || debe > 0)) {
                        console.log(`üéØ BCP.USD Candidato ${i}: BNA=${esBNA}, LIBRO04=${esLibro4}, DEBE>0=${debe > 0}`);
                    }
                    
                    if (esBNA && esLibro4 && debe > 0) {
                        candidatosBNA++;
                        
                        // Normalizar fecha del Mayor para logging
                        const fdocNormalizado = this.normalizarFecha(fdoc);
                        
                        // // // console.log(`üîç Candidato BNA ${candidatosBNA}:`);
                        // // // console.log(`   FDOC raw: "${fdoc}" ‚Üí normalizado: "${fdocNormalizado}"`);
                        // // // console.log(`   DEBE: ${debe}, LIBRO: "${libro}", COMPROB: "${comprob}"`);
                        // // // console.log(`   DES_TDOP: "${desTdop}", esLibro4: ${esLibro4}`);
                        
                        // Buscar match en extracto
                        const matchExtracto = this.buscarMatchExtracto(fdoc, debe, extractoProcesable, idxE, estadosExtracto);
                        
                        if (matchExtracto.encontrado) {
                            // Asignar estados a ambos registros
                            const refMayor = matchExtracto.operacionNumero; // Columna G del extracto
                            const refExtracto = `${libro}-${comprob}`; // LIBRO-COMPROB del mayor
                            
                            estadosFilas.set(i, {
                                estado: 'P4 - Conciliada',
                                ref: refMayor
                            });
                            
                            estadosExtracto.set(matchExtracto.indice, {
                                estado: 'P4 - Conciliada',
                                ref: refExtracto
                            });
                            
                            conciliadosExtracto++;
                            
                            // // // console.log(`‚úÖ ETAPA 4A - CONCILIACI√ìN BNA EXITOSA:`);
                            // // // console.log(`   Mayor: FDOC="${fdoc}"‚Üí"${fdocNormalizado}", DEBE=${debe} ‚Üí REF="${refMayor}"`);
                            // // // console.log(`   Extracto: FECHA="${matchExtracto.fecha}", MONTO=${matchExtracto.monto} ‚Üí REF="${refExtracto}"`);
                        } else {
                            if (candidatosBNA <= 5) {
                                // // // console.log(`‚ùå No se encontr√≥ match para candidato BNA ${candidatosBNA}`);
                            }
                        }
                    }
                }
                
                // =======================================================
                // ETAPA 4B: MAPEO INTERNO MAYOR (LIBRO 04 vs LIBRO 09)
                // =======================================================
                // // // console.log(`\nüÖ±Ô∏è ETAPA 4B: Mapeo interno Mayor (LIBRO 04 vs 09)`);
                
                // Buscar filas pendientes con LIBRO="04"
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Solo filas con LIBRO="04" y DEBE > 0
                    if (String(libro || '').trim() === '04' && debe > 0) {
                        candidatosLibro04++;
                        
                        if (candidatosLibro04 <= 5) {
                            // // // console.log(`üîç Candidato LIBRO 04 (${candidatosLibro04}): DEBE=${debe}, COMPROB="${comprob}"`);
                        }
                        
                        // Buscar coincidencia en LIBRO="09" con HABER similar
                        for (let j = 0; j < filasFiltradasMayor.length; j++) {
                            if (i === j || estadosFilas.has(j)) continue;
                            
                            const otraFila = filasFiltradasMayor[j];
                            const otroLibro = otraFila[idxM.libro] || '';
                            const otroHaber = this.normalizarMonto(otraFila[idxM.haber] || '0');
                            const otroComprob = otraFila[idxM.comprob] || '';
                            
                            if (String(otroLibro || '').trim() === '09' && otroHaber > 0) {
                                candidatosLibro09++;
                                
                                                // Verificar coincidencia de montos (exacto)
                const diferencia = Math.abs(debe - otroHaber);
                const coincide = diferencia === 0;
                                
                                if (candidatosLibro04 <= 5 && candidatosLibro09 <= 10) {
                                    // // // console.log(`   üîÑ vs LIBRO 09: HABER=${otroHaber}, diff=${diferencia.toFixed(4)} ${coincide ? '‚úÖ' : '‚ùå'}`);
                                }
                                
                                if (coincide) {
                                    // Asignar estados a ambas filas
                                    estadosFilas.set(i, {
                                        estado: 'P4 - Conciliada',
                                        ref: `09-${otroComprob}`
                                    });
                                    
                                    estadosFilas.set(j, {
                                        estado: 'P4 - Conciliada', 
                                        ref: `04-${comprob}`
                                    });
                                    
                                    conciliadosInternos++;
                                    
                                    // // // console.log(`‚úÖ ETAPA 4B - CONCILIACI√ìN INTERNA EXITOSA:`);
                                    // // // console.log(`   LIBRO 04 (fila ${i}): DEBE=${debe} ‚Üí REF="09-${otroComprob}"`);
                                    // // // console.log(`   LIBRO 09 (fila ${j}): HABER=${otroHaber} ‚Üí REF="04-${comprob}"`);
                                    
                                    // Salir del bucle interno ya que encontramos el match
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // Diagn√≥stico espec√≠fico para BCP.USD
                if (esBCPUSD) {
                    console.log(`üìä BCP.USD PASO 4 - RESUMEN COMPLETO:`);
                    console.log(`   üìã Filas pendientes iniciales: ${filasPendientes}`);
                    console.log(`\nüÖ∞Ô∏è ETAPA 4A (BNA + Extracto):`);
                    console.log(`   üè¶ Filas con DES_TDOP="Bna": ${filasConBNA}`);
                    console.log(`   üìö Filas con LIBRO="04": ${filasConLibro04}`);
                    console.log(`   üí∞ Filas con DEBE > 0: ${filasConDebe}`);
                    console.log(`   ‚úÖ Candidatos BNA (todos criterios): ${candidatosBNA}`);
                    console.log(`   üéØ Conciliaciones con extracto: ${conciliadosExtracto}`);
                    console.log(`\nüÖ±Ô∏è ETAPA 4B (Libro 04 vs 09):`);
                    console.log(`   üìö Candidatos LIBRO 04: ${candidatosLibro04}`);
                    console.log(`   üìó Candidatos LIBRO 09 revisados: ${candidatosLibro09}`);
                    console.log(`   üéØ Conciliaciones internas: ${conciliadosInternos}`);
                    console.log(`\nüèÅ PASO 4 TOTAL: ${conciliadosExtracto + conciliadosInternos} conciliaciones`);
                }
                
                // // // console.log(`üìä PASO 4 - RESUMEN COMPLETO:`);
                // // // console.log(`   üìã Filas pendientes iniciales: ${filasPendientes}`);
                // // // console.log(`\nüÖ∞Ô∏è ETAPA 4A (BNA + Extracto):`);
                // // // console.log(`   üè¶ Filas con DES_TDOP="Bna": ${filasConBNA}`);
                // // // console.log(`   üìö Filas con LIBRO="04": ${filasConLibro04}`);
                // // // console.log(`   üí∞ Filas con DEBE > 0: ${filasConDebe}`);
                // // // console.log(`   ‚úÖ Candidatos BNA (todos criterios): ${candidatosBNA}`);
                // // // console.log(`   üéØ Conciliaciones con extracto: ${conciliadosExtracto}`);
                // // // console.log(`\nüÖ±Ô∏è ETAPA 4B (Libro 04 vs 09):`);
                // // // console.log(`   üìö Candidatos LIBRO 04: ${candidatosLibro04}`);
                // // // console.log(`   üìó Candidatos LIBRO 09 revisados: ${candidatosLibro09}`);
                // // // console.log(`   üéØ Conciliaciones internas: ${conciliadosInternos}`);
                // // // console.log(`\nüèÅ PASO 4 TOTAL: ${conciliadosExtracto + conciliadosInternos} conciliaciones`);
                
                return {
                    candidatos: candidatosBNA + candidatosLibro04,
                    conciliados: conciliadosExtracto + conciliadosInternos,
                    etapa4a: conciliadosExtracto,
                    etapa4b: conciliadosInternos
                };
            },

            procesarPaso4BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 4 BBVA - DOS ETAPAS (ABONO/CARGO CART):
                
                ETAPA 1 - MAPEO CON EXTRACTO:
                Mayor: 
                1. Filtrar por DES_TDOP = "Bna"
                2. Agrupar por FDOC
                3. FDOC + DEBE
                
                Extracto BBVA:
                1. Identificar en "Concepto" que INICIEN con "ABONO CART" y "CARGO CART"
                2. Agrupar por "F. Operaci√≥n"  
                3. "F. Operaci√≥n" + |Importe| (suma con signo, luego valor absoluto)
                
                ETAPA 2 - MAPEO INTERNO MAYOR (registros pendientes):
                1. Filtrar candidatos: DES_TDOP = "Bna" + DEBE > 0 + registros pendientes
                2. Buscar destinos: CUALQUIER registro pendiente (sin filtro DES_TDOP)
                3. Mapeo exacto: mismo FDOC + DEBE candidato = HABER destino
                
                HEADERS BBVA: F. Operaci√≥n, F. Valor, C√≥digo, N¬∫. Doc., Concepto, Importe, Oficina, ESTADO, #REF
                
                ESTADOS RESULTANTES:
                - "P4 - Conciliada" para registros mapeados en ambas etapas
                */
                
                // // console.log(`\nüè¶ *** BBVA PASO 4 INICIADO *** - Agrupaci√≥n por FDOC + mapeo ABONO/CARGO CART`);
                // // console.log(`üìã Total registros Mayor disponibles: ${filasFiltradasMayor.length}`);
                // // console.log(`üìã Total registros Extracto disponibles: ${extractoProcesable.length}`);
                // // console.log(`üìã Estados ya procesados Mayor: ${estadosFilas.size}`);
                // // console.log(`üìã Estados ya procesados Extracto: ${estadosExtracto.size}`);
                
                let candidatosMayor = 0;
                let candidatosExtracto = 0; 
                let conciliados = 0;
                let numeroGrupo = 1;
                
                // === 1. FILTRAR MAYOR POR DES_TDOP="Bna" Y AGRUPAR POR FDOC ===
                const gruposPorFechaMayor = new Map();
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const desTdop = filaMayor[idxM.desTdop] || '';  // DES_TDOP
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    
                    // FILTRO ESPEC√çFICO BBVA: DES_TDOP = "Bna" + DEBE > 0
                    if (String(desTdop || '').trim().toLowerCase() === 'bna' && debe > 0) {
                        candidatosMayor++;
                        
                        const fechaNormalizada = this.normalizarFecha(fdoc);
                        
                        if (!gruposPorFechaMayor.has(fechaNormalizada)) {
                            gruposPorFechaMayor.set(fechaNormalizada, {
                                fechaOriginal: fdoc,
                                totalDebe: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposPorFechaMayor.get(fechaNormalizada);
                        grupo.totalDebe += debe;
                        grupo.filas.push(i);
                        
                        if (candidatosMayor <= 10) {
                            // // console.log(`üìù BBVA Mayor Candidato ${candidatosMayor}: DES_TDOP="${desTdop}", FDOC="${fdoc}", DEBE=${debe}`);
                        }
                    }
                }
                
                // // console.log(`üìä BBVA PASO 4 - AGRUPACI√ìN MAYOR: ${gruposPorFechaMayor.size} grupos por FDOC formados`);
                // // console.log(`üìä Candidatos Mayor con DES_TDOP="Bna" y DEBE > 0: ${candidatosMayor}`);
                
                // === DETALLE DE GRUPOS MAYOR ===
                // // console.log(`\nüîç === DETALLE GRUPOS MAYOR (DES_TDOP="Bna") ===`);
                let grupoNumero = 1;
                for (const [fechaNormalizada, grupo] of gruposPorFechaMayor) {
                    // // console.log(`üìÖ GRUPO MAYOR ${grupoNumero}: FDOC="${grupo.fechaOriginal}" ‚Üí Normalizada="${fechaNormalizada}"`);
                    // // console.log(`   üí∞ Total DEBE: ${grupo.totalDebe.toFixed(2)}`);
                    // // console.log(`   üìã Registros: ${grupo.filas.length}`);
                    
                    // Mostrar primeros 3 registros del grupo
                    grupo.filas.slice(0, 3).forEach((filaIdx, idx) => {
                        const fila = filasFiltradasMayor[filaIdx];
                        const debe = this.normalizarMonto(fila[idxM.debe] || '0');
                        // // console.log(`     ${idx + 1}. DEBE=${debe.toFixed(2)}, NUMDOC="${fila[idxM.numdoc] || ''}", COMPROB="${fila[idxM.comprob] || ''}"`);
                    });
                    
                    if (grupo.filas.length > 3) {
                        // // console.log(`     ... y ${grupo.filas.length - 3} registros m√°s`);
                    }
                    grupoNumero++;
                }
                
                // === 2. IDENTIFICAR EXTRACTO BBVA ABONO/CARGO CART ===  
                const registrosAbonoCargoCart = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // Headers BBVA: F. Operaci√≥n, F. Valor, C√≥digo, N¬∫. Doc., Concepto, Importe, Oficina
                    const fOperacion = filaExtracto[0] || '';     // F. Operaci√≥n
                    const concepto = filaExtracto[4] || '';       // Concepto  
                    const importe = filaExtracto[5] || '0';       // Importe
                    
                    // Verificar si el concepto INICIA con "ABONO CART" o "CARGO CART"
                    const conceptoUpper = concepto.toString().toUpperCase();
                    const esAbonoCart = conceptoUpper.startsWith('ABONO CART');
                    const esCargoCart = conceptoUpper.startsWith('CARGO CART');
                    
                    if (esAbonoCart || esCargoCart) {
                        candidatosExtracto++;
                        
                        registrosAbonoCargoCart.push({
                            indice: i,
                            fOperacion: fOperacion,
                            concepto: concepto,
                            importe: this.normalizarMonto(importe), // MANTENER SIGNO (+ o -)
                            tipo: esAbonoCart ? 'ABONO CART' : 'CARGO CART'
                        });
                        
                        if (candidatosExtracto <= 10) {
                            // // console.log(`üìù BBVA Extracto Candidato ${candidatosExtracto}: F.Op="${fOperacion}", Concepto="${concepto.substring(0, 40)}...", Importe=${this.normalizarMonto(importe).toFixed(2)} (${this.normalizarMonto(importe) >= 0 ? '+' : '-'}), Tipo=${esAbonoCart ? 'ABONO' : 'CARGO'}`);
                        }
                    }
                }
                
                // // console.log(`üìä BBVA PASO 4 - EXTRACTO: ${candidatosExtracto} registros ABONO/CARGO CART encontrados`);
                
                // === 3. AGRUPAR EXTRACTO POR F. OPERACI√ìN ===
                const gruposPorFOperacion = new Map();
                
                registrosAbonoCargoCart.forEach(registro => {
                    const fOperacionNormalizada = this.normalizarFecha(registro.fOperacion); // Normalizar como fecha
                    
                    if (!gruposPorFOperacion.has(fOperacionNormalizada)) {
                        gruposPorFOperacion.set(fOperacionNormalizada, {
                            fOperacionOriginal: registro.fOperacion,
                            totalImporte: 0,
                            registros: []
                        });
                    }
                    
                    const grupo = gruposPorFOperacion.get(fOperacionNormalizada);
                    grupo.totalImporte += registro.importe; // Sumar con signo (+ o -)
                    grupo.registros.push(registro);
                });
                
                // // console.log(`üìä BBVA PASO 4 - AGRUPACI√ìN EXTRACTO: ${gruposPorFOperacion.size} grupos por F. Operaci√≥n formados`);
                
                // === DETALLE DE GRUPOS EXTRACTO BBVA ===
                // // console.log(`\nüîç === DETALLE GRUPOS EXTRACTO BBVA (ABONO/CARGO CART) ===`);
                let grupoExtractoNum = 1;
                for (const [fechaNormalizada, grupo] of gruposPorFOperacion) {
                    // // console.log(`üìÖ GRUPO EXTRACTO ${grupoExtractoNum}: F.Operaci√≥n="${grupo.fOperacionOriginal}" ‚Üí Normalizada="${fechaNormalizada}"`);
                    // // console.log(`   üí∞ Total antes de |valor|: ${grupo.totalImporte.toFixed(2)}`);
                    // // console.log(`   üí∞ Total |Importe|: ${Math.abs(grupo.totalImporte).toFixed(2)}`);
                    // // console.log(`   üìã Registros: ${grupo.registros.length}`);
                    
                    // Mostrar primeros 3 registros del grupo
                    grupo.registros.slice(0, 3).forEach((registro, idx) => {
                        const signoStr = registro.importe >= 0 ? '+' : '';
                        // // console.log(`     ${idx + 1}. ${registro.tipo}: Importe=${signoStr}${registro.importe.toFixed(2)}, Concepto="${registro.concepto.substring(0, 30)}..."`);
                    });
                    
                    if (grupo.registros.length > 3) {
                        // // console.log(`     ... y ${grupo.registros.length - 3} registros m√°s`);
                    }
                    grupoExtractoNum++;
                }
                
                // === 4. COMPARACI√ìN DE GRUPOS: MAYOR vs EXTRACTO ===
                // // console.log(`\nüîó === COMPARACI√ìN GRUPOS: MAYOR (FDOC+DEBE) vs EXTRACTO (F.OP+|IMPORTE|) ===`);
                // // console.log(`‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
                // // console.log(`‚îÇFECHA NORM  ‚îÇ MAYOR FDOC  ‚îÇ MAYOR DEBE  ‚îÇ BBVA F.OP  ‚îÇ BBVA IMPORTE‚îÇ   STATUS    ‚îÇ MATCH   ‚îÇ`);
                // // console.log(`‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§`);
                
                // Obtener todas las fechas √∫nicas (de ambos lados)
                const todasFechas = new Set([
                    ...Array.from(gruposPorFechaMayor.keys()),
                    ...Array.from(gruposPorFOperacion.keys())
                ]);
                
                for (const fecha of todasFechas) {
                    const grupoMayor = gruposPorFechaMayor.get(fecha);
                    const grupoExtracto = gruposPorFOperacion.get(fecha);
                    
                    const tieneGrupoMayor = grupoMayor !== undefined;
                    const tieneGrupoExtracto = grupoExtracto !== undefined;
                    
                    let status = '';
                    let grupoId = '';
                    
                    if (tieneGrupoMayor && tieneGrupoExtracto) {
                        const totalExtractoAbsoluto = Math.abs(grupoExtracto.totalImporte);
                        const diff = Math.abs(grupoMayor.totalDebe - totalExtractoAbsoluto);
                        if (diff < 0.01) {
                            status = 'MATCH ‚úÖ';
                            grupoId = `${numeroGrupo}`;
                            
                            // === LOG DETALLADO DEL MATCH ===
                            // // console.log(`\nüéØ MATCH ENCONTRADO - GRUPO ${numeroGrupo}:`);
                            // // console.log(`   üìÖ Fecha normalizada: "${fecha}"`);
                            // // console.log(`   üèõÔ∏è  MAYOR: FDOC="${grupoMayor.fechaOriginal}" ‚Üí Total DEBE=${grupoMayor.totalDebe.toFixed(2)} (${grupoMayor.filas.length} registros)`);
                            // // console.log(`   üè¶ EXTRACTO: F.Op="${grupoExtracto.fOperacionOriginal}" ‚Üí Total antes |valor|=${grupoExtracto.totalImporte.toFixed(2)}, Total |Importe|=${totalExtractoAbsoluto.toFixed(2)} (${grupoExtracto.registros.length} registros)`);
                            // // console.log(`   ‚úÖ Diferencia: ${diff.toFixed(6)} (CONCILIADO)`);
                            
                            // === CONCILIAR REGISTROS ===
                            const refGrupo = `BBVA-GRUPO-${numeroGrupo}`;
                            
                            // Marcar todas las filas del grupo Mayor como conciliadas
                            for (const indiceMayor of grupoMayor.filas) {
                                estadosFilas.set(indiceMayor, {
                                    estado: 'P4 - Conciliada',
                                    ref: refGrupo
                                });
                            }
                            
                            // Marcar todas las filas del grupo Extracto como conciliadas
                            for (const registroExtracto of grupoExtracto.registros) {
                                estadosExtracto.set(registroExtracto.indice, {
                                    estado: 'P4 - Conciliada',
                                    ref: refGrupo
                                });
                            }
                            
                            conciliados++;
                            numeroGrupo++;
                        } else {
                            status = `DIFF ${diff.toFixed(2)} ‚ùå`;
                            grupoId = '-';
                            
                            // === LOG DETALLADO DE NO MATCH ===
                            // // console.log(`\n‚ùå NO MATCH - Fecha "${fecha}":`);
                            // // console.log(`   üèõÔ∏è  MAYOR: ${grupoMayor.totalDebe.toFixed(2)} vs üè¶ EXTRACTO: antes |valor|=${grupoExtracto.totalImporte.toFixed(2)}, |Importe|=${totalExtractoAbsoluto.toFixed(2)}`);
                            // // console.log(`   ‚ùå Diferencia: ${diff.toFixed(2)} (NO CONCILIADO)`);
                        }
                    } else if (tieneGrupoMayor) {
                        status = 'MAYOR SOLO';
                        grupoId = '-';
                        
                        // === LOG GRUPO SOLO EN MAYOR ===
                        // // console.log(`\n‚ö†Ô∏è  GRUPO SOLO EN MAYOR - Fecha "${fecha}":`);
                        // // console.log(`   üèõÔ∏è  MAYOR: FDOC="${grupoMayor.fechaOriginal}" ‚Üí Total DEBE=${grupoMayor.totalDebe.toFixed(2)} (${grupoMayor.filas.length} registros)`);
                        // // console.log(`   üè¶ EXTRACTO: Sin grupo correspondiente`);
                        
                    } else {
                        status = 'BBVA SOLO';
                        grupoId = '-';
                        
                        // === LOG GRUPO SOLO EN EXTRACTO ===
                        // // console.log(`\n‚ö†Ô∏è  GRUPO SOLO EN EXTRACTO - Fecha "${fecha}":`);
                        // // console.log(`   üèõÔ∏è  MAYOR: Sin grupo correspondiente`);
                        // // console.log(`   üè¶ EXTRACTO: F.Op="${grupoExtracto.fOperacionOriginal}" ‚Üí Total antes |valor|=${grupoExtracto.totalImporte.toFixed(2)}, Total |Importe|=${Math.abs(grupoExtracto.totalImporte).toFixed(2)} (${grupoExtracto.registros.length} registros)`);
                    }
                    
                    // Formatear datos para tabla
                    const fechaStr = (fecha || '').toString().padEnd(10);
                    const mayorStr = tieneGrupoMayor ? (grupoMayor.fechaOriginal || '').toString().padEnd(11) : '           ';
                    const mayorDebe = tieneGrupoMayor ? (grupoMayor.totalDebe || 0).toFixed(2).padStart(11) : '           ';
                    const bbvaStr = tieneGrupoExtracto ? (grupoExtracto.fOperacionOriginal || '').toString().padEnd(10) : '          ';
                    const bbvaImporte = tieneGrupoExtracto ? Math.abs(grupoExtracto.totalImporte || 0).toFixed(2).padStart(11) : '           ';
                    const statusStr = status.padEnd(11);
                    const grupoStr = grupoId.toString().padStart(7);
                    
                    // // console.log(`‚îÇ ${fechaStr} ‚îÇ ${mayorStr} ‚îÇ ${mayorDebe} ‚îÇ ${bbvaStr} ‚îÇ ${bbvaImporte} ‚îÇ ${statusStr} ‚îÇ ${grupoStr} ‚îÇ`);
                }
                
                // // console.log(`‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`);
                
                // === 5. MAPEO INTERNO MAYOR: BNA DEBE vs CUALQUIER HABER ===
                // // console.log(`\nüîó === ETAPA 2: MAPEO INTERNO MAYOR BBVA (BNA DEBE vs CUALQUIER HABER) ===`);
                // // console.log(`üìã Buscar registros pendientes con DES_TDOP="Bna" DEBE > 0`);
                // // console.log(`üìã Mapear contra CUALQUIER registro con mismo FDOC + HABER igual al DEBE`);
                
                let conciliadosInternos = 0;
                let candidatosBnaDebe = 0;
                let candidatosHaberEncontrados = 0;
                
                // Recopilar candidatos BNA con DEBE
                const candidatosBna = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes (no conciliadas en etapa anterior)
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const desTdop = filaMayor[idxM.desTdop] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    const numdoc = filaMayor[idxM.numdoc] || '';
                    
                    // Solo registros con DES_TDOP="Bna" y DEBE > 0
                    if (String(desTdop || '').trim().toLowerCase() === 'bna' && debe > 0) {
                        candidatosBnaDebe++;
                        candidatosBna.push({
                            indice: i,
                            fdoc: fdoc,
                            debe: debe,
                            comprob: comprob,
                            numdoc: numdoc,
                            fechaNormalizada: this.normalizarFecha(fdoc)
                        });
                    }
                }
                
                // // console.log(`üìä Candidatos BNA con DEBE > 0: ${candidatosBnaDebe}`);
                
                // === DETALLE DE CANDIDATOS BNA ===
                // // console.log(`\nüîç === DETALLE CANDIDATOS BNA (DEBE > 0) ===`);
                candidatosBna.slice(0, 10).forEach((candidato, idx) => {
                    // // console.log(`üìù Candidato BNA ${idx + 1}: FDOC="${candidato.fdoc}", DEBE=${candidato.debe.toFixed(2)}, COMPROB="${candidato.comprob}", NUMDOC="${candidato.numdoc}"`);
                });
                
                if (candidatosBna.length > 10) {
                    // // console.log(`   ... y ${candidatosBna.length - 10} candidatos m√°s`);
                }
                
                // === MAPEO Y CONCILIACI√ìN INTERNA ===
                // // console.log(`\nüîó === MAPEO: BNA DEBE vs CUALQUIER HABER (mismo FDOC + monto) ===`);
                
                const registrosYaUsados = new Set();
                
                for (const candidatoBna of candidatosBna) {
                    // Skip si este candidato BNA ya fue usado
                    if (registrosYaUsados.has(candidatoBna.indice)) continue;
                    
                    // Buscar en TODOS los registros pendientes (sin filtro DES_TDOP)
                    for (let j = 0; j < filasFiltradasMayor.length; j++) {
                        // Skip si ya fue procesado en etapa anterior o ya usado en mapeo interno
                        if (estadosFilas.has(j) || registrosYaUsados.has(j) || j === candidatoBna.indice) continue;
                        
                        const filaDestino = filasFiltradasMayor[j];
                        const fdocDestino = filaDestino[idxM.fdoc] || '';
                        const haberDestino = this.normalizarMonto(filaDestino[idxM.haber] || '0');
                        const comprobDestino = filaDestino[idxM.comprob] || '';
                        const numdocDestino = filaDestino[idxM.numdoc] || '';
                        const desTdopDestino = filaDestino[idxM.desTdop] || '';
                        
                        // Verificar coincidencia: mismo FDOC + HABER igual al DEBE del BNA
                        const fechaDestinoNormalizada = this.normalizarFecha(fdocDestino);
                        const diff = Math.abs(candidatoBna.debe - haberDestino);
                        
                        if (candidatoBna.fechaNormalizada === fechaDestinoNormalizada && diff < 0.01 && haberDestino > 0) {
                            candidatosHaberEncontrados++;
                            
                            // === MATCH ENCONTRADO ===
                            // // console.log(`\nüéØ MATCH INTERNO ENCONTRADO:`);
                            // // console.log(`   üìÖ Fecha BNA: "${candidatoBna.fdoc}" vs Destino: "${fdocDestino}" (normalizada: "${candidatoBna.fechaNormalizada}")`);
                            // // console.log(`   üè¶ BNA: DES_TDOP="Bna", DEBE=${candidatoBna.debe.toFixed(2)}, COMPROB="${candidatoBna.comprob}", NUMDOC="${candidatoBna.numdoc}"`);
                            // // console.log(`   üéØ DESTINO: DES_TDOP="${desTdopDestino}", HABER=${haberDestino.toFixed(2)}, COMPROB="${comprobDestino}", NUMDOC="${numdocDestino}"`);
                            // // console.log(`   ‚úÖ Diferencia: ${diff.toFixed(6)} (CONCILIADO INTERNO)`);
                            
                            // Conciliar ambos registros
                            estadosFilas.set(candidatoBna.indice, {
                                estado: 'P4 - Conciliada',
                                ref: `HABER-${comprobDestino}`
                            });
                            
                            estadosFilas.set(j, {
                                estado: 'P4 - Conciliada',
                                ref: `BNA-${candidatoBna.comprob}`
                            });
                            
                            // Marcar como usados
                            registrosYaUsados.add(candidatoBna.indice);
                            registrosYaUsados.add(j);
                            
                            conciliadosInternos++;
                            break; // Salir del bucle para buscar siguiente candidato BNA
                        }
                    }
                }
                
                // // console.log(`\nüè¶ MAPEO INTERNO COMPLETADO: ${conciliadosInternos} conciliaciones internas`);
                
                // // console.log(`\nüè¶ BBVA PASO 4 COMPLETADO: ${conciliados} grupos con extracto + ${conciliadosInternos} mapeos internos = ${conciliados + conciliadosInternos} total`);
                
                // === TABLA RESUMEN FINAL ===
                // // console.log(`\nüìä RESUMEN FINAL PASO 4 BBVA:`);
                // // console.log(`‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
                // // console.log(`‚îÇ       CONCEPTO      ‚îÇ  VALOR  ‚îÇ`);
                // // console.log(`‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§`);
                // // console.log(`‚îÇ Candidatos Mayor    ‚îÇ ${candidatosMayor.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Candidatos Extracto ‚îÇ ${candidatosExtracto.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Grupos Mayor        ‚îÇ ${gruposPorFechaMayor.size.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Grupos Extracto     ‚îÇ ${gruposPorFOperacion.size.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Conciliados c/Extrac‚îÇ ${conciliados.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Candidatos BNA DEBE ‚îÇ ${candidatosBnaDebe.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Candidatos HABER    ‚îÇ ${candidatosHaberEncontrados.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Conciliados Internos‚îÇ ${conciliadosInternos.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ TOTAL CONCILIADOS   ‚îÇ ${(conciliados + conciliadosInternos).toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`);
                
                return {
                    candidatos: candidatosMayor + candidatosExtracto + candidatosBnaDebe + candidatosHaberEncontrados,
                    conciliados: conciliados + conciliadosInternos,
                    etapa4a: conciliados, // Conciliados con extracto
                    etapa4b: conciliadosInternos // Conciliados internos (BNA DEBE vs CUALQUIER HABER)
                };
            },

            procesarPaso4SBP(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 4 SBP (SCOTIABANK) - MAPEO ESPEC√çFICO:
                
                Mayor: 
                1. Filtrar por DES_TDOP = "Bna" + ESTADO = "Pendiente"
                2. Agrupar por FDOC
                3. FDOC + DEBE
                
                Extracto SBP:
                1. Identificar en "Movimiento" (columna B) que INICIEN con "PAGO DE LETRA"
                2. Agrupar por "Fecha" (columna A)  
                3. "Fecha" + |Importe| (columna C, valor absoluto)
                
                ESTADOS RESULTANTES:
                - "P4 - Conciliada" para registros mapeados
                */
                
                // // console.log(`\nüè¶ *** SBP PASO 4 INICIADO *** - Agrupaci√≥n por FDOC + mapeo PAGO DE LETRA`);
                // // console.log(`üìã Total registros Mayor disponibles: ${filasFiltradasMayor.length}`);
                // // console.log(`üìã Total registros Extracto disponibles: ${extractoProcesable.length}`);
                // // console.log(`üìã Estados ya procesados Mayor: ${estadosFilas.size}`);
                // // console.log(`üìã Estados ya procesados Extracto: ${estadosExtracto.size}`);
                
                let candidatosMayor = 0;
                let candidatosExtracto = 0; 
                let conciliados = 0;
                let numeroGrupo = 1;
                
                // === ETAPA 1: AGRUPAR MAYOR POR FDOC ===
                const gruposMayor = new Map();
                
                // Primera pasada: Identificar candidatos BNA y agrupar por FDOC
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue; // Solo procesar pendientes
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const desTdop = (filaMayor[idxM.desTdop] || '').toString().trim().toUpperCase();
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    const libro = filaMayor[idxM.libro] || '';
                    
                    // Filtrar solo DES_TDOP = "BNA"
                    if (desTdop === 'BNA' && debe > 0) {
                        candidatosMayor++;
                        
                        const fdocNormalizado = this.normalizarFecha(fdoc);
                        
                        if (!gruposMayor.has(fdocNormalizado)) {
                            gruposMayor.set(fdocNormalizado, {
                                fecha: fdocNormalizado,
                                fechaOriginal: fdoc,
                                totalDebe: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposMayor.get(fdocNormalizado);
                        grupo.totalDebe += debe;
                        grupo.filas.push({
                            indice: i,
                            fila: filaMayor,
                            debe: debe,
                            comprob: comprob,
                            libro: libro
                        });
                    }
                }
                
                // === ETAPA 2: AGRUPAR EXTRACTO POR FECHA ===
                const gruposExtracto = new Map();
                
                // Segunda pasada: Identificar "PAGO DE LETRA" y agrupar por fecha
                for (let j = 0; j < extractoProcesable.length; j++) {
                    if (estadosExtracto.has(j)) continue; // Solo procesar pendientes
                    
                    const itemExtracto = extractoProcesable[j];
                    const filaExtracto = itemExtracto.fila;
                    const fecha = filaExtracto[0] || ''; // Columna A
                    const movimiento = (filaExtracto[1] || '').toString().toUpperCase(); // Columna B
                    const importe = this.normalizarMonto(filaExtracto[2] || '0'); // Columna C
                    const referencia = filaExtracto[3] || ''; // Columna D
                    
                    // Filtrar solo "PAGO DE LETRA"
                    if (movimiento.startsWith('PAGO DE LETRA') && importe > 0) {
                        candidatosExtracto++;
                        
                        const fechaNormalizada = this.normalizarFecha(fecha);
                        
                        if (!gruposExtracto.has(fechaNormalizada)) {
                            gruposExtracto.set(fechaNormalizada, {
                                fecha: fechaNormalizada,
                                fechaOriginal: fecha,
                                totalImporte: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposExtracto.get(fechaNormalizada);
                        grupo.totalImporte += Math.abs(importe);
                        grupo.filas.push({
                            indice: j,
                            fila: filaExtracto,
                            importe: Math.abs(importe),
                            referencia: referencia,
                            movimiento: movimiento
                        });
                    }
                }
                
                // === ETAPA 3: MAPEAR GRUPOS MAYOR vs EXTRACTO ===
                // // console.log(`üìä SBP - Grupos formados: ${gruposMayor.size} Mayor, ${gruposExtracto.size} Extracto`);
                
                for (const [fechaMayor, grupoMayor] of gruposMayor) {
                    if (gruposExtracto.has(fechaMayor)) {
                        const grupoExtracto = gruposExtracto.get(fechaMayor);
                        
                        // Verificar coincidencia de totales
                        const diferencia = Math.abs(grupoMayor.totalDebe - grupoExtracto.totalImporte);
                        
                        if (diferencia < 0.01) { // Tolerancia m√≠nima
                            // ‚úÖ MATCH ENCONTRADO - Procesar conciliaci√≥n
                            const refExtracto = grupoExtracto.filas.length > 0 ? grupoExtracto.filas[0].referencia : '';
                            const refMayor = grupoMayor.filas.length > 0 ? `${grupoMayor.filas[0].libro}-${grupoMayor.filas[0].comprob}` : '';
                            
                            // Marcar todas las filas del Mayor como conciliadas
                            grupoMayor.filas.forEach(item => {
                                estadosFilas.set(item.indice, {
                                    estado: 'P4 - Conciliada',
                                    ref: refExtracto
                                });
                                conciliados++;
                            });
                            
                            // Marcar todas las filas del Extracto como conciliadas
                            grupoExtracto.filas.forEach(item => {
                                estadosExtracto.set(item.indice, {
                                    estado: 'P4 - Conciliada',
                                    ref: refMayor
                                });
                                conciliados++;
                            });
                            
                            // // console.log(`‚úÖ SBP Grupo ${numeroGrupo}: FECHA=${fechaMayor}, DEBE=${grupoMayor.totalDebe.toFixed(2)}, IMPORTE=${grupoExtracto.totalImporte.toFixed(2)}`);
                            numeroGrupo++;
                        }
                    }
                }
                
                // // console.log(`üìä SBP PASO 4 COMPLETADO:`);
                // // console.log(`   üìà Candidatos Mayor (BNA): ${candidatosMayor}`);
                // // console.log(`   üìà Candidatos Extracto (PAGO DE LETRA): ${candidatosExtracto}`);
                // // console.log(`   üéØ Total conciliados: ${conciliados}`);
                
                return {
                    candidatos: candidatosMayor + candidatosExtracto,
                    conciliados: conciliados,
                    etapa4a: conciliados,
                    etapa4b: 0 // SBP no tiene etapa 4B
                };
            },

            procesarPaso5(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig) {
                /*
                PASO 5 - OPERACIONES PROT Y DEV (Agrupaci√≥n por Totales Diarios):
                
                CUENTA EST√ÅNDAR (BCP, SANTANDER):
                CRITERIOS DE FILTRADO:
                - LIBRO = "04" + GLOSA inicia con "PROT" (Protestos)
                - LIBRO = "03" o "09" + GLOSA inicia con "DEV" (Devoluciones)
                - ESTADO = "Pendiente" (no procesados en pasos anteriores)
                
                CUENTA BBVA:
                Mayor: IDENTIFICAR TOTALES POR D√çA (PROT + DEV)
                Extracto: Concepto="DEV DOC COBRANZAS" + agrupar por F. Operaci√≥n + |Importe|
                
                ESTRATEGIA DE AGRUPACI√ìN:
                1. Agrupar por FDOC (fecha) los registros que cumplen criterios
                2. Sumar TOTAL HABER de cada grupo por fecha
                3. Mapear: FDOC del grupo + TOTAL HABER vs FECHA + |MONTO| del Extracto
                
                ESTADOS RESULTANTES:
                - Todas las filas del grupo: "P5 - Conciliada"
                - Mayor: #REF = [Operaci√≥n - N√∫mero del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del primer registro del grupo
                
                NOTA: Los montos del extracto est√°n en negativo, se usa Math.abs()
                */
                
                // Verificar si es cuenta BBVA, SBP o IBK para usar l√≥gica espec√≠fica
                if (cuentaConfig && (cuentaConfig.codigo === '1041201' || cuentaConfig.codigo === '1041202')) {
                    return this.procesarPaso5BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (cuentaConfig && (cuentaConfig.alias === 'SBP' || cuentaConfig.alias === 'SBP.USD')) {
                    return this.procesarPaso5SBP(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (cuentaConfig && (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD')) {
                    return this.procesarPaso5IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                }
                
                // // // console.log(`üìà PASO 5: Iniciando procesamiento de operaciones PROT y DEV`);
                // // // console.log(`üîç Total filas a revisar: ${filasFiltradasMayor.length}`);
                // // // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                let candidatosPROT = 0;
                let candidatosDEV = 0;
                let gruposFormados = 0;
                let conciliados = 0;
                
                // Agrupar filas por FDOC que cumplan criterios
                const gruposPorFecha = new Map();
                
                // Primera pasada: Identificar candidatos y agrupar por fecha
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Verificar criterios del PASO 5
                    const esPROT = String(libro || '').trim() === '04' && glosa.startsWith('PROT');
                    const esDEV = (String(libro || '').trim() === '03' || String(libro || '').trim() === '09') && glosa.startsWith('DEV');
                    
                    if (esPROT || esDEV) {
                        if (esPROT) candidatosPROT++;
                        if (esDEV) candidatosDEV++;
                        
                        // Debug: Mostrar los primeros 5 candidatos
                        // if ((candidatosPROT + candidatosDEV) <= 5) {
                        //     // // console.log(`üîç Candidato ${candidatosPROT + candidatosDEV}: LIBRO="${libro}", GLOSA="${glosa.substring(0, 30)}...", FDOC="${fdoc}", HABER=${haber}`);
                        // }
                        
                        // Normalizar fecha para agrupaci√≥n
                        const fdocNormalizado = this.normalizarFecha(fdoc);
                        
                        if (!gruposPorFecha.has(fdocNormalizado)) {
                            gruposPorFecha.set(fdocNormalizado, {
                                fecha: fdocNormalizado,
                                fechaOriginal: fdoc,
                                totalHaber: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposPorFecha.get(fdocNormalizado);
                        grupo.totalHaber += haber;
                        grupo.filas.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            haber: haber,
                            comprob: comprob
                        });
                    }
                }
                
                gruposFormados = gruposPorFecha.size;
                // // // console.log(`üìä PASO 5 - AGRUPACI√ìN:`);
                // // // console.log(`   üìö Candidatos LIBRO 04 (PROT): ${candidatosPROT}`);
                // // // console.log(`   üìó Candidatos LIBRO 03 (DEV): ${candidatosDEV}`);
                // // // console.log(`   üìÖ Grupos por fecha formados: ${gruposFormados}`);
                
                // Segunda pasada: Buscar matches en extracto para cada grupo
                for (const [fechaNormalizada, grupo] of gruposPorFecha.entries()) {
                    // // // console.log(`\nüóìÔ∏è Procesando grupo fecha: ${fechaNormalizada}`);
                    // // // console.log(`   üí∞ Total HABER: ${grupo.totalHaber} (${grupo.filas.length} filas)`);
                    
                    // Buscar match en extracto
                    const matchExtracto = this.buscarMatchExtractoPorGrupo(fechaNormalizada, grupo.totalHaber, extractoProcesable, idxE, estadosExtracto);
                    
                    if (matchExtracto.encontrado) {
                        // Asignar estados a todas las filas del grupo
                        const refMayor = matchExtracto.operacionNumero; // N√∫mero de operaci√≥n del extracto
                        const refExtracto = `${grupo.filas[0].libro}-${grupo.filas[0].comprob}`; // Usar primer registro del grupo
                        
                        // IMPORTANTE: Todas las filas del grupo reciben el MISMO n√∫mero de operaci√≥n del extracto
                        grupo.filas.forEach(item => {
                            estadosFilas.set(item.indice, {
                                estado: 'P5 - Conciliada',
                                ref: refMayor // Mismo n√∫mero de operaci√≥n para todas las filas del grupo
                            });
                            
                            // DEBUG: Verificar que se est√° asignando correctamente
                            // // // console.log(`   üîß DEBUG: Asignando a √≠ndice ${item.indice} ‚Üí ESTADO="P5 - Conciliada", REF="${refMayor}"`);
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P5 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                        // // // console.log(`‚úÖ PASO 5 - CONCILIACI√ìN GRUPAL EXITOSA:`);
                        // // // console.log(`   üìÖ Grupo fecha: ${fechaNormalizada}, Total HABER: ${grupo.totalHaber} (${grupo.filas.length} filas)`);
                        // // // console.log(`   üìã Extracto: FECHA="${matchExtracto.fecha}", MONTO=abs(${matchExtracto.monto}) ‚Üí REF="${refExtracto}"`);
                        // // // console.log(`   üîó TODAS las ${grupo.filas.length} filas del grupo ‚Üí REF="${refMayor}" (Operaci√≥n-N√∫mero del extracto)`);
                        
                        // Debug: Mostrar cada fila del grupo con su REF asignado
                        // grupo.filas.forEach((item, idx) => {
                        //     // // console.log(`      Fila ${idx + 1} (Mayor √≠ndice ${item.indice}): LIBRO=${item.libro}, COMPROB=${item.comprob}, HABER=${item.haber} ‚Üí REF="${refMayor}"`);
                        // });
                    } else {
                        // if (gruposFormados <= 10) {
                        //     // // console.log(`‚ùå No se encontr√≥ match para grupo fecha ${fechaNormalizada}, total: ${grupo.totalHaber}`);
                        // }
                    }
                }
                
                // // // console.log(`üìä PASO 5 - RESUMEN COMPLETO:`);
                // // // console.log(`   üìö Candidatos PROT: ${candidatosPROT}`);
                // // // console.log(`   üìó Candidatos DEV: ${candidatosDEV}`);
                // // // console.log(`   üìÖ Grupos formados: ${gruposFormados}`);
                // // // console.log(`   üéØ Grupos conciliados: ${conciliados}`);
                
                return {
                    candidatos: candidatosPROT + candidatosDEV,
                    grupos: gruposFormados,
                    conciliados: conciliados
                };
            },

            procesarPaso5BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 5 BBVA - OPERACIONES DEV DOC COBRANZAS:
                
                Mayor: 
                1. IDENTIFICAR TOTALES POR D√çA
                2. Filtrar por LIBRO = "04" + GLOSA inicia con "PROT" (Protestos)
                3. Filtrar por LIBRO = "03" o "09" + GLOSA inicia con "DEV" (Devoluciones)
                4. Agrupar por FDOC + sumar HABER
                
                Extracto BBVA:
                1. Identificar en "Concepto" que contenga "DEV DOC COBRANZAS"
                2. Agrupar por "F. Operaci√≥n" (fecha)
                3. "F. Operaci√≥n" + |Importe| (valor absoluto)
                
                HEADERS BBVA: F. Operaci√≥n, F. Valor, C√≥digo, N¬∫. Doc., Concepto, Importe, Oficina, ESTADO, #REF
                
                ESTADOS RESULTANTES:
                - "P5 - Conciliada" para registros mapeados
                */
                
                // // console.log(`\nüìà === PASO 5 BBVA: DEV DOC COBRANZAS ===`);
                // // console.log(`üîç Total filas Mayor a revisar: ${filasFiltradasMayor.length}`);
                // // console.log(`üîç Total filas Extracto disponibles: ${extractoProcesable.length}`);
                // // console.log(`üîç Estados ya procesados - Mayor: ${estadosFilas.size}, Extracto: ${estadosExtracto.size}`);
                
                let candidatosPROT = 0;
                let candidatosDEV = 0;
                let candidatosExtracto = 0;
                let gruposFormados = 0;
                let conciliados = 0;
                
                // === 1. AGRUPAR MAYOR POR FECHA (TOTALES POR D√çA) ===
                // // console.log(`\nüè¶ === ETAPA 1: AGRUPACI√ìN MAYOR POR FECHA ===`);
                const gruposPorFechaMayor = new Map();
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Verificar criterios del PASO 5 BBVA
                    const esPROT = String(libro || '').trim() === '04' && glosa.startsWith('PROT');
                    const esDEV = (String(libro || '').trim() === '03' || String(libro || '').trim() === '09') && glosa.startsWith('DEV');
                    
                    if (esPROT || esDEV) {
                        if (esPROT) candidatosPROT++;
                        if (esDEV) candidatosDEV++;
                        
                        // Normalizar fecha para agrupaci√≥n
                        const fdocNormalizado = this.normalizarFecha(fdoc);
                        
                        if (!gruposPorFechaMayor.has(fdocNormalizado)) {
                            gruposPorFechaMayor.set(fdocNormalizado, {
                                fecha: fdocNormalizado,
                                fechaOriginal: fdoc,
                                totalHaber: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposPorFechaMayor.get(fdocNormalizado);
                        grupo.totalHaber += haber;
                        grupo.filas.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            haber: haber,
                            comprob: comprob
                        });
                    }
                }
                
                gruposFormados = gruposPorFechaMayor.size;
                // // console.log(`üìä MAYOR - Candidatos LIBRO 04 (PROT): ${candidatosPROT}`);
                // // console.log(`üìä MAYOR - Candidatos LIBRO 03/09 (DEV): ${candidatosDEV}`);
                // // console.log(`üìä MAYOR - Grupos por fecha formados: ${gruposFormados}`);
                
                // === 2. AGRUPAR EXTRACTO POR F. OPERACI√ìN (DEV DOC COBRANZAS) ===
                // // console.log(`\nüè¶ === ETAPA 2: AGRUPACI√ìN EXTRACTO BBVA (DEV DOC COBRANZAS) ===`);
                const gruposPorFOperacion = new Map();
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fOperacion = filaExtracto[0] || ''; // F. Operaci√≥n (Col A)
                    const concepto = (filaExtracto[4] || '').toString().toUpperCase(); // Concepto (Col E)
                    const importe = this.normalizarMonto(filaExtracto[5] || '0'); // Importe (Col F)
                    
                    // Verificar si contiene "DEV DOC COBRANZAS"
                    if (concepto.includes('DEV DOC COBRANZAS')) {
                        candidatosExtracto++;
                        
                        // Normalizar fecha para agrupaci√≥n
                        const fOperacionNormalizada = this.normalizarFecha(fOperacion);
                        
                        if (!gruposPorFOperacion.has(fOperacionNormalizada)) {
                            gruposPorFOperacion.set(fOperacionNormalizada, {
                                fecha: fOperacionNormalizada,
                                fechaOriginal: fOperacion,
                                totalImporte: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposPorFOperacion.get(fOperacionNormalizada);
                        grupo.totalImporte += importe; // Sumar con signo
                        grupo.filas.push({
                            indice: i,
                            fila: filaExtracto,
                            fOperacion: fOperacion,
                            concepto: concepto,
                            importe: importe
                        });
                    }
                }
                
                // // console.log(`üìä EXTRACTO - Candidatos DEV DOC COBRANZAS: ${candidatosExtracto}`);
                // // console.log(`üìä EXTRACTO - Grupos por F. Operaci√≥n: ${gruposPorFOperacion.size}`);
                
                // === 3. MOSTRAR DETALLE DE GRUPOS FORMADOS ===
                // // console.log(`\nüîç === DETALLE GRUPOS MAYOR ===`);
                let contadorMayor = 1;
                for (const [fecha, grupo] of gruposPorFechaMayor) {
                    // // console.log(`üìÖ GRUPO MAYOR ${contadorMayor}: FDOC="${grupo.fechaOriginal}" ‚Üí Normalizada="${fecha}"`);
                    // // console.log(`   üí∞ Total HABER: ${grupo.totalHaber.toFixed(2)} (${grupo.filas.length} filas)`);
                    
                    grupo.filas.slice(0, 3).forEach((fila, idx) => {
                        // // console.log(`     ${idx + 1}. LIBRO=${fila.libro}, GLOSA="${fila.glosa.substring(0, 30)}...", HABER=${fila.haber.toFixed(2)}`);
                    });
                    if (grupo.filas.length > 3) {
                        // // console.log(`     ... y ${grupo.filas.length - 3} filas m√°s`);
                    }
                    contadorMayor++;
                    if (contadorMayor > 5) break;
                }
                
                // // console.log(`\nüîç === DETALLE GRUPOS EXTRACTO BBVA ===`);
                let contadorExtracto = 1;
                for (const [fecha, grupo] of gruposPorFOperacion) {
                    // // console.log(`üìÖ GRUPO BBVA ${contadorExtracto}: F. Operaci√≥n="${grupo.fechaOriginal}" ‚Üí Normalizada="${fecha}"`);
                    // // console.log(`   üí∞ Total Importe: ${grupo.totalImporte.toFixed(2)} ‚Üí |${Math.abs(grupo.totalImporte).toFixed(2)}| (${grupo.filas.length} filas)`);
                    
                    grupo.filas.slice(0, 3).forEach((fila, idx) => {
                        // // console.log(`     ${idx + 1}. Concepto="${fila.concepto.substring(0, 30)}...", Importe=${fila.importe.toFixed(2)}`);
                    });
                    if (grupo.filas.length > 3) {
                        // // console.log(`     ... y ${grupo.filas.length - 3} filas m√°s`);
                    }
                    contadorExtracto++;
                    if (contadorExtracto > 5) break;
                }
                
                // === 4. COMPARACI√ìN Y CONCILIACI√ìN ===
                // // console.log(`\nüîó === COMPARACI√ìN MAYOR vs EXTRACTO BBVA ===`);
                // // console.log(`‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
                // // console.log(`‚îÇ    FECHA   ‚îÇ    MAYOR    ‚îÇ  MAYOR HAB  ‚îÇ    BBVA    ‚îÇ  BBVA IMP   ‚îÇ   STATUS    ‚îÇ  GRUPO  ‚îÇ`);
                // // console.log(`‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§`);
                
                // Buscar matches entre grupos
                for (const [fechaMayor, grupoMayor] of gruposPorFechaMayor) {
                    let matchEncontrado = false;
                    let grupoId = '';
                    
                    for (const [fechaBBVA, grupoBBVA] of gruposPorFOperacion) {
                        const totalImporteAbsoluto = Math.abs(grupoBBVA.totalImporte);
                        const diff = Math.abs(grupoMayor.totalHaber - totalImporteAbsoluto);
                        
                        if (fechaMayor === fechaBBVA && diff < 0.01) {
                            // === MATCH ENCONTRADO ===
                            matchEncontrado = true;
                            grupoId = `GRUPO-${conciliados + 1}`;
                            
                            // // console.log(`\nüéØ MATCH ENCONTRADO:`);
                            // // console.log(`   üìÖ Fecha: "${grupoMayor.fechaOriginal}" ‚Üî "${grupoBBVA.fechaOriginal}" (normalizada: "${fechaMayor}")`);
                            // // console.log(`   üí∞ Montos: MAYOR=${grupoMayor.totalHaber.toFixed(2)} ‚Üî BBVA=|${totalImporteAbsoluto.toFixed(2)}| (diff: ${diff.toFixed(6)})`);
                            // // console.log(`   üîó Asignando ${grupoId} a ${grupoMayor.filas.length} filas Mayor + ${grupoBBVA.filas.length} filas BBVA`);
                            
                            // Conciliar todas las filas del grupo Mayor
                            grupoMayor.filas.forEach(item => {
                                estadosFilas.set(item.indice, {
                                    estado: 'P5 - Conciliada',
                                    ref: grupoId
                                });
                            });
                            
                            // Conciliar todas las filas del grupo BBVA
                            grupoBBVA.filas.forEach(item => {
                                estadosExtracto.set(item.indice, {
                                    estado: 'P5 - Conciliada',
                                    ref: grupoId
                                });
                            });
                            
                            conciliados++;
                            break; // Salir del bucle interno
                        }
                    }
                    
                    // Mostrar en tabla
                    const fechaStr = fechaMayor.padEnd(10);
                    const mayorStr = `${grupoMayor.filas.length} filas`.padEnd(11);
                    const mayorHaber = grupoMayor.totalHaber.toFixed(2).padStart(11);
                    const bbvaStr = matchEncontrado ? `${gruposPorFOperacion.get(fechaMayor)?.filas.length || 0} filas`.padEnd(10) : 'NO MATCH'.padEnd(10);
                    const bbvaImporte = matchEncontrado ? Math.abs(gruposPorFOperacion.get(fechaMayor)?.totalImporte || 0).toFixed(2).padStart(11) : '0.00'.padStart(11);
                    const statusStr = matchEncontrado ? 'MATCH'.padEnd(11) : 'DIFF'.padEnd(11);
                    const grupoStr = matchEncontrado ? grupoId.padEnd(7) : '-'.padEnd(7);
                    
                    // // console.log(`‚îÇ ${fechaStr} ‚îÇ ${mayorStr} ‚îÇ ${mayorHaber} ‚îÇ ${bbvaStr} ‚îÇ ${bbvaImporte} ‚îÇ ${statusStr} ‚îÇ ${grupoStr} ‚îÇ`);
                }
                
                // // console.log(`‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`);
                
                // // console.log(`\nüè¶ BBVA PASO 5 COMPLETADO: ${conciliados} grupos conciliados`);
                
                // // console.log(`\nüìä RESUMEN FINAL PASO 5 BBVA:`);
                // // console.log(`‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
                // // console.log(`‚îÇ       CONCEPTO      ‚îÇ  VALOR  ‚îÇ`);
                // // console.log(`‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§`);
                // // console.log(`‚îÇ Candidatos PROT L04 ‚îÇ ${candidatosPROT.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Candidatos DEV L03/09‚îÇ ${candidatosDEV.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Candidatos BBVA     ‚îÇ ${candidatosExtracto.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Grupos Mayor        ‚îÇ ${gruposPorFechaMayor.size.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Grupos BBVA         ‚îÇ ${gruposPorFOperacion.size.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ GRUPOS CONCILIADOS  ‚îÇ ${conciliados.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`);
                
                return {
                    candidatos: candidatosPROT + candidatosDEV + candidatosExtracto,
                    grupos: gruposFormados + gruposPorFOperacion.size,
                    conciliados: conciliados
                };
            },

            procesarPaso5SBP(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 5 SBP (SCOTIABANK) - OPERACIONES PROT/DEV:
                
                Mayor SBP (ESPEC√çFICO): 
                1. Filtrar por LIBRO = "04" + GLOSA contiene "PROT" (Protestos)
                2. Filtrar por LIBRO = "03" o "09" + GLOSA contiene "DEV" (Devoluciones)
                3. Agrupar por FDOC + sumar HABER
                
                Extracto (EST√ÅNDAR - igual que otros bancos):
                1. Usar l√≥gica est√°ndar de PROT/DEV del extracto
                2. Buscar por fecha y monto como siempre
                
                ESTADOS RESULTANTES:
                - "P5 - Conciliada" para registros mapeados
                */
                
                            // // console.log(`\nüìà === PASO 5 SBP: INICIADO ===`);
            // // console.log(`üîç Total filas Mayor a revisar: ${filasFiltradasMayor.length}`);
            // // console.log(`üîç Total filas Extracto disponibles: ${extractoProcesable.length}`);
            // // console.log(`üîç Estados ya procesados - Mayor: ${estadosFilas.size}, Extracto: ${estadosExtracto.size}`);
                
                let candidatosPROT = 0;
                let candidatosDEV = 0;
                let candidatosExtracto = 0;
                let gruposFormados = 0;
                let conciliados = 0;
                
                // === ETAPA 1: AGRUPAR MAYOR POR FECHA (PROT + DEV) ===
                const gruposPorFecha = new Map();
                
                // // console.log(`\nüîç === PASO 5 SBP: ANALIZANDO MAYOR ===`);
                
                // Primera pasada: Identificar candidatos PROT y DEV y agrupar por FDOC
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue; // Solo procesar pendientes
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Verificar criterios del PASO 5 - SBP espec√≠fico
                    const esPROT = String(libro || '').trim() === '04' && (glosa.startsWith('PROT') || glosa.includes('PROT'));
                    const esDEV = (String(libro || '').trim() === '03' || String(libro || '').trim() === '09') && (glosa.startsWith('DEV') || glosa.includes('DEV'));
                    
                    // Log de los primeros 10 registros para debug
                    if (i < 10) {
                        const glosaSafe = glosa ? glosa.substring(0, 40) : '';
                        // // console.log(`üìã Fila ${i}: LIBRO="${libro}" GLOSA="${glosaSafe}..." HABER=${haber} PROT=${esPROT} DEV=${esDEV}`);
                    }
                    
                    if ((esPROT || esDEV) && haber > 0) {
                        if (esPROT) candidatosPROT++;
                        if (esDEV) candidatosDEV++;
                        
                        const fdocNormalizado = this.normalizarFecha(fdoc);
                        
                        // // console.log(`‚úÖ CANDIDATO ${candidatosPROT + candidatosDEV}: FDOC="${fdoc}" ‚Üí "${fdocNormalizado}" HABER=${haber} TIPO=${esPROT ? 'PROT' : 'DEV'}`);
                        
                        if (!gruposPorFecha.has(fdocNormalizado)) {
                            gruposPorFecha.set(fdocNormalizado, {
                                fecha: fdocNormalizado,
                                fechaOriginal: fdoc,
                                totalHaber: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposPorFecha.get(fdocNormalizado);
                        grupo.totalHaber += haber;
                        grupo.filas.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            haber: haber,
                            comprob: comprob
                        });
                    }
                }
                
                gruposFormados = gruposPorFecha.size;
                // // console.log(`üìä Mayor: ${candidatosPROT} PROT + ${candidatosDEV} DEV = ${candidatosPROT + candidatosDEV} candidatos ‚Üí ${gruposFormados} grupos`);
                
                // === ETAPA 2: AGRUPAR EXTRACTO SBP POR FECHA (DEVOLUCION LETRA) ===
                // // console.log(`\nüîç === PASO 5 SBP: AGRUPANDO EXTRACTO ===`);
                
                // Mostrar grupos formados en Mayor
                // // console.log(`üìä Grupos Mayor formados:`);
                // for (const [fecha, grupo] of gruposPorFecha) {
                //     // console.log(`   üìÖ ${fecha}: ${grupo.filas.length} filas, TOTAL=${grupo.totalHaber.toFixed(2)}`);
                // }
                
                const gruposExtracto = new Map();
                
                // Filtrar y agrupar extracto por "DEVOLUCION LETRA"
                for (let j = 0; j < extractoProcesable.length; j++) {
                    if (estadosExtracto.has(j)) continue; // Solo procesar pendientes
                    
                    const itemExtracto = extractoProcesable[j];
                    const filaExtracto = itemExtracto.fila;
                    const fecha = filaExtracto[idxE.fecha] || ''; // Usar √≠ndice correcto
                    const movimiento = (filaExtracto[idxE.descripcion] || '').toString().toUpperCase(); // Usar √≠ndice correcto
                    const importe = this.normalizarMonto(filaExtracto[idxE.monto] || '0'); // Usar √≠ndice correcto
                    const operacion = filaExtracto[idxE.operacion] || ''; // Para referencia
                    
                    // Debug: mostrar los primeros registros
                    if (j < 5) {
                        // // console.log(`üìã Extracto ${j}: fecha="${fecha}" movimiento="${movimiento.substring(0, 20)}..." importe=${Math.abs(importe).toFixed(2)}`);
                    }
                    
                    // Filtrar solo "DEVOLUCION LETRA" o "DEVOLUCION"
                    if ((movimiento.includes('DEVOLUCION LETRA') || movimiento.includes('DEVOLUCION')) && importe !== 0) {
                        candidatosExtracto++;
                        
                        const fechaNormalizada = this.normalizarFecha(fecha);
                        
                        // Extracto candidato encontrado
                        
                        if (!gruposExtracto.has(fechaNormalizada)) {
                            gruposExtracto.set(fechaNormalizada, {
                                fecha: fechaNormalizada,
                                fechaOriginal: fecha,
                                totalImporte: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposExtracto.get(fechaNormalizada);
                        grupo.totalImporte += Math.abs(importe);
                        grupo.filas.push({
                            indice: j,
                            fila: filaExtracto,
                            importe: Math.abs(importe),
                            operacion: operacion,
                            movimiento: movimiento
                        });
                    }
                }
                
                // // console.log(`üìä Extracto: ${candidatosExtracto} candidatos ‚Üí ${gruposExtracto.size} grupos`);
                
                // === ETAPA 3: MAPEAR GRUPOS MAYOR vs EXTRACTO ===
                // // console.log(`\nüîç === PASO 5 SBP: MAPEANDO GRUPOS ===`);
                
                for (const [fechaMayor, grupoMayor] of gruposPorFecha) {
                    // // console.log(`\nüóìÔ∏è Procesando Mayor fecha: ${fechaMayor} (TOTAL=${grupoMayor.totalHaber.toFixed(2)})`);
                    
                    if (gruposExtracto.has(fechaMayor)) {
                        const grupoExtracto = gruposExtracto.get(fechaMayor);
                        
                        // Verificar coincidencia de totales
                        const diferencia = Math.abs(grupoMayor.totalHaber - grupoExtracto.totalImporte);
                        
                        // // console.log(`   üîç COMPARANDO: Mayor=${grupoMayor.totalHaber.toFixed(2)} vs Extracto=${grupoExtracto.totalImporte.toFixed(2)} | Diff=${diferencia.toFixed(4)}`);
                        
                        if (diferencia < 0.01) { // Tolerancia m√≠nima
                            // ‚úÖ MATCH ENCONTRADO - Procesar conciliaci√≥n
                            const refExtracto = grupoExtracto.filas.length > 0 ? grupoExtracto.filas[0].operacion : '';
                            const refMayor = grupoMayor.filas.length > 0 ? `${grupoMayor.filas[0].libro}-${grupoMayor.filas[0].comprob}` : '';
                            
                            // // console.log(`   ‚úÖ MATCH! Conciliando ${grupoMayor.filas.length} Mayor + ${grupoExtracto.filas.length} Extracto`);
                            
                            // Marcar todas las filas del Mayor como conciliadas
                            grupoMayor.filas.forEach(item => {
                                estadosFilas.set(item.indice, {
                                    estado: 'P5 - Conciliada',
                                    ref: refExtracto
                                });
                                conciliados++;
                                const glosaSafe = item.glosa ? item.glosa.substring(0, 30) : '';
                                // // console.log(`     ‚úÖ Mayor fila ${item.indice}: "${glosaSafe}..." ‚Üí REF="${refExtracto}"`);
                            });
                            
                            // Marcar todas las filas del Extracto como conciliadas
                            grupoExtracto.filas.forEach(item => {
                                estadosExtracto.set(item.indice, {
                                    estado: 'P5 - Conciliada',
                                    ref: refMayor
                                });
                                conciliados++;
                                const movSafe = item.movimiento ? item.movimiento.substring(0, 30) : '';
                                // Extracto conciliado
                            });
                        } else {
                            // Diferencia mayor a tolerancia
                        }
                    } else {
                        // No match encontrado
                    }
                }
                
                // SBP Paso 5 completado
                
                return {
                    candidatos: candidatosPROT + candidatosDEV + candidatosExtracto,
                    grupos: gruposFormados + gruposExtracto.size,
                    conciliados: conciliados
                };
            },

            procesarPaso6BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 6 BBVA - DEP√ìSITOS BANCARIOS:
                
                Mayor: 
                1. Agrupar por criterio: NUMDOC
                2. FDOC + DEBE
                3. Siempre en la glosa del mayor: "DEPOSITO BANCARIO"
                
                Extracto BBVA:
                1. F. Operaci√≥n + |Importe|
                
                HEADERS BBVA: F. Operaci√≥n, F. Valor, C√≥digo, N¬∫. Doc., Concepto, Importe, Oficina, ESTADO, #REF
                
                ESTADOS RESULTANTES:
                - "P6 - Conciliada" para registros mapeados
                */
                
                // // console.log(`\nüè¶ === PASO 6 BBVA: DEP√ìSITOS BANCARIOS ===`);
                // // console.log(`üîç Total filas Mayor a revisar: ${filasFiltradasMayor.length}`);
                // // console.log(`üîç Total filas Extracto disponibles: ${extractoProcesable.length}`);
                // // console.log(`üîç Estados ya procesados - Mayor: ${estadosFilas.size}, Extracto: ${estadosExtracto.size}`);
                
                let candidatosMayor = 0;
                let candidatosExtracto = 0;
                let gruposFormados = 0;
                let conciliados = 0;
                
                // === 1. IDENTIFICAR CANDIDATOS MAYOR (INICIA CON DEPOSITO BANCARIO) ===
                // // console.log(`\nüèõÔ∏è === ETAPA 1: IDENTIFICACI√ìN CANDIDATOS MAYOR ===`);
                const candidatosMayorDepositos = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const numdoc = filaMayor[idxM.numdoc] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Verificar si inicia con "DEPOSITO BANCARIO" (m√°s flexible que includes)
                    if (glosa.startsWith('DEPOSITO BANCARIO')) {
                        candidatosMayor++;
                        candidatosMayorDepositos.push({
                            indice: i,
                            fila: filaMayor,
                            glosa: glosa,
                            numdoc: this.normalizarTexto(numdoc),
                            fdoc: fdoc,
                            debe: debe,
                            comprob: comprob,
                            fechaNormalizada: this.normalizarFecha(fdoc)
                        });
                        
                        if (candidatosMayor <= 10) {
                            // // console.log(`üìù Mayor Candidato ${candidatosMayor}: NUMDOC="${numdoc}", FDOC="${fdoc}", DEBE=${debe.toFixed(2)}, GLOSA="${glosa.substring(0, 30)}..."`);
                        }
                    }
                }
                
                // // console.log(`üìä MAYOR - Candidatos DEPOSITO BANCARIO: ${candidatosMayor}`);
                
                // === 2. AGRUPAR MAYOR POR NUMDOC ===
                // // console.log(`\nüìã === ETAPA 2: AGRUPACI√ìN MAYOR POR NUMDOC ===`);
                const gruposPorNumdoc = new Map();
                
                candidatosMayorDepositos.forEach(candidato => {
                    if (!gruposPorNumdoc.has(candidato.numdoc)) {
                        gruposPorNumdoc.set(candidato.numdoc, {
                            numdocOriginal: candidato.numdoc,
                            filas: []
                        });
                    }
                    gruposPorNumdoc.get(candidato.numdoc).filas.push(candidato);
                });
                
                gruposFormados = gruposPorNumdoc.size;
                // // console.log(`üìä MAYOR - Grupos por NUMDOC formados: ${gruposFormados}`);
                
                // === 3. PROCESAR EXTRACTO BBVA (TODOS LOS REGISTROS PENDIENTES) ===
                // // console.log(`\nüè¶ === ETAPA 3: PROCESAMIENTO EXTRACTO BBVA ===`);
                const extractoDisponible = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fOperacion = filaExtracto[0] || ''; // F. Operaci√≥n (Col A)
                    const importe = this.normalizarMonto(filaExtracto[5] || '0'); // Importe (Col F)
                    const concepto = (filaExtracto[4] || '').toString(); // Concepto (Col E)
                    
                    candidatosExtracto++;
                    extractoDisponible.push({
                        indice: i,
                        fila: filaExtracto,
                        fOperacion: fOperacion,
                        importe: importe,
                        importeAbsoluto: Math.abs(importe),
                        concepto: concepto,
                        fechaNormalizada: this.normalizarFecha(fOperacion)
                    });
                    
                    if (candidatosExtracto <= 10) {
                        // Extracto candidato procesado
                    }
                }
                
                // // console.log(`üìä EXTRACTO - Total registros disponibles: ${candidatosExtracto}`);
                
                // === 4. DETALLE DE GRUPOS MAYOR ===
                // // console.log(`\nüîç === DETALLE GRUPOS MAYOR (NUMDOC) ===`);
                let contadorGrupo = 1;
                for (const [numdoc, grupo] of gruposPorNumdoc) {
                    // // console.log(`üìÖ GRUPO MAYOR ${contadorGrupo}: NUMDOC="${numdoc}"`);
                    // // console.log(`   üìã Registros: ${grupo.filas.length}`);
                    
                    grupo.filas.slice(0, 3).forEach((fila, idx) => {
                        // // console.log(`     ${idx + 1}. FDOC="${fila.fdoc}", DEBE=${fila.debe.toFixed(2)}, COMPROB="${fila.comprob}"`);
                    });
                    if (grupo.filas.length > 3) {
                        // // console.log(`     ... y ${grupo.filas.length - 3} registros m√°s`);
                    }
                    contadorGrupo++;
                    if (contadorGrupo > 5) break;
                }
                
                // === 5. MAPEO: MAYOR (FDOC+DEBE) vs EXTRACTO (F.OP+|IMPORTE|) ===
                // // console.log(`\nüîó === MAPEO: MAYOR (FDOC+DEBE) vs EXTRACTO (F.OP+|IMPORTE|) ===`);
                
                for (const [numdoc, grupo] of gruposPorNumdoc) {
                    // Para cada fila del grupo, buscar match en extracto
                    for (const filaMayor of grupo.filas) {
                        // Skip si ya fue procesada
                        if (estadosFilas.has(filaMayor.indice)) continue;
                        
                        // Buscar match en extracto
                        for (const itemExtracto of extractoDisponible) {
                            // Skip si ya fue procesado
                            if (estadosExtracto.has(itemExtracto.indice)) continue;
                            
                            // Comparar fecha y monto
                            const fechasCoinciden = filaMayor.fechaNormalizada === itemExtracto.fechaNormalizada;
                            const diff = Math.abs(filaMayor.debe - itemExtracto.importeAbsoluto);
                            const montosCoinciden = diff < 0.01;
                            
                            if (fechasCoinciden && montosCoinciden) {
                                // === MATCH ENCONTRADO ===
                                // // console.log(`\nüéØ MATCH ENCONTRADO:`);
                                // // console.log(`   üìÖ Fecha: "${filaMayor.fdoc}" ‚Üî "${itemExtracto.fOperacion}" (normalizada: "${filaMayor.fechaNormalizada}")`);
                                // // console.log(`   üí∞ Montos: MAYOR=${filaMayor.debe.toFixed(2)} ‚Üî EXTRACTO=|${itemExtracto.importeAbsoluto.toFixed(2)}| (diff: ${diff.toFixed(6)})`);
                                // // console.log(`   üìã NUMDOC="${numdoc}", COMPROB="${filaMayor.comprob}"`);
                                // // console.log(`   üìã Concepto BBVA: "${itemExtracto.concepto.substring(0, 50)}..."`);
                                
                                // Conciliar ambos registros
                                const refMayor = `BBVA-P6-${itemExtracto.fOperacion}`;
                                const refExtracto = `${filaMayor.comprob}`;
                                
                                estadosFilas.set(filaMayor.indice, {
                                    estado: 'P6 - Conciliada',
                                    ref: refMayor
                                });
                                
                                estadosExtracto.set(itemExtracto.indice, {
                                    estado: 'P6 - Conciliada',
                                    ref: refExtracto
                                });
                                
                                conciliados++;
                                break; // Salir del bucle de extracto para esta fila de Mayor
                            }
                        }
                    }
                }
                
                                // // console.log(`\nüè¶ BBVA PASO 6 COMPLETADO: ${conciliados} dep√≥sitos conciliados`);

                // // console.log(`\nüìä RESUMEN FINAL PASO 6 BBVA:`);
                // // console.log(`‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
                // // console.log(`‚îÇ       CONCEPTO      ‚îÇ  VALOR  ‚îÇ`);
                // // console.log(`‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§`);
                // // console.log(`‚îÇ Candidatos Mayor    ‚îÇ ${candidatosMayor.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Candidatos Extracto ‚îÇ ${candidatosExtracto.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Grupos Mayor NUMDOC ‚îÇ ${gruposFormados.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ DEP√ìSITOS CONCILIAD ‚îÇ ${conciliados.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`);
                
                return {
                    candidatos: candidatosMayor + candidatosExtracto,
                    grupos: gruposFormados,
                    conciliados: conciliados
                };
            },

            procesarPaso6(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 6 - DEP√ìSITOS BANCARIOS:
                
                CRITERIOS DE FILTRADO:
                - LIBRO = "01"
                - GLOSA inicia con "DEPOSITO BANCARIO"
                - ESTADO = "Pendiente" (no procesados en pasos anteriores)
                
                MAPEO ESPEC√çFICO POR BANCO:
                
                BCP (General):
                - ETAPA 6A: NUMDOC (Mayor) ‚Üî Operaci√≥n - N√∫mero (Extracto col G/√≠ndice 6)
                - ETAPA 6B: FDOC + DEBE (Mayor) ‚Üî FECHA + MONTO (Extracto)
                
                SANT (Santander) - MAPEO ESPEC√çFICO:
                - FDOC + DEBE (Mayor) ‚Üî Fecha (Columna A) + Importe (Columna G, valor absoluto)
                - Fecha formato: dd/mm/aaaa
                
                BBVA - MAPEO ESPEC√çFICO:
                - Mayor: Agrupar por NUMDOC, FDOC+DEBE
                - Extracto: F. Operaci√≥n + |Importe|
                - Glosa del mayor: inicia con "DEPOSITO BANCARIO"
                
                ESTADOS RESULTANTES:
                - "P6 - Conciliada"
                - Mayor: #REF = [Referencia del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                // Verificar si es cuenta BBVA, IBK, DET o BN
                // // console.log(`üèõÔ∏è PASO 6: Procesando cuenta ${cuentaConfig?.alias || 'desconocida'} (${cuentaConfig?.codigo || 'sin c√≥digo'})`);
                
                if (cuentaConfig && (cuentaConfig.codigo === '1041201' || cuentaConfig.codigo === '1041202')) {
                    // // console.log(`üîÄ Redirigiendo a procesarPaso6BBVA`);
                    return this.procesarPaso6BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (cuentaConfig && (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD')) {
                    // // console.log(`üîÄ Redirigiendo a procesarPaso6IBK`);
                    return this.procesarPaso6IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (cuentaConfig && cuentaConfig.alias === 'DET') {
                    console.log(`üîÄ Redirigiendo a procesarPaso6DET`);
                    return this.procesarPaso6DET(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (cuentaConfig && cuentaConfig.alias === 'BN') {
                    // console.log(`üîÄ Redirigiendo a procesarPaso6BN`);
                    return this.procesarPaso6BN(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                }
                
                // // // console.log(`üìà PASO 6: Iniciando procesamiento de dep√≥sitos bancarios para ${cuentaConfig?.alias || 'cuenta gen√©rica'}`);
                // // // console.log(`üîç Total filas a revisar: ${filasFiltradasMayor.length}`);
                // // // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                // === VERIFICAR SI ES SANTANDER PARA MAPEO ESPEC√çFICO ===
                const esSantander = cuentaConfig && cuentaConfig.alias === 'SANT';
                
                let candidatosDepositos = 0;
                let conciliadosEtapa6A = 0;
                let conciliadosEtapa6B = 0;
                
                // Identificar candidatos LIBRO="01" + GLOSA inicia con "DEPOSITO BANCARIO"
                const candidatosPaso6 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    
                    // Verificar criterios del PASO 6
                    const esLibro01 = String(libro || '').trim() === '01';
                    const esDepositoBancario = glosa.startsWith('DEPOSITO BANCARIO');
                    
                    if (esLibro01 && esDepositoBancario) {
                        candidatosDepositos++;
                        const numdoc = filaMayor[idxM.numdoc] || '';
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosPaso6.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            numdoc: this.normalizarTexto(numdoc),
                            fdoc: fdoc,
                            debe: debe,
                            comprob: comprob
                        });
                        
                        // Debug: Mostrar los primeros 5 candidatos
                        if (candidatosDepositos <= 5) {
                            // // console.log(`üîç Candidato ${candidatosDepositos}: LIBRO="${libro}", GLOSA="${glosa.substring(0, 40)}...", NUMDOC="${numdoc}", FDOC="${fdoc}", DEBE=${debe}`);
                        }
                    }
                }
                
                // // // console.log(`üìä PASO 6 - FILTRADO:`);
                // // console.log(`   üè¶ Candidatos LIBRO 01 con DEP√ìSITO BANCARIO: ${candidatosDepositos}`);
                
                if (candidatosDepositos === 0) {
                    // // // console.log(`‚ö†Ô∏è No se encontraron candidatos para PASO 6`);
                    return { candidatos: 0, conciliados: 0, etapa6a: 0, etapa6b: 0 };
                }
                
                // ETAPA 6A: Mapeo por NUMDOC vs Operaci√≥n-N√∫mero
                // // console.log(`\nüÖ∞Ô∏è ETAPA 6A: Mapeo por NUMDOC vs Operaci√≥n-N√∫mero`);
                
                for (const candidato of candidatosPaso6) {
                    // Saltar si ya fue procesado en otra etapa
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    // Buscar en extracto por NUMDOC vs Operaci√≥n-N√∫mero
                    const matchExtracto = this.buscarMatchPorNUMDOC(candidato.numdoc, extractoProcesable, idxE, estadosExtracto);
                    
                    if (matchExtracto.encontrado) {
                        const refMayor = matchExtracto.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P6 - Conciliada',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P6 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliadosEtapa6A++;
                        
                        // // console.log(`‚úÖ ETAPA 6A - CONCILIACI√ìN EXITOSA:`);
                        // // console.log(`   üìã Mayor: NUMDOC="${candidato.numdoc}", LIBRO=${candidato.libro}, COMPROB=${candidato.comprob} ‚Üí REF="${refMayor}"`);
                        // // console.log(`   üìã Extracto: Operaci√≥n-N√∫mero="${matchExtracto.operacionNumero}" ‚Üí REF="${refExtracto}"`);
                    }
                }
                
                // ETAPA 6B: Mapeo espec√≠fico seg√∫n banco
                if (esSantander) {
                    // // console.log(`\nüÖ±Ô∏è ETAPA 6B SANTANDER: Mapeo FDOC+DEBE vs Fecha(A)+Importe(G)`);
                } else {
                    // // console.log(`\nüÖ±Ô∏è ETAPA 6B BCP: Mapeo por FDOC+DEBE vs FECHA+MONTO`);
                }
                
                for (const candidato of candidatosPaso6) {
                    // Saltar si ya fue procesado en ETAPA 6A
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    let matchExtracto;
                    
                    if (esSantander) {
                        // MAPEO ESPEC√çFICO SANTANDER: Columnas A (Fecha) y G (Importe)
                        matchExtracto = this.buscarMatchSantanderPaso6(candidato.fdoc, candidato.debe, extractoProcesable, estadosExtracto);
                    } else {
                        // MAPEO BCP: Usando √≠ndices din√°micos
                        matchExtracto = this.buscarMatchPorFechaYMonto(candidato.fdoc, candidato.debe, extractoProcesable, idxE, estadosExtracto);
                    }
                    
                    if (matchExtracto.encontrado) {
                        const refMayor = matchExtracto.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P6 - Conciliada',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P6 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliadosEtapa6B++;
                        
                        // // console.log(`‚úÖ ETAPA 6B - CONCILIACI√ìN EXITOSA:`);
                        // // console.log(`   üìã Mayor: FDOC="${candidato.fdoc}", DEBE=${candidato.debe} ‚Üí REF="${refMayor}"`);
                        // // console.log(`   üìã Extracto: FECHA="${matchExtracto.fecha}", MONTO=${matchExtracto.monto} ‚Üí REF="${refExtracto}"`);
                    }
                }
                
                const totalConciliados = conciliadosEtapa6A + conciliadosEtapa6B;
                
                // // // console.log(`üìä PASO 6 - RESUMEN COMPLETO:`);
                // // console.log(`   üè¶ Candidatos DEP√ìSITOS: ${candidatosDepositos}`);
                // // console.log(`   üÖ∞Ô∏è Etapa 6A (NUMDOC): ${conciliadosEtapa6A} conciliaciones`);
                // // console.log(`   üÖ±Ô∏è Etapa 6B (FDOC+DEBE): ${conciliadosEtapa6B} conciliaciones`);
                // // console.log(`   üéØ Total conciliados: ${totalConciliados}`);
                
                return {
                    candidatos: candidatosDepositos,
                    conciliados: totalConciliados,
                    etapa6a: conciliadosEtapa6A,
                    etapa6b: conciliadosEtapa6B
                };
            },

            buscarMatchPorNUMDOC(numdocMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                Busca un match en el extracto para ETAPA 6A:
                - Compara NUMDOC (Mayor normalizado) vs Operaci√≥n - N√∫mero (Extracto col G/√≠ndice 6)
                - Retorna datos del match si se encuentra
                */
                
                // // console.log(`üîç Buscando match por NUMDOC: "${numdocMayor}"`);
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    // // console.log(`‚ùå Error: extractoProcesable no es v√°lido`);
                    return { encontrado: false };
                }
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    candidatosRevisados++;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const operacionNumero = filaExtracto[6] || ''; // Columna G - Operaci√≥n N√∫mero
                    const operacionNormalizada = this.normalizarTexto(operacionNumero);
                    
                    // Comparar NUMDOC vs Operaci√≥n-N√∫mero (ambos normalizados)
                    const coincide = numdocMayor && operacionNormalizada && numdocMayor === operacionNormalizada;
                    
                    if (candidatosRevisados <= 5) {
                        // // console.log(`   üîç Candidato ${candidatosRevisados}: Operaci√≥n="${operacionNumero}" ‚Üí "${operacionNormalizada}" | Match: ${coincide ? '‚úÖ' : '‚ùå'}`);
                    }
                    
                    if (coincide) {
                        // // console.log(`‚úÖ MATCH NUMDOC encontrado en √≠ndice ${i}`);
                        // // console.log(`   üìã NUMDOC Mayor: "${numdocMayor}" ‚Üî Operaci√≥n Extracto: "${operacionNumero}"`);
                        return {
                            encontrado: true,
                            indice: i,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                // // console.log(`‚ùå No se encontr√≥ match NUMDOC despu√©s de revisar ${candidatosRevisados} candidatos`);
                return { encontrado: false };
            },

            buscarMatchPorFechaYMonto(fdocMayor, debeMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                Busca un match en el extracto para ETAPA 6B:
                - Compara FDOC (Mayor) vs FECHA (Extracto col A)
                - Compara DEBE (Mayor) vs |MONTO| (Extracto col D en VALOR ABSOLUTO)
                - Retorna datos del match si se encuentra
                NOTA: Reutiliza la l√≥gica del Paso 4 con normalizaci√≥n
                */
                
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                // // console.log(`üîç Buscando match por FECHA+MONTO: FDOC="${fdocMayor}" ‚Üí "${fechaMayorNormalizada}", DEBE=${debeMayor}`);
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    // // console.log(`‚ùå Error: extractoProcesable no es v√°lido`);
                    return { encontrado: false };
                }
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    candidatosRevisados++;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[6] || ''; // Columna G - Operaci√≥n N√∫mero
                    
                    // Normalizar fecha y monto del extracto
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtractoRaw_parsed = this.normalizarMonto(montoExtractoRaw);
                    const montoExtracto = Math.abs(montoExtractoRaw_parsed); // VALOR ABSOLUTO
                    
                    // Comparar fechas y montos
                    const fechasCoinciden = fechaMayorNormalizada && fechaExtractoNormalizada && fechaMayorNormalizada === fechaExtractoNormalizada;
                    const diferenciaMonto = Math.abs(debeMayor - montoExtracto);
                    const montosCoinciden = diferenciaMonto === 0; // Exacto
                    
                    if (candidatosRevisados <= 5) {
                        // // console.log(`   üîç Candidato ${candidatosRevisados}:`);
                        // // console.log(`      Fecha: "${fechaExtractoRaw}" ‚Üí "${fechaExtractoNormalizada}" | Match: ${fechasCoinciden ? '‚úÖ' : '‚ùå'}`);
                        // // console.log(`      Monto: ${montoExtractoRaw} ‚Üí abs(${montoExtracto}) | Diferencia: ${diferenciaMonto.toFixed(4)} | Match: ${montosCoinciden ? '‚úÖ' : '‚ùå'}`);
                    }
                    
                    if (fechasCoinciden && montosCoinciden) {
                        // // console.log(`‚úÖ MATCH FECHA+MONTO encontrado en √≠ndice ${i}`);
                        // // console.log(`   üìã FDOC Mayor: "${fdocMayor}" ‚Üî FECHA Extracto: "${fechaExtractoRaw}"`);
                        // // console.log(`   üìã DEBE Mayor: ${debeMayor} ‚Üî |MONTO| Extracto: ${montoExtracto} (diferencia: ${diferenciaMonto.toFixed(4)})`);
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                // // console.log(`‚ùå No se encontr√≥ match FECHA+MONTO despu√©s de revisar ${candidatosRevisados} candidatos`);
                return { encontrado: false };
            },

            buscarMatchSantanderPaso6(fdocMayor, debeMayor, extractoProcesable, estadosExtracto) {
                /*
                Busca un match espec√≠fico para SANTANDER en PASO 6:
                - Compara FDOC (Mayor) vs FECHA (Extracto Columna A/√≠ndice 0)
                - Compara DEBE (Mayor) vs IMPORTE (Extracto Columna G/√≠ndice 6 en VALOR ABSOLUTO)
                - Fecha formato: dd/mm/aaaa
                - Retorna datos del match si se encuentra
                */
                
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                // // console.log(`üè¶ SANT PASO 6: Buscando match FDOC="${fdocMayor}" ‚Üí "${fechaMayorNormalizada}", DEBE=${debeMayor}`);
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    // // console.log(`‚ùå Error: extractoProcesable no es v√°lido para SANT`);
                    return { encontrado: false };
                }
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    candidatosRevisados++;
                    
                    // === MAPEO ESPEC√çFICO SANTANDER ===
                    // Columna A (√≠ndice 0): Fecha 
                    // Columna G (√≠ndice 6): Importe (valor absoluto)
                    const fechaExtracto = filaExtracto[0] || ''; // Columna A
                    const importeExtracto = filaExtracto[6] || '0'; // Columna G
                    const referenciaExtracto = filaExtracto[3] || ''; // Columna D - Referencia
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                    const montoExtractoAbs = Math.abs(this.normalizarMonto(importeExtracto));
                    
                    // Verificar coincidencias: FECHA exacta + MONTO absoluto exacto
                    const fechasCoinciden = fechaMayorNormalizada === fechaExtractoNormalizada;
                    const montosCoinciden = Math.abs(debeMayor - montoExtractoAbs) < 0.01; // Tolerancia para decimales
                    
                    if (fechasCoinciden && montosCoinciden) {
                        // // console.log(`‚úÖ SANT MATCH encontrado: FECHA="${fechaExtracto}"‚Üí"${fechaExtractoNormalizada}", IMPORTE=${importeExtracto}‚Üí${montoExtractoAbs}`);
                        // // console.log(`   üìã Referencia: "${referenciaExtracto}"`);
                        
                        return {
                            encontrado: true,
                            indice: i,
                            filaCompleta: filaExtracto,
                            fecha: fechaExtracto,
                            monto: montoExtractoAbs,
                            operacionNumero: referenciaExtracto || `SANT-${i}`
                        };
                    }
                    
                    // Debug para los primeros 3 candidatos
                    if (candidatosRevisados <= 3) {
                        // // console.log(`üîç SANT Candidato ${candidatosRevisados}: FECHA="${fechaExtracto}"‚Üí"${fechaExtractoNormalizada}" vs "${fechaMayorNormalizada}", IMPORTE=${importeExtracto}‚Üí${montoExtractoAbs} vs ${debeMayor}`);
                    }
                }
                
                // // console.log(`‚ùå SANT: No se encontr√≥ match despu√©s de revisar ${candidatosRevisados} candidatos`);
                return { encontrado: false };
            },

            procesarPaso7BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 7 BBVA - MAPEO DIRECTO:
                
                Mayor: 
                1. FDOC + DEBE (todos los registros pendientes)
                
                Extracto BBVA:
                1. F. Operaci√≥n + |Importe|
                
                HEADERS BBVA: F. Operaci√≥n, F. Valor, C√≥digo, N¬∫. Doc., Concepto, Importe, Oficina, ESTADO, #REF
                
                ESTADOS RESULTANTES:
                - "P7 - Conciliada" para registros mapeados
                */
                
                // // console.log(`\nüìã === PASO 7 BBVA: MAPEO DIRECTO ===`);
                // // console.log(`üîç Total filas Mayor a revisar: ${filasFiltradasMayor.length}`);
                // // console.log(`üîç Total filas Extracto disponibles: ${extractoProcesable.length}`);
                // // console.log(`üîç Estados ya procesados - Mayor: ${estadosFilas.size}, Extracto: ${estadosExtracto.size}`);
                
                let candidatosMayor = 0;
                let candidatosExtracto = 0;
                let conciliados = 0;
                
                // === 1. IDENTIFICAR CANDIDATOS MAYOR (TODOS LOS PENDIENTES) ===
                // // console.log(`\nüèõÔ∏è === ETAPA 1: IDENTIFICACI√ìN CANDIDATOS MAYOR ===`);
                const candidatosMayorPendientes = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString();
                    
                    candidatosMayor++;
                    candidatosMayorPendientes.push({
                        indice: i,
                        fila: filaMayor,
                        fdoc: fdoc,
                        debe: debe,
                        comprob: comprob,
                        libro: libro,
                        glosa: glosa,
                        fechaNormalizada: this.normalizarFecha(fdoc)
                    });
                    
                    if (candidatosMayor <= 10) {
                        // // console.log(`üìù Mayor Candidato ${candidatosMayor}: FDOC="${fdoc}", DEBE=${debe.toFixed(2)}, LIBRO="${libro}", GLOSA="${glosa.substring(0, 30)}..."`);
                    }
                }
                
                // // console.log(`üìä MAYOR - Total candidatos pendientes: ${candidatosMayor}`);
                
                // === 2. PROCESAR EXTRACTO BBVA (TODOS LOS REGISTROS PENDIENTES) ===
                // // console.log(`\nüè¶ === ETAPA 2: PROCESAMIENTO EXTRACTO BBVA ===`);
                const extractoDisponible = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fOperacion = filaExtracto[0] || ''; // F. Operaci√≥n (Col A)
                    const importe = this.normalizarMonto(filaExtracto[5] || '0'); // Importe (Col F)
                    const concepto = (filaExtracto[4] || '').toString(); // Concepto (Col E)
                    
                    candidatosExtracto++;
                    extractoDisponible.push({
                        indice: i,
                        fila: filaExtracto,
                        fOperacion: fOperacion,
                        importe: importe,
                        importeAbsoluto: Math.abs(importe),
                        concepto: concepto,
                        fechaNormalizada: this.normalizarFecha(fOperacion)
                    });
                    
                    if (candidatosExtracto <= 10) {
                        // Extracto candidato procesado
                    }
                }
                
                // // console.log(`üìä EXTRACTO - Total registros disponibles: ${candidatosExtracto}`);
                
                // === 3. MAPEO: MAYOR (FDOC+DEBE) vs EXTRACTO (F.OP+|IMPORTE|) ===
                // // console.log(`\nüîó === MAPEO: MAYOR (FDOC+DEBE) vs EXTRACTO (F.OP+|IMPORTE|) ===`);
                
                for (const candidatoMayor of candidatosMayorPendientes) {
                    // Skip si ya fue procesado
                    if (estadosFilas.has(candidatoMayor.indice)) continue;
                    
                    // Buscar match en extracto
                    for (const itemExtracto of extractoDisponible) {
                        // Skip si ya fue procesado
                        if (estadosExtracto.has(itemExtracto.indice)) continue;
                        
                        // Comparar fecha y monto
                        const fechasCoinciden = candidatoMayor.fechaNormalizada === itemExtracto.fechaNormalizada;
                        const diff = Math.abs(candidatoMayor.debe - itemExtracto.importeAbsoluto);
                        const montosCoinciden = diff < 0.01;
                        
                        if (fechasCoinciden && montosCoinciden) {
                            // === MATCH ENCONTRADO ===
                            // // console.log(`\nüéØ MATCH ENCONTRADO:`);
                            // // console.log(`   üìÖ Fecha: "${candidatoMayor.fdoc}" ‚Üî "${itemExtracto.fOperacion}" (normalizada: "${candidatoMayor.fechaNormalizada}")`);
                            // // console.log(`   üí∞ Montos: MAYOR=${candidatoMayor.debe.toFixed(2)} ‚Üî EXTRACTO=|${itemExtracto.importeAbsoluto.toFixed(2)}| (diff: ${diff.toFixed(6)})`);
                            // // console.log(`   üìã LIBRO="${candidatoMayor.libro}", COMPROB="${candidatoMayor.comprob}"`);
                            // // console.log(`   üìã Concepto BBVA: "${itemExtracto.concepto.substring(0, 50)}..."`);
                            
                            // Conciliar ambos registros
                            const refMayor = `BBVA-P7-${itemExtracto.fOperacion}`;
                            const refExtracto = `${candidatoMayor.comprob}`;
                            
                            estadosFilas.set(candidatoMayor.indice, {
                                estado: 'P7 - Conciliada',
                                ref: refMayor
                            });
                            
                            estadosExtracto.set(itemExtracto.indice, {
                                estado: 'P7 - Conciliada',
                                ref: refExtracto
                            });
                            
                            conciliados++;
                            break; // Salir del bucle de extracto para esta fila de Mayor
                        }
                    }
                }
                
                // // console.log(`\nüìã BBVA PASO 7 COMPLETADO: ${conciliados} registros conciliados`);
                
                // // console.log(`\nüìä RESUMEN FINAL PASO 7 BBVA:`);
                // // console.log(`‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
                // // console.log(`‚îÇ       CONCEPTO      ‚îÇ  VALOR  ‚îÇ`);
                // // console.log(`‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§`);
                // // console.log(`‚îÇ Candidatos Mayor    ‚îÇ ${candidatosMayor.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Candidatos Extracto ‚îÇ ${candidatosExtracto.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ REGISTROS CONCILIAD ‚îÇ ${conciliados.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`);
                
                return {
                    candidatos: candidatosMayor + candidatosExtracto,
                    conciliados: conciliados
                };
            },

            procesarPaso7(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 7 - OPERACIONES LIBRO 3:
                
                CUENTA EST√ÅNDAR (BCP, SANTANDER):
                CRITERIOS DE FILTRADO:
                - LIBRO = "03"
                - ESTADO = "Pendiente" (no procesados en pasos anteriores)
                
                BBVA - MAPEO ESPEC√çFICO:
                - Mayor: FDOC + DEBE (todos los registros pendientes)
                - Extracto: F. Operaci√≥n + |Importe|
                
                MAPEO √öNICO:
                - FDOC + DEBE (Mayor) ‚Üî FECHA + |MONTO| (Extracto)
                - Normalizaci√≥n de fechas y montos
                - Coincidencia exacta
                
                ESTADOS RESULTANTES:
                - "P7 - Conciliada" para ambos registros
                - Mayor: #REF = [Operaci√≥n - N√∫mero del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                // Verificar si es cuenta BBVA o IBK
                if (cuentaConfig && (cuentaConfig.codigo === '1041201' || cuentaConfig.codigo === '1041202')) {
                    return this.procesarPaso7BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (cuentaConfig && cuentaConfig.alias === 'IBK') {
                    return this.procesarPaso7IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                }
                
                // // // console.log(`üìà PASO 7: Iniciando procesamiento de operaciones LIBRO 3`);
                // // // console.log(`üîç Total filas a revisar: ${filasFiltradasMayor.length}`);
                // // // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                let candidatosLibro3 = 0;
                let conciliados = 0;
                
                // Identificar candidatos LIBRO="03" pendientes
                const candidatosPaso7 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    
                    // Verificar criterios del PASO 7
                    const esLibro03 = String(libro || '').trim() === '03';
                    
                    if (esLibro03) {
                        candidatosLibro3++;
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosPaso7.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            fdoc: fdoc,
                            debe: debe,
                            comprob: comprob
                        });
                        
                        // Debug: Mostrar los primeros 5 candidatos
                        // if (candidatosLibro3 <= 5) {
                        //     // // console.log(`üîç Candidato ${candidatosLibro3}: LIBRO="${libro}", FDOC="${fdoc}", DEBE=${debe}, COMPROB="${comprob}"`);
                        // }
                    }
                }
                
                // // // console.log(`üìä PASO 7 - FILTRADO:`);
                // // // console.log(`   üìã Candidatos LIBRO 03 pendientes: ${candidatosLibro3}`);
                
                if (candidatosLibro3 === 0) {
                    // // // console.log(`‚ö†Ô∏è No se encontraron candidatos para PASO 7`);
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // MAPEO: FDOC+DEBE vs FECHA+MONTO
                // // // console.log(`\nüìã MAPEO: FDOC+DEBE vs FECHA+MONTO`);
                
                for (const candidato of candidatosPaso7) {
                    // Saltar si ya fue procesado
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    // Buscar en extracto por FDOC+DEBE vs FECHA+MONTO (reutilizar funci√≥n del Paso 6)
                    const matchExtracto = this.buscarMatchPorFechaYMonto(candidato.fdoc, candidato.debe, extractoProcesable, idxE, estadosExtracto);
                    
                    if (matchExtracto.encontrado) {
                        const refMayor = matchExtracto.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P7 - Conciliada',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P7 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                        // // // console.log(`‚úÖ PASO 7 - CONCILIACI√ìN EXITOSA:`);
                        // // // console.log(`   üìã Mayor: LIBRO=${candidato.libro}, FDOC="${candidato.fdoc}", DEBE=${candidato.debe}, COMPROB=${candidato.comprob} ‚Üí REF="${refMayor}"`);
                        // // // console.log(`   üìã Extracto: FECHA="${matchExtracto.fecha}", MONTO=${matchExtracto.monto} ‚Üí REF="${refExtracto}"`);
                    }
                }
                
                // // // console.log(`üìä PASO 7 - RESUMEN COMPLETO:`);
                // // // console.log(`   üìã Candidatos LIBRO 03: ${candidatosLibro3}`);
                // // // console.log(`   üéØ Conciliados: ${conciliados}`);
                
                return {
                    candidatos: candidatosLibro3,
                    conciliados: conciliados
                };
            },

            procesarPaso8(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 8 - OPERACIONES M√öLTIPLES LIBROS:
                
                CRITERIOS DE FILTRADO:
                - LIBRO = "03", "09", "14", "15"
                - ESTADO = "Pendiente" (no procesados en pasos anteriores)
                
                MAPEO √öNICO:
                - FDOC + HABER (Mayor) ‚Üî FECHA + |MONTO| (Extracto)
                - Valor absoluto para monto extracto (como Paso 5)
                - Normalizaci√≥n de fechas y montos
                - Coincidencia exacta
                
                ESTADOS RESULTANTES:
                - "P8 - Conciliada" para ambos registros
                - Mayor: #REF = [Operaci√≥n - N√∫mero del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                // ‚≠ê VERIFICAR SI ES BBVA, IBK O DET PARA USAR L√ìGICA ESPEC√çFICA
                const esBBVA = cuentaConfig && (cuentaConfig.codigo === '1041201' || cuentaConfig.codigo === '1041202');
                const esIBK = cuentaConfig && cuentaConfig.alias === 'IBK';
                const esDET = cuentaConfig && cuentaConfig.alias === 'DET';
                
                if (esBBVA) {
                    // // console.log(`üè¶ PASO 8 BBVA: FDOC+HABER vs F. Operaci√≥n + |Importe|`);
                    return this.procesarPaso8BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (esIBK) {
                    // // console.log(`üè¶ PASO 8 IBK: FDOC+HABER vs Fecha operaci√≥n + |Cargo|`);
                    return this.procesarPaso8IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (esDET) {
                    console.log(`üîÄ Redirigiendo a procesarPaso8DET`);
                    return this.procesarPaso8DET(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                }
                
                // // // console.log(`üìà PASO 8: Iniciando procesamiento de operaciones M√öLTIPLES LIBROS`);
                // // // console.log(`üîç Total filas a revisar: ${filasFiltradasMayor.length}`);
                // // // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                let candidatosLibro03 = 0;
                let candidatosLibro09 = 0;
                let candidatosLibro14 = 0;
                let candidatosLibro15 = 0;
                let conciliados = 0;
                
                // Libros objetivo del Paso 8
                const librosObjetivo = ['03', '09', '14', '15'];
                
                // Identificar candidatos de m√∫ltiples libros
                const candidatosPaso8 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    
                    // Verificar criterios del PASO 8
                    const esLibroObjetivo = librosObjetivo.includes(String(libro || '').trim());
                    
                    if (esLibroObjetivo) {
                        // Contar por libro
                        if (String(libro || '').trim() === '03') candidatosLibro03++;
                        else if (String(libro || '').trim() === '09') candidatosLibro09++;
                        else if (String(libro || '').trim() === '14') candidatosLibro14++;
                        else if (String(libro || '').trim() === '15') candidatosLibro15++;
                        
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosPaso8.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            fdoc: fdoc,
                            haber: haber,
                            comprob: comprob
                        });
                        
                        // Debug: Mostrar los primeros 5 candidatos
                        // if (candidatosPaso8.length <= 5) {
                        //     // // console.log(`üîç Candidato ${candidatosPaso8.length}: LIBRO="${libro}", FDOC="${fdoc}", HABER=${haber}, COMPROB="${comprob}"`);
                        // }
                    }
                }
                
                const totalCandidatos = candidatosPaso8.length;
                
                // // // console.log(`üìä PASO 8 - FILTRADO:`);
                // // // console.log(`   üìã Candidatos LIBRO 03: ${candidatosLibro03}`);
                // // // console.log(`   üìó Candidatos LIBRO 09: ${candidatosLibro09}`);
                // // // console.log(`   üìò Candidatos LIBRO 14: ${candidatosLibro14}`);
                // // // console.log(`   üìô Candidatos LIBRO 15: ${candidatosLibro15}`);
                // // // console.log(`   üìö Total candidatos m√∫ltiples libros: ${totalCandidatos}`);
                
                if (totalCandidatos === 0) {
                    // // // console.log(`‚ö†Ô∏è No se encontraron candidatos para PASO 8`);
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // MAPEO: FDOC+HABER vs FECHA+MONTO
                // // // console.log(`\nüìã MAPEO: FDOC+HABER vs FECHA+MONTO (valor absoluto)`);
                
                for (const candidato of candidatosPaso8) {
                    // Saltar si ya fue procesado
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    // Buscar en extracto por FDOC+HABER vs FECHA+MONTO
                    const matchExtracto = this.buscarMatchPorFechaYMontoHaber(candidato.fdoc, candidato.haber, extractoProcesable, idxE, estadosExtracto);
                    
                    if (matchExtracto.encontrado) {
                        const refMayor = matchExtracto.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P8 - Conciliada',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P8 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                        // // // console.log(`‚úÖ PASO 8 - CONCILIACI√ìN EXITOSA:`);
                        // // // console.log(`   üìã Mayor: LIBRO=${candidato.libro}, FDOC="${candidato.fdoc}", HABER=${candidato.haber}, COMPROB=${candidato.comprob} ‚Üí REF="${refMayor}"`);
                        // // // console.log(`   üìã Extracto: FECHA="${matchExtracto.fecha}", |MONTO|=${matchExtracto.monto} ‚Üí REF="${refExtracto}"`);
                    }
                }
                
                // // // console.log(`üìä PASO 8 - RESUMEN COMPLETO:`);
                // // // console.log(`   üìö Candidatos m√∫ltiples libros: ${totalCandidatos}`);
                // // // console.log(`   üéØ Conciliados: ${conciliados}`);
                // // // console.log(`   üìà Distribuci√≥n: L03=${candidatosLibro03}, L09=${candidatosLibro09}, L14=${candidatosLibro14}, L15=${candidatosLibro15}`);
                
                return {
                    candidatos: totalCandidatos,
                    conciliados: conciliados,
                    libro03: candidatosLibro03,
                    libro09: candidatosLibro09,
                    libro14: candidatosLibro14,
                    libro15: candidatosLibro15
                };
            },

            buscarMatchPorFechaYMontoHaber(fdocMayor, haberMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                Busca un match en el extracto para PASO 8 (HABER):
                - Compara FDOC (Mayor) vs FECHA (Extracto col A)
                - Compara HABER (Mayor) vs |MONTO| (Extracto col D en VALOR ABSOLUTO)
                - Retorna datos del match si se encuentra
                NOTA: Similar a buscarMatchPorFechaYMonto pero usa HABER y enfatiza Math.abs()
                */
                
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                // // // console.log(`üîç Buscando match por FECHA+HABER: FDOC="${fdocMayor}" ‚Üí "${fechaMayorNormalizada}", HABER=${haberMayor}`);
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    // // // console.log(`‚ùå Error: extractoProcesable no es v√°lido`);
                    return { encontrado: false };
                }
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    candidatosRevisados++;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[6] || ''; // Columna G - Operaci√≥n N√∫mero
                    
                    // Normalizar fecha y monto del extracto
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtractoRaw_parsed = this.normalizarMonto(montoExtractoRaw);
                    const montoExtracto = Math.abs(montoExtractoRaw_parsed); // VALOR ABSOLUTO (como Paso 5)
                    
                    // Comparar fechas y montos
                    const fechasCoinciden = fechaMayorNormalizada && fechaExtractoNormalizada && fechaMayorNormalizada === fechaExtractoNormalizada;
                    const diferenciaMonto = Math.abs(haberMayor - montoExtracto);
                    const montosCoinciden = diferenciaMonto === 0; // Exacto
                    
                    // if (candidatosRevisados <= 5) {
                    //     // // console.log(`   üîç Candidato ${candidatosRevisados}:`);
                    //     // // console.log(`      Fecha: "${fechaExtractoRaw}" ‚Üí "${fechaExtractoNormalizada}" | Match: ${fechasCoinciden ? '‚úÖ' : '‚ùå'}`);
                    //     // // console.log(`      Monto: ${montoExtractoRaw} ‚Üí abs(${montoExtracto}) | HABER=${haberMayor} | Diferencia: ${diferenciaMonto.toFixed(4)} | Match: ${montosCoinciden ? '‚úÖ' : '‚ùå'}`);
                    // }
                    
                    if (fechasCoinciden && montosCoinciden) {
                        // // // console.log(`‚úÖ MATCH FECHA+HABER encontrado en √≠ndice ${i}`);
                        // // // console.log(`   üìã FDOC Mayor: "${fdocMayor}" ‚Üî FECHA Extracto: "${fechaExtractoRaw}"`);
                        // // // console.log(`   üìã HABER Mayor: ${haberMayor} ‚Üî |MONTO| Extracto: ${montoExtracto} (diferencia: ${diferenciaMonto.toFixed(4)})`);
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                // // // console.log(`‚ùå No se encontr√≥ match FECHA+HABER despu√©s de revisar ${candidatosRevisados} candidatos`);
                return { encontrado: false };
            },

            buscarMatchBBVAPaso8(fdocMayor, haberMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                Busca un match en el extracto BBVA para PASO 8:
                - Compara FDOC (Mayor) vs F. Operaci√≥n (Extracto col A)
                - Compara HABER (Mayor) vs |Importe| (Extracto col D en VALOR ABSOLUTO)
                - Retorna datos del match si se encuentra
                
                ESTRUCTURA EXTRACTO BBVA:
                - Columna A (√≠ndice 0): F. Operaci√≥n (fecha)
                - Columna D (√≠ndice 3): Importe (monto)
                - Columna G (√≠ndice 6): Operaci√≥n - N√∫mero
                */
                
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                // // console.log(`üîç BBVA PASO 8: Buscando match por F. Operaci√≥n+|Importe|: FDOC="${fdocMayor}" ‚Üí "${fechaMayorNormalizada}", HABER=${haberMayor}`);
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    // // console.log(`‚ùå Error: extractoProcesable no es v√°lido`);
                    return { encontrado: false };
                }
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    candidatosRevisados++;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // ‚≠ê MAPEO ESPEC√çFICO BBVA CORREGIDO:
                    // Columna A (√≠ndice 0): F. Operaci√≥n (fecha)
                    // Columna F (√≠ndice 5): Importe (monto) 
                    // Columna D (√≠ndice 3): N¬∫. Doc.
                    const fechaOperacionRaw = filaExtracto[0] || ''; // F. Operaci√≥n
                    const importeRaw = filaExtracto[5] || '0'; // Importe (√≠ndice 5)
                    const operacionNumero = filaExtracto[3] || ''; // N¬∫. Doc. (√≠ndice 3)
                    
                    // Normalizar fecha y monto del extracto BBVA
                    const fechaOperacionNormalizada = this.normalizarFecha(fechaOperacionRaw);
                    const importeRaw_parsed = this.normalizarMonto(importeRaw);
                    const importe = Math.abs(importeRaw_parsed); // VALOR ABSOLUTO
                    
                    // Comparar fechas y montos
                    const fechasCoinciden = fechaMayorNormalizada && fechaOperacionNormalizada && fechaMayorNormalizada === fechaOperacionNormalizada;
                    const diferenciaMonto = Math.abs(haberMayor - importe);
                    const montosCoinciden = diferenciaMonto === 0; // Exacto
                    
                    // Debug: Mostrar los primeros 5 candidatos
                    if (candidatosRevisados <= 5) {
                        // // console.log(`   üîç Candidato BBVA ${candidatosRevisados}:`);
                        // // console.log(`      ESTRUCTURA FILA: [${filaExtracto.slice(0, 8).map((col, idx) => `${idx}:"${col}"`).join(', ')}]`);
                        // // console.log(`      F. Operaci√≥n [0]: "${fechaOperacionRaw}" ‚Üí "${fechaOperacionNormalizada}" | Match: ${fechasCoinciden ? '‚úÖ' : '‚ùå'}`);
                        // // console.log(`      Importe [5]: ${importeRaw} ‚Üí abs(${importe}) | HABER=${haberMayor} | Diferencia: ${diferenciaMonto.toFixed(4)} | Match: ${montosCoinciden ? '‚úÖ' : '‚ùå'}`);
                        // // console.log(`      N¬∫. Doc [3]: "${operacionNumero}"`);
                    }
                    
                    if (fechasCoinciden && montosCoinciden) {
                        // // console.log(`‚úÖ MATCH BBVA PASO 8 encontrado en √≠ndice ${i}`);
                        // // console.log(`   üìã FDOC Mayor: "${fdocMayor}" ‚Üî F. Operaci√≥n BBVA: "${fechaOperacionRaw}"`);
                        // // console.log(`   üìã HABER Mayor: ${haberMayor} ‚Üî |Importe| BBVA: ${importe} (diferencia: ${diferenciaMonto.toFixed(4)})`);
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaOperacionNormalizada,
                            monto: importe,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                // // console.log(`‚ùå No se encontr√≥ match BBVA PASO 8 despu√©s de revisar ${candidatosRevisados} candidatos`);
                return { encontrado: false };
            },

            procesarPaso8BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 8 BBVA - OPERACIONES M√öLTIPLES LIBROS:
                
                CRITERIOS DE FILTRADO:
                - LIBRO = "03", "09", "14", "15"
                - ESTADO = "Pendiente" (no procesados en pasos anteriores)
                
                MAPEO √öNICO BBVA:
                - FDOC + HABER (Mayor) ‚Üî F. Operaci√≥n + |Importe| (Extracto)
                - Valor absoluto para monto extracto
                - Normalizaci√≥n de fechas y montos
                - Coincidencia exacta
                
                ESTRUCTURA EXTRACTO BBVA:
                - Columna A (√≠ndice 0): F. Operaci√≥n (fecha)
                - Columna F (√≠ndice 5): Importe (monto)
                - Columna D (√≠ndice 3): N¬∫. Doc.
                
                ESTADOS RESULTANTES:
                - "P8 - Conciliada" para ambos registros
                - Mayor: #REF = [Operaci√≥n - N√∫mero del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                // // console.log(`üè¶ PASO 8 BBVA: Iniciando procesamiento de operaciones M√öLTIPLES LIBROS`);
                // // console.log(`üîç Total filas a revisar: ${filasFiltradasMayor.length}`);
                // // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                let candidatosLibro03 = 0;
                let candidatosLibro09 = 0;
                let candidatosLibro14 = 0;
                let candidatosLibro15 = 0;
                let conciliados = 0;
                
                // Libros objetivo del Paso 8 BBVA
                const librosObjetivo = ['03', '09', '14', '15'];
                
                // Identificar candidatos de m√∫ltiples libros
                const candidatosPaso8 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    
                    // Verificar criterios del PASO 8 BBVA
                    const esLibroObjetivo = librosObjetivo.includes(String(libro || '').trim());
                    
                    if (esLibroObjetivo) {
                        // Contar por libro
                        if (String(libro || '').trim() === '03') candidatosLibro03++;
                        else if (String(libro || '').trim() === '09') candidatosLibro09++;
                        else if (String(libro || '').trim() === '14') candidatosLibro14++;
                        else if (String(libro || '').trim() === '15') candidatosLibro15++;
                        
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosPaso8.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            fdoc: fdoc,
                            haber: haber,
                            comprob: comprob
                        });
                        
                        // Debug: Mostrar los primeros 5 candidatos
                        if (candidatosPaso8.length <= 5) {
                            // // console.log(`üîç Candidato BBVA ${candidatosPaso8.length}: LIBRO="${libro}", FDOC="${fdoc}", HABER=${haber}, COMPROB="${comprob}"`);
                        }
                    }
                }
                
                const totalCandidatos = candidatosPaso8.length;
                
                // // console.log(`üìä PASO 8 BBVA - FILTRADO:`);
                // // console.log(`   üìã Candidatos LIBRO 03: ${candidatosLibro03}`);
                // // console.log(`   üìó Candidatos LIBRO 09: ${candidatosLibro09}`);
                // // console.log(`   üìò Candidatos LIBRO 14: ${candidatosLibro14}`);
                // // console.log(`   üìô Candidatos LIBRO 15: ${candidatosLibro15}`);
                // // console.log(`   üìö Total candidatos m√∫ltiples libros: ${totalCandidatos}`);
                
                if (totalCandidatos === 0) {
                    // // console.log(`‚ö†Ô∏è No se encontraron candidatos para PASO 8 BBVA`);
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // MAPEO BBVA: FDOC+HABER vs F. Operaci√≥n+|Importe|
                // // console.log(`\nüìã MAPEO BBVA: FDOC+HABER vs F. Operaci√≥n+|Importe| (valor absoluto)`);
                
                for (const candidato of candidatosPaso8) {
                    // Saltar si ya fue procesado
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    // Buscar en extracto por FDOC+HABER vs F. Operaci√≥n+|Importe|
                    const matchExtracto = this.buscarMatchBBVAPaso8(candidato.fdoc, candidato.haber, extractoProcesable, idxE, estadosExtracto);
                    
                    if (matchExtracto.encontrado) {
                        const refMayor = matchExtracto.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P8 - Conciliada',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P8 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                        // // console.log(`‚úÖ PASO 8 BBVA - CONCILIACI√ìN EXITOSA:`);
                        // // console.log(`   üìã Mayor: LIBRO=${candidato.libro}, FDOC="${candidato.fdoc}", HABER=${candidato.haber}, COMPROB=${candidato.comprob} ‚Üí REF="${refMayor}"`);
                        // // console.log(`   üìã Extracto: F. Operaci√≥n="${matchExtracto.fecha}", |Importe|=${matchExtracto.monto} ‚Üí REF="${refExtracto}"`);
                    }
                }
                
                // // console.log(`üìä PASO 8 BBVA - RESUMEN COMPLETO:`);
                // // console.log(`   üìö Candidatos m√∫ltiples libros: ${totalCandidatos}`);
                // // console.log(`   üéØ Conciliados: ${conciliados}`);
                // // console.log(`   üìà Distribuci√≥n: L03=${candidatosLibro03}, L09=${candidatosLibro09}, L14=${candidatosLibro14}, L15=${candidatosLibro15}`);
                
                return {
                    candidatos: totalCandidatos,
                    conciliados: conciliados,
                    libro03: candidatosLibro03,
                    libro09: candidatosLibro09,
                    libro14: candidatosLibro14,
                    libro15: candidatosLibro15
                };
            },

            procesarPaso9(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 9 - OPERACIONES M√öLTIPLES LIBROS AGRUPADAS:
                
                CRITERIOS DE FILTRADO:
                - LIBRO = "03", "09", "14", "15"
                - ESTADO = "Pendiente" (no procesados en pasos anteriores)
                
                ESTRATEGIA ESPEC√çFICA POR BANCO:
                
                BCP (General):
                1. Agrupar por NUMDOC los registros que cumplen criterios
                2. Sumar TOTAL HABER de cada grupo por NUMDOC
                3. Mapear: FDOC del grupo + TOTAL HABER vs FECHA + |MONTO| del Extracto
                
                SANT (Santander) - MAPEO ESPEC√çFICO:
                1. Agrupar en Extracto por FECHA (Columna A)
                2. Sumar Total |IMPORTE| de cada grupo por FECHA
                3. Mapear: FDOC + TOTAL HABER (Mayor) vs FECHA + TOTAL |IMPORTE| (Extracto)
                
                ESTADOS RESULTANTES:
                - "P9 - Conciliada"
                - Mayor: #REF = [Referencia del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del primer registro del grupo
                */
                
                // // // console.log(`üìà PASO 9: Iniciando procesamiento de operaciones M√öLTIPLES LIBROS AGRUPADAS para ${cuentaConfig?.alias || 'cuenta gen√©rica'}`);
                // // // console.log(`üîç Total filas a revisar: ${filasFiltradasMayor.length}`);
                // // // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                // === VERIFICAR SI ES SANTANDER, BBVA O IBK PARA MAPEO ESPEC√çFICO ===
                const esSantander = cuentaConfig && cuentaConfig.alias === 'SANT';
                const esBBVA = cuentaConfig && (cuentaConfig.codigo === '1041201' || cuentaConfig.codigo === '1041202');
                const esIBK = cuentaConfig && cuentaConfig.alias === 'IBK';
                
                // === DEBUG: Bank Detection ===
                // // console.log(`\nüîç PASO 9 - DETECCI√ìN DE BANCO:`);
                // // console.log(`   cuentaConfig:`, cuentaConfig);
                // // console.log(`   cuentaConfig.alias:`, cuentaConfig?.alias);
                // // console.log(`   cuentaConfig.codigo:`, cuentaConfig?.codigo);
                // // console.log(`   esSantander:`, esSantander);
                // // console.log(`   esBBVA:`, esBBVA);
                
                // ‚≠ê FORZAR SANTANDER SI ES CUENTA 1041401
                const esCuentaSantander = cuentaConfig?.codigo === '1041401';
                const esRealmenteSantander = esSantander || esCuentaSantander;
                
                // // console.log(`   esCuentaSantander (por c√≥digo):`, esCuentaSantander);
                // // console.log(`   esRealmenteSantander (final):`, esRealmenteSantander);
                
                if (esRealmenteSantander) {
                    // // console.log(`üè¶ PASO 9: SANTANDER se procesar√° en PASO 12 (despu√©s de ITF)`);
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                } else if (esBBVA) {
                    // // console.log(`üè¶ PASO 9 BBVA: Agrupaci√≥n por comisiones COMISION REC y COMISION RECAUDACION`);
                    return this.procesarPaso9BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (esIBK) {
                    // // console.log(`üè¶ PASO 9 IBK: Agrupaci√≥n por NUMDOC+FECHA con filtros HABER>0 y CARGO<0`);
                    return this.procesarPaso9IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else {
                    // // console.log(`üè¶ PASO 9 BCP: Agrupaci√≥n por NUMDOC en mayor + mapeo FDOC+HABER vs FECHA+MONTO`);
                }
                
                let candidatosLibro03 = 0;
                let candidatosLibro09 = 0;
                let candidatosLibro14 = 0;
                let candidatosLibro15 = 0;
                let gruposFormados = 0;
                let conciliados = 0;
                
                // Libros objetivo del Paso 9
                const librosObjetivo = ['03', '09', '14', '15'];
                
                // Agrupar filas por NUMDOC que cumplan criterios
                const gruposPorNUMDOC = new Map();
                
                // Primera pasada: Identificar candidatos y agrupar por NUMDOC
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const numdoc = filaMayor[idxM.numdoc] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Verificar criterios del PASO 9
                    const esLibroObjetivo = librosObjetivo.includes(String(libro || '').trim());
                    
                    if (esLibroObjetivo) {
                        // Contar por libro
                        if (String(libro || '').trim() === '03') candidatosLibro03++;
                        else if (String(libro || '').trim() === '09') candidatosLibro09++;
                        else if (String(libro || '').trim() === '14') candidatosLibro14++;
                        else if (String(libro || '').trim() === '15') candidatosLibro15++;
                        
                        // Debug: Mostrar los primeros 5 candidatos
                        // if ((candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15) <= 10) {
                        //     // console.log(`üîç Candidato ${candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15}: LIBRO="${libro}", NUMDOC="${numdoc}", FDOC="${fdoc}", HABER=${haber}`);
                        // }
                        
                        // ‚≠ê AGRUPAR POR NUMDOC + FECHA (evitar mezclar fechas diferentes)
                        const numdocNormalizado = this.normalizarTexto(numdoc);
                        const fechaNormalizada = this.normalizarFecha(fdoc);
                        const claveGrupo = `${numdocNormalizado}_${fechaNormalizada}`; // NUMDOC + FECHA
                        
                        if (!gruposPorNUMDOC.has(claveGrupo)) {
                            gruposPorNUMDOC.set(claveGrupo, {
                                numdoc: numdocNormalizado,
                                numdocOriginal: numdoc,
                                fdoc: fdoc, // Usar FDOC del primer registro para mapeo
                                fechaNormalizada: fechaNormalizada,
                                totalHaber: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposPorNUMDOC.get(claveGrupo);
                        grupo.totalHaber += haber;
                        grupo.filas.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            numdoc: numdoc,
                            fdoc: fdoc,
                            haber: haber,
                            comprob: comprob
                        });
                    }
                }
                
                gruposFormados = gruposPorNUMDOC.size;
                const totalCandidatos = candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15;
                
                // // console.log(`üìä PASO 9 - AGRUPACI√ìN:`);
                // // console.log(`   üìã Candidatos LIBRO 03: ${candidatosLibro03}`);
                // // console.log(`   üìó Candidatos LIBRO 09: ${candidatosLibro09}`);
                // // console.log(`   üìò Candidatos LIBRO 14: ${candidatosLibro14}`);
                // // console.log(`   üìô Candidatos LIBRO 15: ${candidatosLibro15}`);
                // // console.log(`   üìö Total candidatos: ${totalCandidatos}`);
                // // console.log(`   üîó Grupos por NUMDOC formados: ${gruposFormados}`);
                
                if (gruposFormados === 0) {
                    // // console.log(`‚ö†Ô∏è No se encontraron grupos para PASO 9`);
                    // // console.log(`   üìã Verificar si las filas tienen LIBRO en ["03", "09", "14", "15"]`);
                    // // console.log(`   üìã Verificar si las filas est√°n marcadas como "Pendiente"`);
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                // ‚úÖ A. GRUPOS ESPEC√çFICOS OBJETIVO
                // // console.log(`\nüìä === GRUPOS ESPEC√çFICOS ===`);
                // // console.log(`üéØ FILTRO ACTIVO: Solo mostrando NUMDOC: 11302, 1113, 11303, 1157, 900013`);
                let contadorGrupo = 104;
                const gruposObjetivoA = ['11302', '1113', '11303', '1157', '900013']; // Solo estos grupos
                for (const [numdocNormalizado, grupo] of gruposPorNUMDOC.entries()) {
                    // Solo mostrar los grupos objetivo espec√≠ficos
                    if (gruposObjetivoA.includes(numdocNormalizado)) {
                        // // console.log(`\nüîó GRUPO ${contadorGrupo}: NUMDOC="${numdocNormalizado}"`);
                        // // console.log(`   üìÖ FDOC: "${grupo.fdoc}" (${this.normalizarFecha(grupo.fdoc)})`);
                        // // console.log(`   üí∞ Total HABER: ${grupo.totalHaber.toFixed(2)}`);
                        // // console.log(`   üìã Filas en grupo: ${grupo.filas.length}`);
                        // grupo.filas.forEach((fila, idx) => {
                        //     // console.log(`     ${idx + 1}. LIBRO="${fila.libro}" | HABER=${fila.haber.toFixed(2)} | COMPROB="${fila.comprob}"`);
                        // });
                        contadorGrupo++;
                    }
                }
                
                // // console.log(`\nüéØ === B. GRUPOS VS EXTRACTO ===`);
                
                // ‚úÖ PASO 9B: BUSCAR MATCHES EN EXTRACTO PARA CADA GRUPO
                contadorGrupo = 104;
                const gruposObjetivo = ['11302', '1113', '11303', '1157', '900013']; // Solo estos grupos
                
                for (const [numdocNormalizado, grupo] of gruposPorNUMDOC.entries()) {
                    // Solo procesar y mostrar logs para los grupos objetivo
                    const esGrupoObjetivo = gruposObjetivo.includes(numdocNormalizado);
                    
                    if (esGrupoObjetivo) {
                        // // console.log(`\nüîç BUSCANDO MATCH PARA GRUPO ${contadorGrupo}: NUMDOC="${numdocNormalizado}"`);
                        // // console.log(`   üìÖ FDOC: "${grupo.fdoc}" ‚Üí "${this.normalizarFecha(grupo.fdoc)}"`);
                        // // console.log(`   üí∞ Total HABER: ${grupo.totalHaber.toFixed(2)}`);
                    }
                    
                    // Buscar match en extracto usando FDOC y TOTAL HABER del grupo
                    const matchExtracto = this.buscarMatchExtractoPorGrupoNUMDOC(grupo.fdoc, grupo.totalHaber, extractoProcesable, idxE, estadosExtracto, esGrupoObjetivo);
                    
                    if (matchExtracto.encontrado) {
                        if (esGrupoObjetivo) {
                            // // console.log(`\n‚úÖ ¬°MATCH ENCONTRADO PARA GRUPO ${contadorGrupo}!`);
                            // // console.log(`   üéØ Extracto √≠ndice: ${matchExtracto.indice}`);
                            // // console.log(`   üìÖ Fechas: "${grupo.fdoc}" ‚Üî "${matchExtracto.fecha}"`);
                            // // console.log(`   üí∞ Montos: ${grupo.totalHaber.toFixed(2)} ‚Üî ${matchExtracto.monto.toFixed(2)}`);
                            // // console.log(`   üè¶ Operaci√≥n #: "${matchExtracto.operacionNumero}"`);
                        }
                        
                        // Asignar estados a todas las filas del grupo
                        const refMayor = matchExtracto.operacionNumero; // N√∫mero de operaci√≥n del extracto
                        const refExtracto = `${grupo.filas[0].libro}-${grupo.filas[0].comprob}`; // Usar primer registro del grupo
                        
                        // // console.log(`   üìù Asignando estado "P9 - Conciliada" a ${grupo.filas.length} filas del grupo:`);
                        
                        // IMPORTANTE: Todas las filas del grupo reciben el MISMO n√∫mero de operaci√≥n del extracto
                        grupo.filas.forEach((item, idx) => {
                            estadosFilas.set(item.indice, {
                                estado: 'P9 - Conciliada',
                                ref: refMayor // Mismo n√∫mero de operaci√≥n para todas las filas del grupo
                            });
                            
                            // // console.log(`     ${idx + 1}. √çndice ${item.indice} ‚Üí REF="${refMayor}"`);
                        });
                        
                        estadosExtracto.set(matchExtracto.indice, {
                            estado: 'P9 - Conciliada',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                        // // console.log(`   ‚úÖ GRUPO ${contadorGrupo} CONCILIADO EXITOSAMENTE`);
                        // // // console.log(`   üîó Grupo NUMDOC: ${numdocNormalizado}, FDOC: ${grupo.fdoc}, Total HABER: ${grupo.totalHaber} (${grupo.filas.length} filas)`);
                        // // // console.log(`   üìã Extracto: FECHA="${matchExtracto.fecha}", MONTO=abs(${matchExtracto.monto}) ‚Üí REF="${refExtracto}"`);
                        // // // console.log(`   üîó TODAS las ${grupo.filas.length} filas del grupo ‚Üí REF="${refMayor}" (Operaci√≥n-N√∫mero del extracto)`);
                        
                        // Debug: Mostrar cada fila del grupo con su REF asignado
                        // grupo.filas.forEach((item, idx) => {
                        //     // // console.log(`      Fila ${idx + 1} (Mayor √≠ndice ${item.indice}): LIBRO=${item.libro}, COMPROB=${item.comprob}, HABER=${item.haber} ‚Üí REF="${refMayor}"`);
                        // });
                    } else {
                        if (esGrupoObjetivo) {
                            // // console.log(`\n‚ùå NO SE ENCONTR√ì MATCH PARA GRUPO ${contadorGrupo}: NUMDOC="${numdocNormalizado}"`);
                            // // console.log(`   ‚ùì Verificar en extracto operaciones del ${this.normalizarFecha(grupo.fdoc)} por ${grupo.totalHaber.toFixed(2)}`);
                        }
                    }
                    
                    // Solo incrementar contador para grupos objetivo (para mantener numeraci√≥n consistente en logs)
                    if (esGrupoObjetivo) {
                        contadorGrupo++;
                    }
                }
                
                // ‚úÖ C. TABLA DE ESTADOS DE GRUPOS (SOLO GRUPOS OBJETIVO)
                // // console.log(`\nüìä === C. TABLA DE ESTADOS DE GRUPOS ===`);
                // // console.log(`‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
                // // console.log(`‚îÇ GRUPO ‚îÇ NUMDOC          ‚îÇ FDOC            ‚îÇ TOTAL HABER  ‚îÇ FILAS       ‚îÇ ESTADO      ‚îÇ`);
                // // console.log(`‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§`);
                
                let gruposConciliados = 0;
                let gruposNoConciliados = 0;
                let numeroGrupo = 104;
                const gruposObjetivoTabla = ['11302', '1113', '11303', '1157', '900013']; // Redefinir para la tabla
                
                for (const [numdocNormalizado, grupo] of gruposPorNUMDOC.entries()) {
                    // Solo mostrar los grupos objetivo espec√≠ficos
                    if (gruposObjetivoTabla.includes(numdocNormalizado)) {
                        // Verificar si el grupo fue conciliado revisando el estado de la primera fila
                        const primeraFila = grupo.filas[0];
                        const estadoPrimeraFila = estadosFilas.get(primeraFila.indice);
                        const estado = estadoPrimeraFila && estadoPrimeraFila.estado === 'P9 - Conciliada' ? '‚úÖ CONCILIADO' : '‚ùå PENDIENTE';
                        
                        if (estado === '‚úÖ CONCILIADO') gruposConciliados++;
                        else gruposNoConciliados++;
                        
                        const grupoPadded = numeroGrupo.toString().padStart(5);
                        const numdocPadded = (numdocNormalizado || '').toString().padEnd(15);
                        const fdocPadded = (grupo.fdoc || '').toString().padEnd(15);
                        const haberPadded = (grupo.totalHaber || 0).toFixed(2).padStart(12);
                        const filasPadded = (grupo.filas?.length || 0).toString().padStart(11);
                        const estadoPadded = (estado || '').toString().padEnd(13);
                        
                        // // console.log(`‚îÇ ${grupoPadded} ‚îÇ ${numdocPadded} ‚îÇ ${fdocPadded} ‚îÇ ${haberPadded} ‚îÇ ${filasPadded} ‚îÇ ${estadoPadded} ‚îÇ`);
                    }
                    numeroGrupo++;
                }
                
                // // console.log(`‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`);
                // // console.log(`üìä RESUMEN: ${gruposConciliados} conciliados, ${gruposNoConciliados} pendientes`);
                // // console.log(`üéØ SOLO MOSTRANDO GRUPOS: ${gruposObjetivoTabla.join(', ')}`);
                
                return {
                    candidatos: totalCandidatos,
                    grupos: gruposFormados,
                    conciliados: conciliados,
                    libro03: candidatosLibro03,
                    libro09: candidatosLibro09,
                    libro14: candidatosLibro14,
                    libro15: candidatosLibro15
                };
            },

            procesarPaso9Santander(filasFiltradasMayor, extractoProcesable, idxM, estadosFilas, estadosExtracto) {
                /*
                PASO 9 SANTANDER - AGRUPACI√ìN POR FECHA:
                
                ESTRATEGIA ESPEC√çFICA:
                1. Agrupar por FECHA en Mayor: FDOC de LIBRO "03", "09", "14", "15"
                2. Agrupar por FECHA en Extracto: Columna A
                3. Mapear: FECHA + TOTAL HABER (Mayor) vs FECHA + TOTAL |IMPORTE| (Extracto)
                4. Numerar grupos y usar n√∫mero como #REF
                
                ESTADOS RESULTANTES:
                - "P9 - Conciliada"
                - Mayor: #REF = "GRUPO-[N]"
                - Extracto: #REF = "GRUPO-[N]"
                */
                
                // // console.log(`\nüè¶ *** SANT PASO 9 INICIADO *** - Agrupaci√≥n por FECHA en Mayor y Extracto`);
                // // console.log(`üìã IMPORTANTE: Mayor se agrupa por FDOC (fecha), NO por NUMDOC`);
                // // console.log(`üìã Total registros Mayor disponibles: ${filasFiltradasMayor.length}`);
                // // console.log(`üìã Total registros Extracto disponibles: ${extractoProcesable.length}`);
                // // console.log(`üìã Estados ya procesados Mayor: ${estadosFilas.size}`);
                // // console.log(`üìã Estados ya procesados Extracto: ${estadosExtracto.size}`);
                
                // === üî¨ TEST DE NORMALIZACI√ìN DE FECHAS ===
                // === üî¨ TEST DE NORMALIZACI√ìN DE FECHAS Y VERIFICACI√ìN COLUMNA L ===
                // // console.log(`\nüî¨ === TEST DE NORMALIZACI√ìN DE FECHAS ===`);
                // // console.log(`üìÖ Mayor: "6/6/2025" ‚Üí "${this.normalizarFecha('6/6/2025')}"`);
                // // console.log(`üìÖ SANT: "06/06/2025" ‚Üí "${this.normalizarFecha('06/06/2025')}"`);
                // // console.log(`üìÖ Mayor: "13/6/2025" ‚Üí "${this.normalizarFecha('13/6/2025')}"`);
                // // console.log(`üìÖ SANT: "13/06/2025" ‚Üí "${this.normalizarFecha('13/06/2025')}"`);
                // // console.log(`üìÖ Mayor: "20/6/2025" ‚Üí "${this.normalizarFecha('20/6/2025')}"`);
                // // console.log(`üìÖ SANT: "20/06/2025" ‚Üí "${this.normalizarFecha('20/06/2025')}"`);
                // // console.log(`üìÖ Mayor: "27/6/2025" ‚Üí "${this.normalizarFecha('27/6/2025')}"`);
                // // console.log(`üìÖ SANT: "27/06/2025" ‚Üí "${this.normalizarFecha('27/06/2025')}"`);
                
                const coincide06 = this.normalizarFecha('6/6/2025') === this.normalizarFecha('06/06/2025');
                const coincide13 = this.normalizarFecha('13/6/2025') === this.normalizarFecha('13/06/2025');
                const coincide20 = this.normalizarFecha('20/6/2025') === this.normalizarFecha('20/06/2025');
                const coincide27 = this.normalizarFecha('27/6/2025') === this.normalizarFecha('27/06/2025');
                
                // // console.log(`üéØ COINCIDENCIAS: 06/06=${coincide06 ? '‚úÖ' : '‚ùå'}, 13/06=${coincide13 ? '‚úÖ' : '‚ùå'}, 20/06=${coincide20 ? '‚úÖ' : '‚ùå'}, 27/06=${coincide27 ? '‚úÖ' : '‚ùå'}`);
                
                // === üîç VERIFICACI√ìN ESPEC√çFICA REGISTROS SANT DISPONIBLES ===
                // // console.log(`\nüîç === VERIFICACI√ìN EXTRACTO SANT (solo registros disponibles) ===`);
                const registrosDisponibles = extractoProcesable ? extractoProcesable.filter((_, i) => !estadosExtracto.has(i)) : [];
                const registrosYaProcesados = extractoProcesable ? extractoProcesable.length - registrosDisponibles.length : 0;
                // // console.log(`üìä Total registros SANT en archivo: ${extractoProcesable ? extractoProcesable.length : 0}`);
                // // console.log(`üîí Registros ya procesados (pasos anteriores): ${registrosYaProcesados}`);
                // // console.log(`üÜì Registros disponibles para Paso 9: ${registrosDisponibles.length}`);
                
                // DEBUG: Resumen de estados del extracto SANT
                const estadosEnExtracto = {};
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) {
                        const estado = estadosExtracto.get(i).estado;
                        estadosEnExtracto[estado] = (estadosEnExtracto[estado] || 0) + 1;
                    } else {
                        estadosEnExtracto['Pendiente'] = (estadosEnExtracto['Pendiente'] || 0) + 1;
                    }
                }
                // // console.log(`üìä RESUMEN ESTADOS EXTRACTO SANT:`);
                for (const [estado, cantidad] of Object.entries(estadosEnExtracto)) {
                    // // console.log(`   ${estado}: ${cantidad} registros`);
                }
                
                // DEBUG: Resumen de estados del Mayor
                const estadosEnMayor = {};
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) {
                        const estado = estadosFilas.get(i).estado;
                        estadosEnMayor[estado] = (estadosEnMayor[estado] || 0) + 1;
                    } else {
                        estadosEnMayor['Pendiente'] = (estadosEnMayor['Pendiente'] || 0) + 1;
                    }
                }
                // // console.log(`üìä RESUMEN ESTADOS MAYOR SANT:`);
                for (const [estado, cantidad] of Object.entries(estadosEnMayor)) {
                    // // console.log(`   ${estado}: ${cantidad} registros`);
                }
                
                let candidatosLibro03 = 0;
                let candidatosLibro09 = 0;
                let candidatosLibro14 = 0;
                let candidatosLibro15 = 0;
                let gruposFormados = 0;
                let conciliados = 0;
                
                // Libros objetivo del Paso 9
                const librosObjetivo = ['03', '09', '14', '15'];
                
                // === 1. AGRUPAR POR FECHA EN MAYOR ===
                const gruposPorFechaMayor = new Map();
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // ‚≠ê VERIFICAR ESTADO = "Pendiente" O VAC√çO (INICIAL)
                    const estadoCol = String(filaMayor[filaMayor.length - 2] || ''); // Convertir a string
                    const esPendiente = estadoCol.trim() === 'Pendiente' || estadoCol.trim() === '';
                    
                    if (!esPendiente) {
                        if ((candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15) <= 5) {
                            // // console.log(`üîç SALTANDO registro ${i}: ESTADO="${estadoCol}" (no es Pendiente ni vac√≠o), LIBRO="${libro}", FDOC="${fdoc}"`);
                        }
                        continue;
                    }
                    
                    // üîç DEBUG: Mostrar registros que S√ç se procesan con DETALLE COMPLETO
                    if ((candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15) <= 10) {
                        const numdoc = filaMayor[idxM.numdoc] || '';
                        const glosa = (filaMayor[idxM.glosa] || '').substring(0, 30);
                        // // console.log(`‚úÖ MAYOR PROCESANDO ${candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15}: ESTADO="${estadoCol}", LIBRO="${libro}", FDOC="${fdoc}", HABER=${haber}, NUMDOC="${numdoc}", GLOSA="${glosa}..."`);
                    }
                    
                    // Verificar criterios del PASO 9
                    const esLibroObjetivo = librosObjetivo.includes(String(libro || '').trim());
                    
                    if (esLibroObjetivo) {
                        // Contar por libro
                        if (String(libro || '').trim() === '03') candidatosLibro03++;
                        else if (String(libro || '').trim() === '09') candidatosLibro09++;
                        else if (String(libro || '').trim() === '14') candidatosLibro14++;
                        else if (String(libro || '').trim() === '15') candidatosLibro15++;
                        
                        // ‚≠ê AGRUPAR POR FECHA (FDOC) - CORRECCI√ìN PRINCIPAL
                        const fechaMayorNormalizada = this.normalizarFecha(fdoc);
                        
                        // üîç DEBUG ESPEC√çFICO PARA FECHAS PROBLEM√ÅTICAS
                        if (fdoc === '6/6/2025' || fdoc === '13/6/2025' || fdoc === '20/6/2025' || fdoc === '27/6/2025') {
                            // // console.log(`üîç DEBUG FECHA MAYOR: "${fdoc}" ‚Üí "${fechaMayorNormalizada}" (LIBRO=${libro}, HABER=${haber})`);
                        }
                        
                        if (fechaMayorNormalizada) {
                            if (!gruposPorFechaMayor.has(fechaMayorNormalizada)) {
                                gruposPorFechaMayor.set(fechaMayorNormalizada, {
                                    fecha: fechaMayorNormalizada,
                                    fechaOriginal: fdoc,
                                    totalHaber: 0,
                                    filas: [],
                                    primerComprob: comprob,
                                    primerLibro: libro
                                });
                            }
                            
                            const grupo = gruposPorFechaMayor.get(fechaMayorNormalizada);
                            grupo.totalHaber += haber;
                            grupo.filas.push(i);
                            
                            // Mostrar ejemplos de los primeros 10 registros agregados a grupos
                            if ((candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15) <= 10) {
                                const numdoc = filaMayor[idxM.numdoc] || '';
                                const glosa = (filaMayor[idxM.glosa] || '').substring(0, 25);
                                // // console.log(`üìù AGREGADO A GRUPO MAYOR ${candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15}: FECHA="${fdoc}"‚Üí"${fechaMayorNormalizada}", LIBRO="${libro}", HABER=${haber}, NUMDOC="${numdoc}", GLOSA="${glosa}..."`);
                            }
                        }
                    }
                }
                
                const gruposMayorFormados = gruposPorFechaMayor.size;
                const totalCandidatos = candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15;
                
                // // console.log(`üè¶ SANT PASO 9 - AGRUPACI√ìN MAYOR: ${gruposMayorFormados} grupos por FECHA formados`);
                
                if (gruposMayorFormados === 0) {
                    // // console.log(`‚ö†Ô∏è SANT: No se encontraron grupos de fechas en Mayor para PASO 9`);
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                // === 2. AGRUPAR POR FECHA EN EXTRACTO SANTANDER ===
                const gruposPorFechaExtracto = new Map();
                let registrosSaltadosSinDatos = 0;
                let registrosProcesadosEnExtracto = 0;
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // === MAPEO ESPEC√çFICO SANTANDER ===
                    // Columna A (√≠ndice 0): Fecha
                    // Columna G (√≠ndice 6): Importe
                    const fechaExtracto = filaExtracto[0] || '';
                    const importeExtracto = filaExtracto[6] || '0';
                    
                    // ‚≠ê VERIFICAR QUE TENGA DATOS REALES
                    const tieneFecha = fechaExtracto && fechaExtracto.toString().trim() !== '';
                    const tieneImporte = importeExtracto && importeExtracto.toString().trim() !== '' && importeExtracto.toString() !== '0';
                    const tieneDatosReales = tieneFecha && tieneImporte;
                    
                    // SALTAR SI NO TIENE DATOS REALES
                    if (!tieneDatosReales) {
                        registrosSaltadosSinDatos++;
                        continue;
                    }
                    
                    // ‚≠ê EL REGISTRO YA FUE PROCESADO EN PASOS ANTERIORES (verificado arriba con estadosExtracto.has(i))
                    // NO necesitamos verificar columna L porque los estados se guardan en estadosExtracto Map
                    
                    // üîç DEBUG SOLO PARA REGISTROS QUE REALMENTE SE PROCESAN
                    if (registrosProcesadosEnExtracto <= 15) {
                        const referencia = filaExtracto[3] || '';
                        const descripcion = (filaExtracto[4] || '').substring(0, 20);
                        // // console.log(`‚úÖ PROCESANDO SANT ${i}: FECHA="${fechaExtracto}", IMPORTE="${importeExtracto}", REF="${referencia}", DESC="${descripcion}..."`);
                    }
                    
                    registrosProcesadosEnExtracto++;
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                    const montoExtractoAbs = Math.abs(this.normalizarMonto(importeExtracto));
                    
                    // üîç DEBUG ESPEC√çFICO PARA FECHAS SANT PROBLEM√ÅTICAS
                    if (fechaExtracto === '06/06/2025' || fechaExtracto === '13/06/2025' || fechaExtracto === '20/06/2025' || fechaExtracto === '27/06/2025') {
                        // // console.log(`üîç DEBUG FECHA SANT: "${fechaExtracto}" ‚Üí "${fechaExtractoNormalizada}" (IMPORTE=${importeExtracto}‚Üí${montoExtractoAbs})`);
                    }
                    
                    if (fechaExtractoNormalizada && montoExtractoAbs > 0) {
                        if (!gruposPorFechaExtracto.has(fechaExtractoNormalizada)) {
                            gruposPorFechaExtracto.set(fechaExtractoNormalizada, {
                                fecha: fechaExtractoNormalizada,
                                totalImporte: 0,
                                filas: [],
                                fechaOriginal: fechaExtracto
                            });
                        }
                        
                        const grupo = gruposPorFechaExtracto.get(fechaExtractoNormalizada);
                        grupo.totalImporte += montoExtractoAbs;
                        grupo.filas.push(i);
                        
                        // Debug de grupos formados (solo primeros 5 grupos)
                        if (gruposPorFechaExtracto.size <= 5) {
                            // // console.log(`üìù AGREGADO A GRUPO SANT: FECHA="${fechaExtracto}"‚Üí"${fechaExtractoNormalizada}", IMPORTE=${importeExtracto}‚Üí${montoExtractoAbs}`);
                        }
                    }
                }
                
                const gruposExtractoFormados = gruposPorFechaExtracto.size;
                // // console.log(`üè¶ SANT PASO 9 - AGRUPACI√ìN EXTRACTO: ${gruposExtractoFormados} grupos por FECHA formados`);
                
                // === üìä RESUMEN DE PROCESAMIENTO SANT ===
                // // console.log(`\nüìä RESUMEN PROCESAMIENTO SANT:`);
                // // console.log(`   üìã Total registros en archivo SANT: ${extractoProcesable.length}`);
                // // console.log(`   ‚è≠Ô∏è Saltados ya procesados (pasos anteriores): ${extractoProcesable.length - registrosSaltadosSinDatos - registrosProcesadosEnExtracto}`);
                // // console.log(`   ‚è≠Ô∏è Saltados sin datos reales: ${registrosSaltadosSinDatos}`);
                // // console.log(`   ‚úÖ Registros PENDIENTES procesados: ${registrosProcesadosEnExtracto}`);
                // // console.log(`======================================`);
                
                // === üìä TABLA DE COMPARACI√ìN MAYOR VS SANT (SOLO PARA DEBUG) ===
                // // console.log(`\nüìä === TABLA DE COMPARACI√ìN GRUPOS MAYOR VS SANT (CON ESTADOS) ===`);
                // // console.log(`‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
                // // console.log(`‚îÇ    FECHA   ‚îÇ  MAYOR FDOC ‚îÇ MAYOR HABER ‚îÇ SANT FECHA ‚îÇ SANT IMPORTE‚îÇ   STATUS    ‚îÇ DIFERENC‚îÇ`);
                // // console.log(`‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§`);
                
                // Obtener todas las fechas √∫nicas (de ambos lados)
                const todasFechas = new Set([
                    ...Array.from(gruposPorFechaMayor.keys()),
                    ...Array.from(gruposPorFechaExtracto.keys())
                ]);
                
                for (const fecha of Array.from(todasFechas).sort()) {
                    const grupoMayor = gruposPorFechaMayor.get(fecha);
                    const grupoSant = gruposPorFechaExtracto.get(fecha);
                    
                    const fechaCol = (fecha || '').toString().padEnd(10);
                    const mayorFdoc = grupoMayor ? (grupoMayor.fechaOriginal || '').toString().padEnd(11) : ''.padEnd(11);
                    const mayorHaber = grupoMayor ? (grupoMayor.totalHaber || 0).toFixed(2).padStart(11) : ''.padStart(11);
                    const santFecha = grupoSant ? (grupoSant.fechaOriginal || '').toString().padEnd(10) : ''.padEnd(10);
                    const santImporte = grupoSant ? (grupoSant.totalImporte || 0).toFixed(2).padStart(11) : ''.padStart(11);
                    
                    let status = '';
                    let diferencia = '';
                    
                    if (grupoMayor && grupoSant) {
                        const diff = Math.abs(grupoMayor.totalHaber - grupoSant.totalImporte);
                        const coincide = diff < 0.01;
                        status = coincide ? '‚úÖ MATCH' : '‚ùå DIFF';
                        diferencia = diff.toFixed(2);
                    } else if (grupoMayor && !grupoSant) {
                        status = 'üî∏ SOLO MAYOR';
                        diferencia = '---';
                    } else if (!grupoMayor && grupoSant) {
                        status = 'üîπ SOLO SANT';
                        diferencia = '---';
                    }
                    
                    status = status.padEnd(11);
                    diferencia = diferencia.padStart(7);
                    
                    // // console.log(`‚îÇ ${fechaCol} ‚îÇ ${mayorFdoc} ‚îÇ ${mayorHaber} ‚îÇ ${santFecha} ‚îÇ ${santImporte} ‚îÇ ${status} ‚îÇ ${diferencia} ‚îÇ`);
                }
                
                // // console.log(`‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`);
                // // console.log(`üìä Grupos Mayor: ${gruposMayorFormados} | Grupos SANT: ${gruposExtractoFormados}`);
                
                // === üîç DEBUG DETALLADO: CONTENIDO DE CADA GRUPO ===
                // // console.log(`\nüîç === DETALLE COMPLETO DE GRUPOS FORMADOS ===`);
                
                // // console.log(`\nüìã DETALLE GRUPOS MAYOR:`);
                for (const [fecha, grupo] of gruposPorFechaMayor) {
                    // // console.log(`  üóìÔ∏è GRUPO FECHA ${fecha}: ${grupo.filas.length} registros, TOTAL HABER: ${grupo.totalHaber.toFixed(2)}`);
                    for (let i = 0; i < Math.min(3, grupo.filas.length); i++) {
                        const indice = grupo.filas[i];
                        const fila = filasFiltradasMayor[indice];
                        const estadoMayor = estadosFilas.has(indice) ? estadosFilas.get(indice).estado : 'Pendiente';
                        const numdoc = fila[idxM.numdoc] || '';
                        const glosa = (fila[idxM.glosa] || '').substring(0, 20);
                        // // console.log(`     ‚Ä¢ Reg ${i+1}: NUMDOC="${numdoc}", HABER=${this.normalizarMonto(fila[idxM.haber])}, ESTADO_MAYOR="${estadoMayor}", GLOSA="${glosa}..."`);
                    }
                    if (grupo.filas.length > 3) {
                        // // console.log(`     ... y ${grupo.filas.length - 3} registros m√°s`);
                    }
                }
                
                // // console.log(`\nüìã DETALLE GRUPOS SANT:`);
                for (const [fecha, grupo] of gruposPorFechaExtracto) {
                    // // console.log(`  üóìÔ∏è GRUPO FECHA ${fecha}: ${grupo.filas.length} registros, TOTAL IMPORTE: ${grupo.totalImporte.toFixed(2)}`);
                    for (let i = 0; i < Math.min(3, grupo.filas.length); i++) {
                        const indice = grupo.filas[i];
                        const item = extractoProcesable[indice];
                        const fila = item.fila;
                        const estadoSant = estadosExtracto.has(indice) ? estadosExtracto.get(indice).estado : 'Pendiente';
                        const referencia = fila[3] || '';
                        const importe = fila[6] || '';
                        // // console.log(`     ‚Ä¢ Reg ${i+1}: REF="${referencia}", IMPORTE=${importe}, ESTADO_SANT="${estadoSant}"`);
                    }
                    if (grupo.filas.length > 3) {
                        // // console.log(`     ... y ${grupo.filas.length - 3} registros m√°s`);
                    }
                }
                // // console.log(`===============================================`);
                
                // === MOSTRAR TABLA DE GRUPOS MAYOR ===
                // // console.log(`\nüìÖ TABLA GRUPOS MAYOR:`);
                // // console.log(`‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
                // // console.log(`‚îÇ    FECHA   ‚îÇ FECHA ORIG  ‚îÇ   HABER   ‚îÇ  FILAS  ‚îÇ`);
                // // console.log(`‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§`);
                
                for (const [fecha, grupo] of gruposPorFechaMayor) {
                    const fechaOrig = (grupo.fechaOriginal || '').toString().padEnd(11);
                    const fechaNorm = (fecha || '').toString().padEnd(10);
                    const haber = (grupo.totalHaber || 0).toFixed(2).padStart(9);
                    const filas = (grupo.filas?.length || 0).toString().padStart(7);
                    // // console.log(`‚îÇ ${fechaNorm} ‚îÇ ${fechaOrig} ‚îÇ ${haber} ‚îÇ ${filas} ‚îÇ`);
                }
                // // console.log(`‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`);
                
                // === MOSTRAR TABLA DE GRUPOS EXTRACTO ===
                // // console.log(`\nüìÖ TABLA GRUPOS EXTRACTO:`);
                // // console.log(`‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
                // // console.log(`‚îÇ    FECHA   ‚îÇ FECHA ORIG  ‚îÇ  IMPORTE  ‚îÇ  FILAS  ‚îÇ`);
                // // console.log(`‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§`);
                
                for (const [fecha, grupo] of gruposPorFechaExtracto) {
                    const fechaOrig = (grupo.fechaOriginal || '').toString().padEnd(11);
                    const fechaNorm = (fecha || '').toString().padEnd(10);
                    const importe = (grupo.totalImporte || 0).toFixed(2).padStart(9);
                    const filas = (grupo.filas?.length || 0).toString().padStart(7);
                    // // console.log(`‚îÇ ${fechaNorm} ‚îÇ ${fechaOrig} ‚îÇ ${importe} ‚îÇ ${filas} ‚îÇ`);
                }
                // // console.log(`‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`);
                
                // === 3. MAPEAR GRUPOS POR FECHA Y MONTO ===
                let numeroGrupo = 1;
                
                for (const [fechaMayor, grupoMayor] of gruposPorFechaMayor) {
                    // üîç DEBUG B√öSQUEDA DE MAPEO
                    // // console.log(`üîç BUSCANDO MAPEO: Fecha Mayor="${fechaMayor}", ¬øExiste en Extracto? ${gruposPorFechaExtracto.has(fechaMayor) ? '‚úÖ' : '‚ùå'}`);
                    
                    if (gruposPorFechaExtracto.has(fechaMayor)) {
                        const grupoExtracto = gruposPorFechaExtracto.get(fechaMayor);
                        
                        // Verificar si montos coinciden
                        const diferencia = Math.abs(grupoMayor.totalHaber - grupoExtracto.totalImporte);
                        const montosCoinciden = diferencia < 0.01; // Tolerancia para decimales
                        
                        // // console.log(`üîç COMPARANDO MONTOS: Mayor=${grupoMayor.totalHaber.toFixed(2)} vs SANT=${grupoExtracto.totalImporte.toFixed(2)}, Diferencia=${diferencia.toFixed(4)}, ¬øCoinciden? ${montosCoinciden ? '‚úÖ' : '‚ùå'}`);
                        
                        if (montosCoinciden) {
                            // ‚≠ê USAR N√öMERO DE GRUPO COMO REFERENCIA
                            const refGrupo = `GRUPO-${numeroGrupo}`;
                            
                            // // console.log(`‚úÖ SANT MATCH GRUPO ${numeroGrupo}: FECHA="${fechaMayor}", HABER=${grupoMayor.totalHaber}, IMPORTE=${grupoExtracto.totalImporte}`);
                            
                            // Marcar todas las filas del grupo Mayor como conciliadas
                            for (const indiceMayor of grupoMayor.filas) {
                                estadosFilas.set(indiceMayor, {
                                    estado: 'P9 - Conciliada',
                                    ref: refGrupo
                                });
                            }
                            
                            // Marcar todas las filas del grupo Extracto como conciliadas
                            for (const indiceExtracto of grupoExtracto.filas) {
                                estadosExtracto.set(indiceExtracto, {
                                    estado: 'P9 - Conciliada',
                                    ref: refGrupo
                                });
                            }
                            
                            conciliados++;
                            numeroGrupo++;
                        } else {
                            // // console.log(`‚ùå MONTOS NO COINCIDEN: Fecha="${fechaMayor}", diferencia de ${diferencia.toFixed(2)}`);
                        }
                    } else {
                        // // console.log(`‚ùå FECHA NO ENCONTRADA EN EXTRACTO: "${fechaMayor}"`);
                    }
                }
                
                // // console.log(`\nüè¶ SANT PASO 9 COMPLETADO: ${conciliados} grupos conciliados con numeraci√≥n`);
                
                // === TABLA RESUMEN FINAL ===
                // // console.log(`\nüìä RESUMEN FINAL PASO 9 SANT:`);
                // // console.log(`‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
                // // console.log(`‚îÇ       CONCEPTO      ‚îÇ  VALOR  ‚îÇ`);
                // // console.log(`‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§`);
                // // console.log(`‚îÇ Candidatos Mayor    ‚îÇ ${totalCandidatos.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Grupos Mayor        ‚îÇ ${gruposMayorFormados.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Grupos Extracto     ‚îÇ ${gruposExtractoFormados.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Grupos Conciliados  ‚îÇ ${conciliados.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`);
                
                return {
                    candidatos: totalCandidatos,
                    grupos: Math.max(gruposMayorFormados, gruposExtractoFormados),
                    conciliados: conciliados,
                    libro03: candidatosLibro03,
                    libro09: candidatosLibro09,
                    libro14: candidatosLibro14,
                    libro15: candidatosLibro15
                };
            },

            procesarPaso12Santander(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 12 SANTANDER - AGRUPACI√ìN POR FECHA (DESPU√âS DE ITF):
                
                ESTRATEGIA ESPEC√çFICA:
                1. Agrupar por FECHA en Mayor: FDOC de LIBRO "03", "09", "14", "15"
                2. Agrupar por FECHA en Extracto: Columna A
                3. Mapear: FECHA + TOTAL HABER (Mayor) vs FECHA + TOTAL |IMPORTE| (Extracto)
                4. Numerar grupos y usar n√∫mero como #REF
                
                IMPORTANTE: Se ejecuta DESPU√âS del Paso 11 (ITF) para saltar registros ya conciliados
                
                ESTADOS RESULTANTES:
                - "P12 - Conciliada"
                - Mayor: #REF = "GRUPO-[N]"
                - Extracto: #REF = "GRUPO-[N]"
                */
                
                // ‚≠ê VERIFICAR QUE ES SANTANDER (PEN o USD)
                const esSantander = cuentaConfig && (cuentaConfig.codigo === '1041401' || cuentaConfig.codigo === '1041402');
                
                if (!esSantander) {
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                // Diagn√≥stico espec√≠fico para SANT.USD
                const esSANTUSD = cuentaConfig && cuentaConfig.codigo === '1041402';
                if (esSANTUSD) {
                    console.log(`üè¶ DIAGN√ìSTICO SANT.USD - PASO 12:`);
                    console.log(`   Total filas Mayor: ${filasFiltradasMayor.length}`);
                    console.log(`   Cuenta configurada: ${cuentaConfig.codigo} (${cuentaConfig.alias})`);
                    console.log(`   Estrategia: Agrupar por FECHA - FDOC (Mayor) vs FECHA (Extracto)`);
                }
                
                // // console.log(`\nüè¶ *** SANT PASO 12 INICIADO *** - Agrupaci√≥n por FECHA (despu√©s de ITF)`);
                // // console.log(`üìã IMPORTANTE: Mayor se agrupa por FDOC (fecha), NO por NUMDOC`);
                // // console.log(`üìã Total registros Mayor disponibles: ${filasFiltradasMayor.length}`);
                // // console.log(`üìã Total registros Extracto disponibles: ${extractoProcesable.length}`);
                // // console.log(`üìã Estados ya procesados Mayor: ${estadosFilas.size}`);
                // // console.log(`üìã Estados ya procesados Extracto: ${estadosExtracto.size}`);
                
                // === üî¨ TEST DE NORMALIZACI√ìN DE FECHAS Y VERIFICACI√ìN COLUMNA L ===
                // // console.log(`\nüî¨ === TEST DE NORMALIZACI√ìN DE FECHAS ===`);
                // // console.log(`üìÖ Mayor: "6/6/2025" ‚Üí "${this.normalizarFecha('6/6/2025')}"`);
                // // console.log(`üìÖ SANT: "06/06/2025" ‚Üí "${this.normalizarFecha('06/06/2025')}"`);
                // // console.log(`üìÖ Mayor: "13/6/2025" ‚Üí "${this.normalizarFecha('13/6/2025')}"`);
                // // console.log(`üìÖ SANT: "13/06/2025" ‚Üí "${this.normalizarFecha('13/06/2025')}"`);
                // // console.log(`üìÖ Mayor: "20/6/2025" ‚Üí "${this.normalizarFecha('20/6/2025')}"`);
                // // console.log(`üìÖ SANT: "20/06/2025" ‚Üí "${this.normalizarFecha('20/06/2025')}"`);
                // // console.log(`üìÖ Mayor: "27/6/2025" ‚Üí "${this.normalizarFecha('27/6/2025')}"`);
                // // console.log(`üìÖ SANT: "27/06/2025" ‚Üí "${this.normalizarFecha('27/06/2025')}"`);
                
                const coincide06 = this.normalizarFecha('6/6/2025') === this.normalizarFecha('06/06/2025');
                const coincide13 = this.normalizarFecha('13/6/2025') === this.normalizarFecha('13/06/2025');
                const coincide20 = this.normalizarFecha('20/6/2025') === this.normalizarFecha('20/06/2025');
                const coincide27 = this.normalizarFecha('27/6/2025') === this.normalizarFecha('27/06/2025');
                
                // // console.log(`üéØ COINCIDENCIAS: 06/06=${coincide06 ? '‚úÖ' : '‚ùå'}, 13/06=${coincide13 ? '‚úÖ' : '‚ùå'}, 20/06=${coincide20 ? '‚úÖ' : '‚ùå'}, 27/06=${coincide27 ? '‚úÖ' : '‚ùå'}`);
                
                // === üîç VERIFICACI√ìN ESPEC√çFICA REGISTROS SANT DISPONIBLES ===
                // // console.log(`\nüîç === VERIFICACI√ìN EXTRACTO SANT (solo registros disponibles) ===`);
                const registrosDisponibles = extractoProcesable ? extractoProcesable.filter((_, i) => !estadosExtracto.has(i)) : [];
                const registrosYaProcesados = extractoProcesable ? extractoProcesable.length - registrosDisponibles.length : 0;
                // // console.log(`üìä Total registros SANT en archivo: ${extractoProcesable ? extractoProcesable.length : 0}`);
                // // console.log(`üîí Registros ya procesados (pasos anteriores): ${registrosYaProcesados}`);
                // // console.log(`üÜì Registros disponibles para Paso 12: ${registrosDisponibles.length}`);
                
                // DEBUG: Resumen de estados del extracto SANT
                const estadosEnExtracto = {};
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) {
                        const estado = estadosExtracto.get(i).estado;
                        estadosEnExtracto[estado] = (estadosEnExtracto[estado] || 0) + 1;
                    } else {
                        estadosEnExtracto['Pendiente'] = (estadosEnExtracto['Pendiente'] || 0) + 1;
                    }
                }
                // // console.log(`üìä RESUMEN ESTADOS EXTRACTO SANT:`);
                for (const [estado, cantidad] of Object.entries(estadosEnExtracto)) {
                    // // console.log(`   ${estado}: ${cantidad} registros`);
                }
                
                // DEBUG: Resumen de estados del Mayor
                const estadosEnMayor = {};
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) {
                        const estado = estadosFilas.get(i).estado;
                        estadosEnMayor[estado] = (estadosEnMayor[estado] || 0) + 1;
                    } else {
                        estadosEnMayor['Pendiente'] = (estadosEnMayor['Pendiente'] || 0) + 1;
                    }
                }
                // // console.log(`üìä RESUMEN ESTADOS MAYOR SANT:`);
                for (const [estado, cantidad] of Object.entries(estadosEnMayor)) {
                    // // console.log(`   ${estado}: ${cantidad} registros`);
                }
                
                let candidatosLibro03 = 0;
                let candidatosLibro09 = 0;
                let candidatosLibro14 = 0;
                let candidatosLibro15 = 0;
                let totalCandidatos = 0;
                
                // === 1. AGRUPAR POR FECHA EN MAYOR ===
                const gruposPorFechaMayor = new Map();
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // ‚≠ê VERIFICAR ESTADO = "Pendiente" O VAC√çO (INICIAL)
                    const estadoCol = String(filaMayor[filaMayor.length - 2] || ''); // Convertir a string
                    const esPendiente = estadoCol.trim() === 'Pendiente' || estadoCol.trim() === '';
                    
                    if (!esPendiente) {
                        continue; // Saltar si no es pendiente
                    }
                    
                    // Verificar criterios SANTANDER: LIBRO en 03, 09, 14, 15
                    const esLibroObjetivo = ['03', '09', '14', '15'].includes(String(libro || '').trim());
                    
                    if (!esLibroObjetivo) continue;
                    
                    totalCandidatos++;
                    
                    // Contadores por libro
                    if (String(libro || '').trim() === '03') candidatosLibro03++;
                    else if (String(libro || '').trim() === '09') candidatosLibro09++;
                    else if (String(libro || '').trim() === '14') candidatosLibro14++;
                    else if (String(libro || '').trim() === '15') candidatosLibro15++;
                    
                    // Normalizar fecha para agrupaci√≥n
                    const fechaNormalizada = this.normalizarFecha(fdoc);
                    
                    if (!gruposPorFechaMayor.has(fechaNormalizada)) {
                        gruposPorFechaMayor.set(fechaNormalizada, {
                            fechaOriginal: fdoc,
                            totalHaber: 0,
                            filas: []
                        });
                    }
                    
                    const grupo = gruposPorFechaMayor.get(fechaNormalizada);
                    grupo.totalHaber += haber;
                    grupo.filas.push(i);
                }
                
                const gruposMayorFormados = gruposPorFechaMayor.size;
                
                // // console.log(`üè¶ SANT PASO 12 - AGRUPACI√ìN MAYOR: ${gruposMayorFormados} grupos por FECHA formados`);
                
                if (gruposMayorFormados === 0) {
                    // // console.log(`‚ö†Ô∏è SANT: No se encontraron grupos de fechas en Mayor para PASO 12`);
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                // === 2. AGRUPAR POR FECHA EN EXTRACTO SANTANDER ===
                const gruposPorFechaExtracto = new Map();
                let registrosSaltadosSinDatos = 0;
                let registrosProcesadosEnExtracto = 0;
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // === MAPEO ESPEC√çFICO SANTANDER ===
                    // Columna A (√≠ndice 0): Fecha
                    // Columna G (√≠ndice 6): Importe
                    const fechaExtracto = filaExtracto[0] || '';
                    const importeExtracto = filaExtracto[6] || '0';
                    
                    // ‚≠ê VERIFICAR QUE TENGA DATOS REALES
                    const tieneFecha = fechaExtracto && fechaExtracto.toString().trim() !== '';
                    const tieneImporte = importeExtracto && importeExtracto.toString().trim() !== '' && importeExtracto.toString() !== '0';
                    const tieneDatosReales = tieneFecha && tieneImporte;
                    
                    // SALTAR SI NO TIENE DATOS REALES
                    if (!tieneDatosReales) {
                        registrosSaltadosSinDatos++;
                        continue;
                    }
                    
                    // ‚≠ê EL REGISTRO YA FUE PROCESADO EN PASOS ANTERIORES (verificado arriba con estadosExtracto.has(i))
                    // NO necesitamos verificar columna L porque los estados se guardan en estadosExtracto Map
                    
                    // üîç DEBUG SOLO PARA REGISTROS QUE REALMENTE SE PROCESAN
                    if (registrosProcesadosEnExtracto <= 15) {
                        const referencia = filaExtracto[3] || '';
                        const descripcion = (filaExtracto[4] || '').substring(0, 20);
                        // // console.log(`‚úÖ PROCESANDO SANT ${i}: FECHA="${fechaExtracto}", IMPORTE="${importeExtracto}", REF="${referencia}", DESC="${descripcion}..."`);
                    }
                    
                    registrosProcesadosEnExtracto++;
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                    const montoExtractoAbs = Math.abs(this.normalizarMonto(importeExtracto));
                    
                    if (!gruposPorFechaExtracto.has(fechaExtractoNormalizada)) {
                        gruposPorFechaExtracto.set(fechaExtractoNormalizada, {
                            fechaOriginal: fechaExtracto,
                            totalImporte: 0,
                            filas: []
                        });
                    }
                    
                    const grupo = gruposPorFechaExtracto.get(fechaExtractoNormalizada);
                    grupo.totalImporte += montoExtractoAbs;
                    grupo.filas.push(i);
                    
                    // Debug de grupos formados (solo primeros 5 grupos)
                    if (gruposPorFechaExtracto.size <= 5) {
                        // // console.log(`üìù AGREGADO A GRUPO SANT: FECHA="${fechaExtracto}"‚Üí"${fechaExtractoNormalizada}", IMPORTE=${importeExtracto}‚Üí${montoExtractoAbs}`);
                    }
                }
                
                const gruposExtractoFormados = gruposPorFechaExtracto.size;
                // // console.log(`üè¶ SANT PASO 12 - AGRUPACI√ìN EXTRACTO: ${gruposExtractoFormados} grupos por FECHA formados`);
                
                // === üìä RESUMEN DE PROCESAMIENTO SANT ===
                // // console.log(`\nüìä RESUMEN PROCESAMIENTO SANT:`);
                // // console.log(`   üìã Total registros en archivo SANT: ${extractoProcesable.length}`);
                // // console.log(`   ‚è≠Ô∏è Saltados ya procesados (pasos anteriores): ${extractoProcesable.length - registrosSaltadosSinDatos - registrosProcesadosEnExtracto}`);
                // // console.log(`   ‚è≠Ô∏è Saltados sin datos reales: ${registrosSaltadosSinDatos}`);
                // // console.log(`   ‚úÖ Registros PENDIENTES procesados: ${registrosProcesadosEnExtracto}`);
                // // console.log(`======================================`);
                
                // === üìä TABLA DE COMPARACI√ìN MAYOR VS SANT (SOLO PARA DEBUG) ===
                // // console.log(`\nüìä === TABLA DE COMPARACI√ìN GRUPOS MAYOR VS SANT (CON ESTADOS) ===`);
                // // console.log(`‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
                // // console.log(`‚îÇ    FECHA   ‚îÇ  MAYOR FDOC ‚îÇ MAYOR HABER ‚îÇ SANT FECHA ‚îÇ SANT IMPORTE‚îÇ   STATUS    ‚îÇ DIFERENC‚îÇ`);
                // // console.log(`‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§`);
                
                // Obtener todas las fechas √∫nicas (de ambos lados)
                const todasFechas = new Set([
                    ...Array.from(gruposPorFechaMayor.keys()),
                    ...Array.from(gruposPorFechaExtracto.keys())
                ]);
                
                let conciliados = 0;
                let numeroGrupo = 1;
                
                // // console.log(`üìä Fechas √∫nicas encontradas: ${todasFechas.size}`);
                // // console.log(`üìä Grupos Mayor: ${gruposMayorFormados} | Grupos SANT: ${gruposExtractoFormados}`);
                
                // === üîç DEBUG DETALLADO: CONTENIDO DE CADA GRUPO ===
                // // console.log(`\nüîç === DETALLE COMPLETO DE GRUPOS FORMADOS ===`);
                
                // // console.log(`\nüìã DETALLE GRUPOS MAYOR:`);
                for (const [fecha, grupo] of gruposPorFechaMayor) {
                    // // console.log(`  üóìÔ∏è GRUPO FECHA ${fecha}: ${grupo.filas.length} registros, TOTAL HABER: ${grupo.totalHaber.toFixed(2)}`);
                    for (let i = 0; i < Math.min(3, grupo.filas.length); i++) {
                        const indice = grupo.filas[i];
                        const fila = filasFiltradasMayor[indice];
                        const estadoMayor = estadosFilas.has(indice) ? estadosFilas.get(indice).estado : 'Pendiente';
                        const numdoc = fila[idxM.numdoc] || '';
                        const glosa = (fila[idxM.glosa] || '').substring(0, 20);
                        // // console.log(`     ‚Ä¢ Reg ${i+1}: NUMDOC="${numdoc}", HABER=${this.normalizarMonto(fila[idxM.haber])}, ESTADO_MAYOR="${estadoMayor}", GLOSA="${glosa}..."`);
                    }
                    if (grupo.filas.length > 3) {
                        // // console.log(`     ... y ${grupo.filas.length - 3} registros m√°s`);
                    }
                }
                
                // // console.log(`\nüìã DETALLE GRUPOS SANT:`);
                for (const [fecha, grupo] of gruposPorFechaExtracto) {
                    // // console.log(`  üóìÔ∏è GRUPO FECHA ${fecha}: ${grupo.filas.length} registros, TOTAL IMPORTE: ${grupo.totalImporte.toFixed(2)}`);
                    for (let i = 0; i < Math.min(3, grupo.filas.length); i++) {
                        const indice = grupo.filas[i];
                        const item = extractoProcesable[indice];
                        const fila = item.fila;
                        const estadoSant = estadosExtracto.has(indice) ? estadosExtracto.get(indice).estado : 'Pendiente';
                        const referencia = fila[3] || '';
                        const importe = fila[6] || '';
                        // // console.log(`     ‚Ä¢ Reg ${i+1}: REF="${referencia}", IMPORTE=${importe}, ESTADO_SANT="${estadoSant}"`);
                    }
                    if (grupo.filas.length > 3) {
                        // // console.log(`     ... y ${grupo.filas.length - 3} registros m√°s`);
                    }
                }
                // // console.log(`===============================================`);
                
                // === MAPEO Y CONCILIACI√ìN ===
                for (const fecha of todasFechas) {
                    const grupoMayor = gruposPorFechaMayor.get(fecha);
                    const grupoExtracto = gruposPorFechaExtracto.get(fecha);
                    
                    const tieneGrupoMayor = grupoMayor !== undefined;
                    const tieneGrupoExtracto = grupoExtracto !== undefined;
                    
                    let status = '';
                    let diferencia = '';
                    
                    if (tieneGrupoMayor && tieneGrupoExtracto) {
                        const diff = Math.abs(grupoMayor.totalHaber - grupoExtracto.totalImporte);
                        if (diff < 0.01) {
                            status = 'MATCH ‚úÖ';
                            diferencia = '0.00';
                            
                            // === CONCILIAR REGISTROS ===
                            const refGrupo = `GRUPO-${numeroGrupo}`;
                            
                            // Marcar todas las filas del grupo Mayor como conciliadas
                            for (const indiceMayor of grupoMayor.filas) {
                                estadosFilas.set(indiceMayor, {
                                    estado: 'P12 - Conciliada',
                                    ref: refGrupo
                                });
                            }
                            
                            // Marcar todas las filas del grupo Extracto como conciliadas
                            for (const indiceExtracto of grupoExtracto.filas) {
                                estadosExtracto.set(indiceExtracto, {
                                    estado: 'P12 - Conciliada',
                                    ref: refGrupo
                                });
                            }
                            
                            conciliados++;
                            numeroGrupo++;
                        } else {
                            status = 'DIFF ‚ùå';
                            diferencia = diff.toFixed(2);
                        }
                    } else if (tieneGrupoMayor) {
                        status = 'MAYOR SOLO';
                        diferencia = '-';
                    } else {
                        status = 'SANT SOLO';
                        diferencia = '-';
                    }
                    
                    // Formatear datos para tabla
                    const fechaStr = (fecha || '').toString().padEnd(10);
                    const mayorStr = tieneGrupoMayor ? (grupoMayor.fechaOriginal || '').toString().padEnd(11) : '           ';
                    const mayorHaber = tieneGrupoMayor ? (grupoMayor.totalHaber || 0).toFixed(2).padStart(11) : '           ';
                    const santStr = tieneGrupoExtracto ? (grupoExtracto.fechaOriginal || '').toString().padEnd(10) : '          ';
                    const santImporte = tieneGrupoExtracto ? (grupoExtracto.totalImporte || 0).toFixed(2).padStart(11) : '           ';
                    const statusStr = status.padEnd(11);
                    const difStr = diferencia.toString().padStart(7);
                    
                    // // console.log(`‚îÇ ${fechaStr} ‚îÇ ${mayorStr} ‚îÇ ${mayorHaber} ‚îÇ ${santStr} ‚îÇ ${santImporte} ‚îÇ ${statusStr} ‚îÇ ${difStr} ‚îÇ`);
                }
                
                // // console.log(`‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`);
                
                // // console.log(`\nüè¶ SANT PASO 12 COMPLETADO: ${conciliados} grupos conciliados con numeraci√≥n`);
                
                // === TABLA RESUMEN FINAL ===
                // // console.log(`\nüìä RESUMEN FINAL PASO 12 SANT:`);
                // // console.log(`‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
                // // console.log(`‚îÇ       CONCEPTO      ‚îÇ  VALOR  ‚îÇ`);
                // // console.log(`‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§`);
                // // console.log(`‚îÇ Candidatos Mayor    ‚îÇ ${totalCandidatos.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Grupos Mayor        ‚îÇ ${gruposMayorFormados.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Grupos Extracto     ‚îÇ ${gruposExtractoFormados.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Grupos Conciliados  ‚îÇ ${conciliados.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`);
                
                return {
                    candidatos: totalCandidatos,
                    grupos: Math.max(gruposMayorFormados, gruposExtractoFormados),
                    conciliados: conciliados,
                    libro03: candidatosLibro03,
                    libro09: candidatosLibro09,
                    libro14: candidatosLibro14,
                    libro15: candidatosLibro15
                };
            },

            buscarMatchExtractoPorGrupoNUMDOC(fdocGrupo, totalHaber, extractoProcesable, idxE, estadosExtracto, esGrupoObjetivo = false) {
                /*
                Busca un match en el extracto para PASO 9 (grupos por NUMDOC):
                - Compara FDOC del grupo vs FECHA (Extracto col A)
                - Compara total HABER del grupo vs |MONTO| (Extracto col D en VALOR ABSOLUTO)
                - Retorna datos del match si se encuentra
                NOTA: Similar a buscarMatchExtractoPorGrupo del Paso 5 pero para agrupaci√≥n por NUMDOC
                */
                
                if (esGrupoObjetivo) {
                    // // console.log(`üîç Buscando match para grupo NUMDOC: FDOC="${fdocGrupo}", total HABER=${totalHaber}`);
                    // // console.log(`üìÑ Total l√≠neas disponibles en extracto: ${extractoProcesable ? extractoProcesable.length : 0}`);
                    // // console.log(`üìÑ L√≠neas ya procesadas: ${estadosExtracto.size}`);
                    
                    // Mostrar primeras 5 l√≠neas del extracto con fechas normalizadas
                    // // console.log(`üìã PRIMERAS 5 L√çNEAS DEL EXTRACTO DISPONIBLE:`);
                    for (let i = 0; i < Math.min(5, extractoProcesable.length); i++) {
                        if (!estadosExtracto.has(i)) {
                            const fila = extractoProcesable[i].fila;
                            const fechaRaw = fila[idxE.fecha] || '';
                            const fechaNorm = this.normalizarFecha(fechaRaw);
                            const montoRaw = fila[idxE.monto] || '';
                            // // console.log(`   ${i}: "${fechaRaw}" ‚Üí "${fechaNorm}" | Monto: "${montoRaw}"`);
                        } else {
                            // // console.log(`   ${i}: [YA PROCESADA]`);
                        }
                    }
                    
                    // Buscar espec√≠ficamente la fecha objetivo en todo el extracto
                    const fechaObjetivo = this.normalizarFecha(fdocGrupo);
                    // // console.log(`üéØ BUSCANDO FECHA OBJETIVO "${fechaObjetivo}" EN TODO EL EXTRACTO:`);
                    let encontradas = 0;
                    const lineasObjetivo = [];
                    for (let i = 0; i < extractoProcesable.length; i++) {
                        const fila = extractoProcesable[i].fila;
                        const fechaRaw = fila[idxE.fecha] || '';
                        const fechaNorm = this.normalizarFecha(fechaRaw);
                        if (fechaNorm === fechaObjetivo) {
                            const montoRaw = fila[idxE.monto] || '';
                            const montoNorm = Math.abs(this.normalizarMonto(montoRaw));
                            const procesada = estadosExtracto.has(i) ? '[PROCESADA]' : '[DISPONIBLE]';
                            const diferencia = Math.abs(totalHaber - montoNorm);
                            const coincide = diferencia === 0 ? 'üéØ MATCH!' : `Dif: ${diferencia.toFixed(2)}`;
                            // // console.log(`   √çndice ${i}: "${fechaRaw}" | Monto: "${montoRaw}" ‚Üí ${montoNorm.toFixed(2)} ${procesada} ${coincide}`);
                            if (!estadosExtracto.has(i)) {
                                lineasObjetivo.push({indice: i, monto: montoNorm, diferencia});
                            }
                            encontradas++;
                        }
                    }
                    if (encontradas === 0) {
                        // // console.log(`   ‚ùå NO se encontraron l√≠neas con fecha "${fechaObjetivo}"`);
                    } else {
                        // // console.log(`   üìä Total encontradas: ${encontradas} | Disponibles: ${lineasObjetivo.length}`);
                    }
                }
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    // // // console.log(`‚ùå Error: extractoProcesable no es v√°lido`);
                    return { encontrado: false };
                }
                
                const fechaGrupoNormalizada = this.normalizarFecha(fdocGrupo);
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    candidatosRevisados++;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[6] || ''; // Columna G - Operaci√≥n N√∫mero
                    
                    // Normalizar fecha y monto del extracto
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtractoRaw_parsed = this.normalizarMonto(montoExtractoRaw);
                    const montoExtracto = Math.abs(montoExtractoRaw_parsed); // VALOR ABSOLUTO para extracto
                    
                    // Comparar fechas y montos
                    const fechasCoinciden = fechaGrupoNormalizada === fechaExtractoNormalizada;
                    const diferenciaMonto = Math.abs(totalHaber - montoExtracto);
                    const montosCoinciden = diferenciaMonto < 0.01; // Tolerancia para errores de floating point
                    
                    // Solo mostrar logs para coincidencias de fecha o matches completos
                    if (esGrupoObjetivo && (fechasCoinciden || (fechasCoinciden && montosCoinciden))) {
                        // // console.log(`   üîç Candidato ${candidatosRevisados} (√çndice ${i}):`);
                        // // console.log(`      Fecha: "${fechaExtractoRaw}" ‚Üí "${fechaExtractoNormalizada}" | FDOC Grupo: "${fechaGrupoNormalizada}" | Match: ${fechasCoinciden ? '‚úÖ' : '‚ùå'}`);
                        // // console.log(`      Monto: ${montoExtractoRaw} ‚Üí abs(${montoExtracto.toFixed(2)}) | Total HABER=${totalHaber.toFixed(6)} | Diferencia: ${diferenciaMonto.toFixed(6)} | Match: ${montosCoinciden ? '‚úÖ' : '‚ùå'}`);
                    }
                    
                    if (fechasCoinciden && montosCoinciden) {
                        // // console.log(`‚úÖ MATCH COMPLETO encontrado en √≠ndice ${i}`);
                        // // console.log(`   üìã FDOC Grupo: "${fdocGrupo}" ‚Üî FECHA Extracto: "${fechaExtractoRaw}"`);
                        // // console.log(`   üìã Total HABER: ${totalHaber} ‚Üî |MONTO|: ${montoExtracto} (diferencia: ${diferenciaMonto.toFixed(4)})`);
                        // // console.log(`   üìã Operaci√≥n-N√∫mero del extracto: "${operacionNumero}" (se asignar√° a todas las filas del grupo)`);
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                // // // console.log(`‚ùå No se encontr√≥ match despu√©s de revisar ${candidatosRevisados} candidatos`);
                return { encontrado: false };
            },

            procesarPaso10(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, datosSaldo = null, estadosSaldo = null) {
                /*
                PASO 10 - OPERACIONES DE CHEQUES (2 ETAPAS):
                
                ETAPA 10A - MAPEO MAYOR VS EXTRACTO:
                CRITERIOS DE FILTRADO:
                - Mayor: LIBRO = "02" + ESTADO = "Pendiente"
                - Extracto: "Descripci√≥n operaci√≥n" empieza con "CHEQUE" o "CERT. CHQ"
                
                MAPEO:
                - NUMDOC (Mayor) ‚Üî √∫ltimos 8 caracteres de "Descripci√≥n operaci√≥n" (Extracto)
                - HABER (Mayor) ‚Üî |MONTO| (Extracto en valor absoluto)
                
                ESTADOS RESULTANTES:
                - "P10A - Conciliada" para ambos registros
                - Mayor: #REF = [Operaci√≥n - N√∫mero del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                
                ETAPA 10B - MAPEO EXTRACTO VS SALDO:
                CRITERIOS DE FILTRADO:
                - Extracto: "Descripci√≥n operaci√≥n" inicia con "CHEQUE" + ESTADO = "Pendiente"
                - Saldo: ESTADO = "Pendiente"
                
                MAPEO:
                - √öltimos 8 caracteres de Descripci√≥n operaci√≥n (Extracto) ‚Üî NUMDOC (Saldo)
                
                ESTADOS RESULTANTES:
                - "P10B - Conciliada" para ambos registros
                - Saldo: #REF = "Operaci√≥n - N√∫mero" del extracto
                - Extracto: #REF = "libro - comprobante" (columnas L y M de saldo)
                */
                
                // // // console.log(`üìà PASO 10: Iniciando procesamiento de operaciones de CHEQUES (2 ETAPAS)`);
                // // // console.log(`üîç Total filas a revisar: ${filasFiltradasMayor.length}`);
                // // // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                // ========================================
                // ETAPA 10A: MAPEO MAYOR VS EXTRACTO
                // ========================================
                let candidatosLibro02 = 0;
                let candidatosExtractoCheques = 0;
                let conciliados10A = 0;
                let conciliados10B = 0;
                
                // Identificar candidatos LIBRO="02" pendientes
                const candidatosPaso10 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    
                    // Verificar criterios del PASO 10A
                    const esLibro02 = String(libro || '').trim() === '02';
                    
                    if (esLibro02) {
                        candidatosLibro02++;
                        const numdoc = filaMayor[idxM.numdoc] || '';
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosPaso10.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            numdoc: this.normalizarTexto(numdoc),
                            numdocOriginal: numdoc,
                            haber: haber,
                            comprob: comprob
                        });
                    }
                }
                
                // // // console.log(`üìä ETAPA 10A - FILTRADO MAYOR:`);
                // // // console.log(`   üìù Candidatos LIBRO 02 (cheques): ${candidatosLibro02}`);
                
                // Filtrar extracto por descripci√≥n que empiece con "CHEQUE" o "CERT. CHQ"
                const extractoCheques = [];
                
                if (extractoProcesable && Array.isArray(extractoProcesable)) {
                    for (let i = 0; i < extractoProcesable.length; i++) {
                        // Solo revisar filas no procesadas del extracto
                        if (estadosExtracto.has(i)) continue;
                        
                        const itemExtracto = extractoProcesable[i];
                        const filaExtracto = itemExtracto.fila;
                        
                        if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                        
                        const descripcionOperacion = (filaExtracto[idxE.descripcion] || '').toString().toUpperCase();
                        
                        // Verificar si empieza con "CHEQUE" o "CERT. CHQ"
                        const esCheque = descripcionOperacion.startsWith('CHEQUE') || descripcionOperacion.startsWith('CERT. CHQ');
                        
                        if (esCheque) {
                            candidatosExtractoCheques++;
                            
                            // Extraer √∫ltimos 8 caracteres de la descripci√≥n
                            const ultimos8Chars = descripcionOperacion.slice(-8);
                            const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                            const operacionNumero = filaExtracto[6] || ''; // Columna G - Operaci√≥n N√∫mero
                            
                            extractoCheques.push({
                                indiceOriginal: i,
                                descripcion: descripcionOperacion,
                                ultimos8: this.normalizarTexto(ultimos8Chars),
                                monto: Math.abs(this.normalizarMonto(montoExtractoRaw)), // VALOR ABSOLUTO
                                operacionNumero: operacionNumero,
                                filaCompleta: filaExtracto
                            });
                        }
                    }
                }
                
                // // // console.log(`üìä ETAPA 10A - FILTRADO EXTRACTO:`);
                // // // console.log(`   üìù Candidatos con CHEQUE/CERT. CHQ: ${candidatosExtractoCheques}`);
                
                // ETAPA 10A: MAPEO MAYOR vs EXTRACTO
                if (candidatosLibro02 > 0 && candidatosExtractoCheques > 0) {
                    // // // console.log(`\nüìù ETAPA 10A - MAPEO: NUMDOC+HABER vs √∫ltimos 8 chars + |MONTO|`);
                    
                    for (const candidato of candidatosPaso10) {
                        // Saltar si ya fue procesado
                        if (estadosFilas.has(candidato.indice)) continue;
                        
                        // Buscar match en extracto filtrado
                        const matchExtracto = this.buscarMatchPorNUMDOCyCheque(candidato.numdoc, candidato.haber, extractoCheques, estadosExtracto);
                        
                        if (matchExtracto.encontrado) {
                            const refMayor = matchExtracto.operacionNumero;
                            const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                            
                            // Asignar estados ETAPA 10A
                            estadosFilas.set(candidato.indice, {
                                estado: 'P10A - Conciliada',
                                ref: refMayor
                            });
                            
                            estadosExtracto.set(matchExtracto.indiceOriginal, {
                                estado: 'P10A - Conciliada',
                                ref: refExtracto
                            });
                            
                            conciliados10A++;
                            
                            // // // console.log(`‚úÖ ETAPA 10A - CONCILIACI√ìN EXITOSA:`);
                            // // // console.log(`   üìù Mayor: LIBRO=${candidato.libro}, NUMDOC="${candidato.numdocOriginal}", HABER=${candidato.haber}, COMPROB=${candidato.comprob} ‚Üí REF="${refMayor}"`);
                            // // // console.log(`   üìù Extracto: DESC="${matchExtracto.descripcion}", √öltimos 8="${matchExtracto.ultimos8}", |MONTO|=${matchExtracto.monto} ‚Üí REF="${refExtracto}"`);
                        }
                    }
                }
                
                // ========================================
                // ETAPA 10B: MAPEO EXTRACTO VS SALDO
                // ========================================
                
                // // // console.log(`\nüìà ETAPA 10B: Iniciando mapeo EXTRACTO vs SALDO para cheques`);
                
                if (datosSaldo && datosSaldo.length > 1 && estadosSaldo) {
                    // Mapear √≠ndices del saldo
                    const headerSaldo = datosSaldo[0] || [];
                    const indicesSaldo = this.buscarIndicesColumnas(headerSaldo, {
                        cuenta: ['CUENTA'], 
                        numdoc: ['NUMDOC'], 
                        debe: ['DEBE'], 
                        haber: ['HABER'], 
                        fdoc: ['FDOC'], 
                        libro: ['LIBRO'], // Columna L
                        comprobante: ['COMPROBANTE', 'COMPROB'] // Columna M
                    });
                    
                    const filasSaldo = datosSaldo.slice(1);
                    
                    // Filtrar extracto cheques pendientes despu√©s de ETAPA 10A
                    const extractoChequesParaSaldo = extractoCheques.filter(item => !estadosExtracto.has(item.indiceOriginal));
                    
                    // // // console.log(`üìä ETAPA 10B - CANDIDATOS:`);
                    // // // console.log(`   üìù Extracto cheques pendientes: ${extractoChequesParaSaldo.length}`);
                    // // // console.log(`   üìù Filas saldo disponibles: ${filasSaldo.length}`);
                    
                    // MAPEO: √öltimos 8 chars extracto ‚Üî NUMDOC saldo
                    for (const extractoItem of extractoChequesParaSaldo) {
                        for (let idx = 0; idx < filasSaldo.length; idx++) {
                            // Solo procesar filas saldo pendientes
                            if (estadosSaldo.has(idx) && estadosSaldo.get(idx).estado !== 'Pendiente') continue;
                            
                            const filaSaldo = filasSaldo[idx];
                            const numdocSaldoRaw = filaSaldo[indicesSaldo.numdoc] || '';
                            const numdocSaldoNormalizado = this.normalizarTexto(numdocSaldoRaw);
                            
                            // Comparar √∫ltimos 8 chars extracto vs NUMDOC saldo
                            if (extractoItem.ultimos8 && numdocSaldoNormalizado && extractoItem.ultimos8 === numdocSaldoNormalizado) {
                                // MATCH ENCONTRADO
                                const operacionNumero = extractoItem.operacionNumero;
                                const libroSaldo = filaSaldo[indicesSaldo.libro] || filaSaldo[11] || ''; // Columna L
                                const comprobanteSaldo = filaSaldo[indicesSaldo.comprobante] || filaSaldo[12] || ''; // Columna M
                                const refExtracto = `${libroSaldo}-${comprobanteSaldo}`;
                                
                                // Asignar estados ETAPA 10B
                                estadosSaldo.set(idx, {
                                    estado: 'P10B - Conciliada',
                                    ref: operacionNumero
                                });
                                
                                estadosExtracto.set(extractoItem.indiceOriginal, {
                                    estado: 'P10B - Conciliada',
                                    ref: refExtracto
                                });
                                
                                conciliados10B++;
                                
                                // // // console.log(`‚úÖ ETAPA 10B - CONCILIACI√ìN EXITOSA:`);
                                // // // console.log(`   üìù Extracto: DESC="${extractoItem.descripcion}", √öltimos 8="${extractoItem.ultimos8}", Operaci√≥n="${operacionNumero}" ‚Üí REF="${refExtracto}"`);
                                // // // console.log(`   üìù Saldo: NUMDOC="${numdocSaldoRaw}", LIBRO="${libroSaldo}", COMPROB="${comprobanteSaldo}" ‚Üí REF="${operacionNumero}"`);
                                
                                break; // Solo uno por extracto
                            }
                        }
                    }

                    
                } else {
                    // // // console.log(`‚ö†Ô∏è ETAPA 10B: No hay datos de saldo disponibles o estadosSaldo no inicializado`);
                    // // // console.log(`   üìä datosSaldo: ${datosSaldo ? 'S√ç' : 'NO'}, estadosSaldo: ${estadosSaldo ? 'S√ç' : 'NO'}`);
                }
                
                // // // console.log(`üìä PASO 10 - RESUMEN COMPLETO:`);
                // // // console.log(`   üìù Candidatos LIBRO 02: ${candidatosLibro02}`);
                // // // console.log(`   üìù Candidatos extracto cheques: ${candidatosExtractoCheques}`);
                // // // console.log(`   üéØ Conciliados 10A: ${conciliados10A}`);
                // // // console.log(`   üéØ Conciliados 10B: ${conciliados10B}`);
                
                return {
                    candidatos: candidatosLibro02,
                    candidatosExtracto: candidatosExtractoCheques,
                    conciliados10A: conciliados10A,
                    conciliados10B: conciliados10B,
                    conciliados: conciliados10A + conciliados10B
                };
            },

            aplicarEstadosASaldo(datosSaldo, estadosSaldo) {
                /*
                Aplica los estados del Map estadosSaldo a las columnas P (ESTADO) y Q (#REF) del archivo saldo.
                - datosSaldo: Array con header + filas de datos del saldo
                - estadosSaldo: Map con √≠ndices y estados {estado, ref}
                */
                
                if (!datosSaldo || datosSaldo.length <= 1 || !estadosSaldo || estadosSaldo.size === 0) {
                    // // // console.log(`‚ö†Ô∏è aplicarEstadosASaldo: Sin datos para procesar`);
                    return;
                }
                
                // // // console.log(`üìä aplicarEstadosASaldo: Aplicando ${estadosSaldo.size} estados a ${datosSaldo.length - 1} filas`);
                
                let estadosAplicados = 0;
                
                // Procesar cada fila de datos (saltar header)
                for (let i = 1; i < datosSaldo.length; i++) {
                    const indiceData = i - 1; // √çndice en el Map (0-based para filas de datos)
                    
                    if (estadosSaldo.has(indiceData)) {
                        const estadoInfo = estadosSaldo.get(indiceData);
                        const fila = datosSaldo[i];
                        
                        // Asegurar que la fila tiene al menos 17 columnas (0-16)
                        while (fila.length < 17) {
                            fila.push('');
                        }
                        
                        // Actualizar columnas P (15) y Q (16)
                        fila[15] = estadoInfo.estado || 'Pendiente'; // Columna P = ESTADO
                        fila[16] = estadoInfo.ref || ''; // Columna Q = #REF
                        
                        estadosAplicados++;
                        
                        // // // console.log(`   ‚úÖ Fila ${i}: ESTADO="${estadoInfo.estado}", REF="${estadoInfo.ref}"`);
                    }
                }
                
                // // // console.log(`üìä aplicarEstadosASaldo: ${estadosAplicados} estados aplicados exitosamente`);
            },

            buscarMatchPorNUMDOCyCheque(numdocMayor, haberMayor, extractoCheques, estadosExtracto) {
                /*
                Busca un match en el extracto filtrado para PASO 10 (cheques):
                - Compara NUMDOC (Mayor normalizado) vs √∫ltimos 8 caracteres de descripci√≥n (Extracto)
                - Compara HABER (Mayor) vs |MONTO| (Extracto en valor absoluto)
                - Retorna datos del match si se encuentra
                */
                
                // // // console.log(`üîç Buscando match por CHEQUE: NUMDOC="${numdocMayor}", HABER=${haberMayor}`);
                
                let candidatosRevisados = 0;
                
                for (const itemExtracto of extractoCheques) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(itemExtracto.indiceOriginal)) continue;
                    
                    candidatosRevisados++;
                    
                    // Comparar NUMDOC vs √∫ltimos 8 caracteres y HABER vs |MONTO|
                    const numdocCoincide = numdocMayor && itemExtracto.ultimos8 && numdocMayor === itemExtracto.ultimos8;
                    const diferenciaMonto = Math.abs(haberMayor - itemExtracto.monto);
                    const montosCoinciden = diferenciaMonto === 0; // Exacto
                    
                    // if (candidatosRevisados <= 5) {
                    //     // // console.log(`   üîç Candidato ${candidatosRevisados}:`);
                    //     // // console.log(`      NUMDOC: "${numdocMayor}" vs √öltimos 8: "${itemExtracto.ultimos8}" | Match: ${numdocCoincide ? '‚úÖ' : '‚ùå'}`);
                    //     // // console.log(`      HABER: ${haberMayor} vs |MONTO|: ${itemExtracto.monto} | Diferencia: ${diferenciaMonto.toFixed(4)} | Match: ${montosCoinciden ? '‚úÖ' : '‚ùå'}`);
                    // }
                    
                    if (numdocCoincide && montosCoinciden) {
                        // // // console.log(`‚úÖ MATCH CHEQUE encontrado`);
                        // // // console.log(`   üìù NUMDOC Mayor: "${numdocMayor}" ‚Üî √öltimos 8 Extracto: "${itemExtracto.ultimos8}"`);
                        // // // console.log(`   üìù HABER Mayor: ${haberMayor} ‚Üî |MONTO| Extracto: ${itemExtracto.monto} (diferencia: ${diferenciaMonto.toFixed(4)})`);
                        // // // console.log(`   üìù Descripci√≥n completa: "${itemExtracto.descripcion}"`);
                        return {
                            encontrado: true,
                            indiceOriginal: itemExtracto.indiceOriginal,
                            descripcion: itemExtracto.descripcion,
                            ultimos8: itemExtracto.ultimos8,
                            monto: itemExtracto.monto,
                            operacionNumero: itemExtracto.operacionNumero
                        };
                    }
                }
                
                // // // console.log(`‚ùå No se encontr√≥ match CHEQUE despu√©s de revisar ${candidatosRevisados} candidatos`);
                return { encontrado: false };
            },

            procesarPaso11(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 11 - ITF (IMPUESTO A LAS TRANSACCIONES FINANCIERAS):
                
                ESTRATEGIA ESPEC√çFICA POR BANCO:
                
                BCP (General):
                - Mayor: LIBRO = "09" + GLOSA empieza con "ITF" + CUENTA espec√≠fica + ESTADO = "Pendiente"
                - Extracto: "Descripci√≥n operaci√≥n" contiene "IMPUESTO ITF"
                - Mapeo: Suma total MAYOR vs suma total EXTRACTO POR CUENTA
                
                SANT (Santander) - MAPEO ESPEC√çFICO:
                - Mayor: LIBRO = "09" + GLOSA contiene "ITF" + HABER
                - Extracto: Descripci√≥n contiene "CARGO POR ITF", agrupar todos
                - Mapeo: Suma HABER (Mayor) vs suma |IMPORTE| (Extracto)
                
                BBVA - MAPEO ESPEC√çFICO:
                - Mayor: GLOSA contiene "ITF" + HABER
                - Extracto: Concepto contiene "ITF", identificar total de operaciones
                - Mapeo: Suma HABER (Mayor) vs suma |IMPORTE| (Extracto)
                
                IBK - MAPEO ESPEC√çFICO:
                - Mayor: LIBRO = "09" + GLOSA contiene "ITF" + HABER (est√°ndar)
                - Extracto: Movimiento contiene "ITF" + valor absoluto de ABONO
                - Mapeo: Suma HABER (Mayor) vs suma |ABONO| (Extracto IBK)
                
                ESTADOS RESULTANTES:
                - "P11 - Conciliada"
                - Mayor: #REF = [Referencia del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del primer registro Mayor ITF
                */
                
                // // // console.log(`üìà PASO 11: Iniciando procesamiento de ITF (LIBRO 09) para cuenta ${cuentaConfig?.alias || 'GLOBAL'}`);
                // // // console.log(`üîç Total filas a revisar: ${filasFiltradasMayor.length}`);
                // // // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                // === VERIFICAR SI ES SANTANDER, BBVA, SBP, IBK O BN PARA MAPEO ESPEC√çFICO ===
                const esSantander = cuentaConfig && (cuentaConfig.alias === 'SANT' || cuentaConfig.alias === 'SANT.USD');
                const esBBVA = cuentaConfig && (cuentaConfig.codigo === '1041201' || cuentaConfig.codigo === '1041202');
                const esIBK = cuentaConfig && (cuentaConfig.alias === 'IBK' || cuentaConfig.alias === 'IBK.USD');
                const esSBP = cuentaConfig && (cuentaConfig.alias === 'SBP' || cuentaConfig.alias === 'SBP.USD');
                const esBN = cuentaConfig && cuentaConfig.alias === 'BN';
                
                if (esSantander) {
                    // // console.log(`üè¶ PASO 11 SANTANDER: Identificar ITF en GLOSA + CARGO POR ITF en Descripci√≥n`);
                    const esSANTUSD = cuentaConfig && cuentaConfig.codigo === '1041402';
                    if (esSANTUSD) {
                        console.log(`üè¶ DIAGN√ìSTICO SANT.USD - PASO 11 ITF:`);
                        console.log(`   Cuenta: ${cuentaConfig.codigo} (${cuentaConfig.alias})`);
                        console.log(`   Buscando en extracto: "CARGO POR ITF" o "I.T.F."`);
                    }
                    return this.procesarPaso11Santander(filasFiltradasMayor, extractoProcesable, idxM, estadosFilas, estadosExtracto);
                } else if (esBBVA) {
                    const esBBVAUSD = cuentaConfig && cuentaConfig.codigo === '1041202';
                    if (esBBVAUSD) {
                        console.log(`üè¶ DIAGN√ìSTICO BBVA.USD - PASO 11 ITF:`);
                        console.log(`   Cuenta: ${cuentaConfig.codigo} (${cuentaConfig.alias})`);
                        console.log(`   Estrategia: Misma l√≥gica que BBVA.PEN`);
                    }
                    return this.procesarPaso11BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (esIBK) {
                    // // console.log(`üè¶ PASO 11 IBK: ITF en Movimiento + valor absoluto de Abono`);
                    return this.procesarPaso11IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (esSBP) {
                    const esSBPUSD = cuentaConfig && cuentaConfig.codigo === '1041302';
                    if (esSBPUSD) {
                        console.log(`üè¶ DIAGN√ìSTICO SBP.USD - PASO 11 ITF:`);
                        console.log(`   Cuenta: ${cuentaConfig.codigo} (${cuentaConfig.alias})`);
                        console.log(`   Estrategia: Misma l√≥gica que SBP.PEN`);
                    }
                    return this.procesarPaso11SBP(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else if (esBN) {
                    console.log(`üîÄ Redirigiendo a procesarPaso11BN`);
                    return this.procesarPaso11BN(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto);
                } else {
                    // // console.log(`üè¶ PASO 11 BCP: L√≥gica est√°ndar IMPUESTO ITF`);
                    const esBCPUSD = cuentaConfig && cuentaConfig.codigo === '1041502';
                    if (esBCPUSD) {
                        console.log(`üè¶ DIAGN√ìSTICO BCP.USD - PASO 11 ITF:`);
                        console.log(`   Total filas Mayor: ${filasFiltradasMayor.length}`);
                        console.log(`   Cuenta configurada: ${cuentaConfig.codigo} (${cuentaConfig.alias})`);
                        console.log(`   Buscando: LIBRO="09" + GLOSA.startsWith("ITF") + CUENTA="${cuentaConfig.codigo}"`);
                    }
                }
                
                let candidatosLibro09ITF = 0;
                let candidatosExtractoITF = 0;
                let conciliados = 0;
                
                // Obtener c√≥digo de cuenta espec√≠fica para filtrado
                const codigoCuentaEspecifica = cuentaConfig ? cuentaConfig.codigo : null;
                
                // Identificar candidatos LIBRO="09" + GLOSA empieza con "ITF" + CUENTA espec√≠fica
                const candidatosMayorITF = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const cuentaMayor = (filaMayor[idxM.cuenta] || '').toString();
                    
                    // Verificar criterios del PASO 11 + FILTRO POR CUENTA ESPEC√çFICA
                    const esLibro09 = String(libro || '').trim() === '09';
                    const esGlosaITF = glosa.startsWith('ITF');
                    const esCuentaEspecifica = codigoCuentaEspecifica ? (cuentaMayor === codigoCuentaEspecifica) : true;
                    
                    // Diagn√≥stico espec√≠fico para BCP.USD - mostrar primeras 20 filas
                    const esBCPUSD = cuentaConfig && cuentaConfig.codigo === '1041502';
                    if (esBCPUSD && i < 20) {
                        console.log(`üîç BCP.USD ITF Fila ${i}: LIBRO="${libro}", GLOSA="${glosa.substring(0, 30)}", CUENTA="${cuentaMayor}", HABER=${this.normalizarMonto(filaMayor[idxM.haber] || '0')}`);
                        console.log(`   ‚Ü≥ Criterios: LIBRO09=${esLibro09}, GLOSA_ITF=${esGlosaITF}, CUENTA_OK=${esCuentaEspecifica}`);
                    }
                    
                    if (esLibro09 && esGlosaITF && esCuentaEspecifica) {
                        candidatosLibro09ITF++;
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosMayorITF.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            fdoc: fdoc,
                            debe: debe,
                            haber: haber,
                            comprob: comprob
                        });
                        
                        // Debug: Mostrar los primeros 5 candidatos
                        if (candidatosLibro09ITF <= 5) {
                            // // console.log(`üîç Candidato ITF ${candidatosLibro09ITF} (Cuenta ${cuentaMayor}): LIBRO="${libro}", GLOSA="${glosa.substring(0, 30)}...", FDOC="${fdoc}", DEBE=${debe}, HABER=${haber}`);
                        }
                        
                        // Diagn√≥stico espec√≠fico para BCP.USD
                        const esBCPUSD = cuentaConfig && cuentaConfig.codigo === '1041502';
                        if (esBCPUSD && candidatosLibro09ITF <= 10) {
                            console.log(`üéØ BCP.USD ITF Candidato ${candidatosLibro09ITF}: LIBRO="${libro}", GLOSA="${glosa.substring(0, 40)}", CUENTA="${cuentaMayor}", HABER=${haber}`);
                        }
                    }
                }
                
                // // // console.log(`üìä PASO 11 - FILTRADO MAYOR (Cuenta ${cuentaConfig?.alias || 'GLOBAL'}):`);
                // // console.log(`   üí∞ Candidatos LIBRO 09 + ITF: ${candidatosLibro09ITF}`);
                
                if (candidatosLibro09ITF === 0) {
                    // // // console.log(`‚ö†Ô∏è No se encontraron candidatos ITF en LIBRO 09 para cuenta ${cuentaConfig?.alias || 'GLOBAL'}`);
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // Filtrar extracto por descripci√≥n que contenga "IMPUESTO ITF"
                const extractoITF = [];
                
                if (extractoProcesable && Array.isArray(extractoProcesable)) {
                    for (let i = 0; i < extractoProcesable.length; i++) {
                        // Solo revisar filas no procesadas del extracto
                        if (estadosExtracto.has(i)) continue;
                        
                        const itemExtracto = extractoProcesable[i];
                        const filaExtracto = itemExtracto.fila;
                        
                        if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                        
                        const descripcionOperacion = (filaExtracto[idxE.descripcion] || '').toString().toUpperCase();
                        
                        // Verificar si contiene "IMPUESTO ITF"
                        const esImpuestoITF = descripcionOperacion.includes('IMPUESTO ITF');
                        
                        if (esImpuestoITF) {
                            candidatosExtractoITF++;
                            
                            const fechaExtracto = filaExtracto[idxE.fecha] || '';
                            const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                            const operacionNumero = filaExtracto[6] || ''; // Columna G - Operaci√≥n N√∫mero
                            
                            extractoITF.push({
                                indiceOriginal: i,
                                descripcion: descripcionOperacion,
                                fecha: this.normalizarFecha(fechaExtracto),
                                monto: Math.abs(this.normalizarMonto(montoExtractoRaw)), // VALOR ABSOLUTO
                                operacionNumero: operacionNumero,
                                filaCompleta: filaExtracto
                            });
                            
                            // Debug: Mostrar los primeros 5 candidatos del extracto
                            if (candidatosExtractoITF <= 5) {
                                // // console.log(`üîç Extracto ITF ${candidatosExtractoITF}: DESC="${descripcionOperacion.substring(0, 40)}...", FECHA="${fechaExtracto}", |MONTO|=${Math.abs(this.normalizarMonto(montoExtractoRaw))}`);
                            }
                        }
                    }
                }
                
                // // // console.log(`üìä PASO 11 - FILTRADO EXTRACTO:`);
                // // console.log(`   üí∞ Candidatos con IMPUESTO ITF: ${candidatosExtractoITF}`);
                
                if (candidatosExtractoITF === 0) {
                    // // // console.log(`‚ö†Ô∏è No se encontraron candidatos IMPUESTO ITF en extracto para PASO 11`);
                    return { candidatos: candidatosLibro09ITF, conciliados: 0 };
                }
                
                // AGRUPACI√ìN Y MAPEO POR CUENTA: Suma total de ITFs para cuenta espec√≠fica
                const totalMayorITF = candidatosMayorITF.reduce((suma, item) => suma + (item.debe + item.haber), 0);
                const totalExtractoITF = extractoITF.reduce((suma, item) => suma + item.monto, 0);
                
                // Diagn√≥stico detallado para BCP.USD
                const esBCPUSD_calc = cuentaConfig && cuentaConfig.codigo === '1041502';
                if (esBCPUSD_calc) {
                    console.log(`üîç BCP.USD ITF DESGLOSE DE C√ÅLCULOS:`);
                    console.log(`üìä MAYOR - ${candidatosMayorITF.length} candidatos:`);
                    candidatosMayorITF.forEach((item, idx) => {
                        console.log(`   ${idx + 1}. DEBE=${item.debe}, HABER=${item.haber}, SUMA=${item.debe + item.haber}`);
                    });
                    console.log(`üìä EXTRACTO - ${extractoITF.length} candidatos:`);
                    extractoITF.forEach((item, idx) => {
                        console.log(`   ${idx + 1}. MONTO=${item.monto}, DESC="${item.descripcion.substring(0, 20)}"`);
                    });
                    console.log(`üìä TOTALES CALCULADOS:`);
                    console.log(`   Mayor: ${candidatosMayorITF.map(item => item.debe + item.haber).join(' + ')} = ${totalMayorITF}`);
                    console.log(`   Extracto: ${extractoITF.map(item => item.monto).join(' + ')} = ${totalExtractoITF}`);
                }
                
                // // console.log(`\nüí∞ AGRUPACI√ìN ITF CUENTA ${cuentaConfig?.alias || 'GLOBAL'}:`);
                // // console.log(`   üìã Total MAYOR ITF (DEBE+HABER): ${totalMayorITF.toFixed(2)} (${candidatosLibro09ITF} registros)`);
                // // console.log(`   üìã Total EXTRACTO ITF (|MONTO|): ${totalExtractoITF.toFixed(2)} (${candidatosExtractoITF} registros)`);
                
                // Verificar si los totales coinciden (con tolerancia para errores de punto flotante)
                const diferenciaTotales = Math.abs(totalMayorITF - totalExtractoITF);
                const totalesCoinciden = diferenciaTotales < 0.01; // Tolerancia de 1 centavo
                
                // Diagn√≥stico espec√≠fico para BCP.USD
                const esBCPUSD_prec = cuentaConfig && cuentaConfig.codigo === '1041502';
                if (esBCPUSD_prec) {
                    console.log(`üîç BCP.USD ITF DIAGN√ìSTICO PRECISI√ìN:`);
                    console.log(`   totalMayorITF = ${totalMayorITF} (tipo: ${typeof totalMayorITF})`);
                    console.log(`   totalExtractoITF = ${totalExtractoITF} (tipo: ${typeof totalExtractoITF})`);
                    console.log(`   diferenciaTotales = ${diferenciaTotales} (exacto: ${diferenciaTotales.toString()})`);
                    console.log(`   totalesCoinciden = ${totalesCoinciden} (condici√≥n: diferenciaTotales < 0.01)`);
                    console.log(`   Resultado: ${totalesCoinciden ? '‚úÖ CONCILIAR√Å' : '‚ùå NO CONCILIAR√Å'}`);
                }
                
                // // console.log(`   üí∞ Diferencia entre totales: ${diferenciaTotales.toFixed(4)}`);
                // // console.log(`   üí∞ ¬øTotales coinciden? ${totalesCoinciden ? '‚úÖ S√ç' : '‚ùå NO'}`);
                
                if (totalesCoinciden) {
                    // CONCILIACI√ìN EXITOSA: Asignar estados a TODOS los registros de ambos grupos
                    const refMayor = extractoITF.length > 0 ? extractoITF[0].operacionNumero : 'ITF-GLOBAL';
                    const refExtracto = candidatosMayorITF.length > 0 ? `${candidatosMayorITF[0].libro}-${candidatosMayorITF[0].comprob}` : '09-ITF';
                    
                    // Asignar estados a TODOS los registros del mayor ITF
                    candidatosMayorITF.forEach((item, idx) => {
                        estadosFilas.set(item.indice, {
                            estado: 'P11 - Conciliada',
                            ref: refMayor // Mismo n√∫mero de operaci√≥n para todos
                        });
                        
                        // // console.log(`   ‚úÖ Mayor ${idx + 1}/${candidatosMayorITF.length}: √çndice ${item.indice}, GLOSA="${item.glosa.substring(0, 20)}...", DEBE=${item.debe}, HABER=${item.haber} ‚Üí REF="${refMayor}"`);
                    });
                    
                    // Asignar estados a TODOS los registros del extracto ITF
                    extractoITF.forEach((item, idx) => {
                        estadosExtracto.set(item.indiceOriginal, {
                            estado: 'P11 - Conciliada',
                            ref: refExtracto
                        });
                        
                        // // console.log(`   ‚úÖ Extracto ${idx + 1}/${extractoITF.length}: √çndice ${item.indiceOriginal}, DESC="${item.descripcion.substring(0, 30)}...", |MONTO|=${item.monto} ‚Üí REF="${refExtracto}"`);
                    });
                    
                    conciliados = candidatosMayorITF.length + extractoITF.length; // Total de registros conciliados
                    
                    // // // console.log(`‚úÖ PASO 11 - CONCILIACI√ìN ITF EXITOSA para cuenta ${cuentaConfig?.alias || 'GLOBAL'}:`);
                    // // console.log(`   üí∞ TOTAL Mayor: ${totalMayorITF.toFixed(2)} (${candidatosMayorITF.length} registros) ‚Üí REF="${refMayor}"`);
                    // // console.log(`   üí∞ TOTAL Extracto: ${totalExtractoITF.toFixed(2)} (${extractoITF.length} registros) ‚Üí REF="${refExtracto}"`);
                    // // console.log(`   üí∞ Diferencia: ${diferenciaTotales.toFixed(4)} (coincidencia exacta)`);
                    // // console.log(`   üéØ Registros conciliados: ${conciliados} (${candidatosMayorITF.length} mayor + ${extractoITF.length} extracto)`);
                } else {
                    // // // console.log(`‚ùå PASO 11 - Los totales ITF NO coinciden (diferencia: ${diferenciaTotales.toFixed(4)} > 0)`);
                    // // console.log(`   üí∞ Mayor: ${totalMayorITF.toFixed(2)} vs Extracto: ${totalExtractoITF.toFixed(2)}`);
                }
                
                // Diagn√≥stico espec√≠fico para BCP.USD
                const esBCPUSD_res = cuentaConfig && cuentaConfig.codigo === '1041502';
                if (esBCPUSD_res) {
                    console.log(`üìä BCP.USD PASO 11 ITF - RESUMEN COMPLETO:`);
                    console.log(`   üí∞ Candidatos LIBRO 09 ITF: ${candidatosLibro09ITF}`);
                    console.log(`   üìã Candidatos Extracto ITF: ${candidatosExtractoITF}`);
                    console.log(`   üéØ Conciliados: ${conciliados}`);
                    console.log(`   üí∞ Total Mayor: ${totalMayorITF.toFixed(2)}`);
                    console.log(`   üí∞ Total Extracto: ${totalExtractoITF.toFixed(2)}`);
                    console.log(`   üìä Diferencia: ${diferenciaTotales.toFixed(4)} (${diferenciaTotales < 0.01 ? 'TOLERABLE - CONCILIA' : 'FUERA TOLERANCIA'})`);
                }
                
                // // // console.log(`üìä PASO 11 - RESUMEN COMPLETO (Cuenta ${cuentaConfig?.alias || 'GLOBAL'}):`);
                // // console.log(`   üí∞ Candidatos LIBRO 09 ITF: ${candidatosLibro09ITF}`);
                // // console.log(`   üí∞ Candidatos extracto IMPUESTO ITF: ${candidatosExtractoITF}`);
                // // console.log(`   üéØ Registros conciliados: ${conciliados}`);
                // // console.log(`   üí∞ Estrategia: Agrupaci√≥n por cuenta - suma de totales por cuenta espec√≠fica`);
                
                return {
                    candidatos: candidatosLibro09ITF,
                    candidatosExtracto: candidatosExtractoITF,
                    conciliados: conciliados,
                    totalMayor: totalMayorITF,
                    totalExtracto: totalExtractoITF,
                    diferencia: diferenciaTotales
                };
            },

            procesarPaso11Santander(filasFiltradasMayor, extractoProcesable, idxM, estadosFilas, estadosExtracto) {
                /*
                PASO 11 SANTANDER - ITF ESPEC√çFICO:
                
                ESTRATEGIA ESPEC√çFICA:
                - Mayor: LIBRO = "09" + GLOSA contiene "ITF" + HABER
                - Extracto: Descripci√≥n contiene "CARGO POR ITF", agrupar todos
                - Mapeo: Suma HABER (Mayor) vs suma |IMPORTE| (Extracto)
                
                ESTADOS RESULTANTES:
                - "P11 - Conciliada"
                - Mayor: #REF = [Primera referencia del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del primer registro Mayor ITF
                */
                
                // // console.log(`üè¶ SANT PASO 11: Iniciando procesamiento ITF espec√≠fico para Santander`);
                
                let candidatosLibro09ITF = 0;
                let candidatosExtractoITF = 0;
                let conciliados = 0;
                
                // === 1. IDENTIFICAR ITF EN MAYOR ===
                const candidatosMayorITF = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    
                    // Verificar criterios SANT PASO 11: LIBRO "09" + GLOSA contiene "ITF"
                    const esLibro09 = String(libro || '').trim() === '09';
                    const esGlosaITF = glosa.includes('ITF');
                    
                    if (esLibro09 && esGlosaITF) {
                        candidatosLibro09ITF++;
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosMayorITF.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            fdoc: fdoc,
                            debe: debe,
                            haber: haber,
                            comprob: comprob
                        });
                        
                        // // console.log(`üîç SANT ITF Mayor ${candidatosLibro09ITF}: LIBRO="${libro}", GLOSA="${glosa.substring(0, 30)}...", HABER=${haber}`);
                    }
                }
                
                // // console.log(`üè¶ SANT PASO 11 - MAYOR: ${candidatosLibro09ITF} candidatos ITF encontrados`);
                
                if (candidatosLibro09ITF === 0) {
                    // // console.log(`‚ö†Ô∏è SANT: No se encontraron candidatos ITF en LIBRO 09`);
                    return { candidatos: 0, candidatosExtracto: 0, conciliados: 0 };
                }
                
                // === 2. IDENTIFICAR "CARGO POR ITF" EN EXTRACTO SANTANDER ===
                const extractoITF = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // === MAPEO ESPEC√çFICO SANTANDER ===
                    // Columna E (√≠ndice 4): Descripci√≥n - buscar "CARGO POR ITF" o "I.T.F."
                    // Columna G (√≠ndice 6): Importe
                    const descripcionExtracto = (filaExtracto[4] || '').toString().toUpperCase(); // Columna E - Descripcion
                    const importeExtracto = filaExtracto[6] || '0'; // Columna G
                    const referenciaExtracto = filaExtracto[3] || ''; // Columna D - Referencia
                    
                    // Verificar si contiene "CARGO POR ITF" o "I.T.F."
                    const esCargoITF = descripcionExtracto.includes('CARGO POR ITF') || descripcionExtracto.includes('I.T.F.');
                    
                    if (esCargoITF) {
                        candidatosExtractoITF++;
                        
                        const montoExtractoAbs = Math.abs(this.normalizarMonto(importeExtracto));
                        
                        extractoITF.push({
                            indiceOriginal: i,
                            descripcion: descripcionExtracto,
                            monto: montoExtractoAbs,
                            referencia: referenciaExtracto,
                            filaCompleta: filaExtracto
                        });
                        
                        // // console.log(`üîç SANT ITF Extracto ${candidatosExtractoITF}: DESC="${descripcionExtracto.substring(0, 40)}...", |IMPORTE|=${montoExtractoAbs}`);
                    }
                }
                
                // // console.log(`üè¶ SANT PASO 11 - EXTRACTO: ${candidatosExtractoITF} candidatos CARGO POR ITF encontrados`);
                
                if (candidatosExtractoITF === 0) {
                    // // console.log(`‚ö†Ô∏è SANT: No se encontraron candidatos CARGO POR ITF en extracto`);
                    return { candidatos: candidatosLibro09ITF, candidatosExtracto: 0, conciliados: 0 };
                }
                
                // === 3. MAPEAR: SUMA HABER vs SUMA |IMPORTE| ===
                const totalMayorHaber = candidatosMayorITF.reduce((suma, item) => suma + item.haber, 0);
                const totalExtractoImporte = extractoITF.reduce((suma, item) => suma + item.monto, 0);
                
                // // console.log(`üè¶ SANT PASO 11 - TOTALES:`);
                // // console.log(`   üìã Total MAYOR HABER: ${totalMayorHaber.toFixed(2)} (${candidatosMayorITF.length} registros)`);
                // // console.log(`   üìã Total EXTRACTO |IMPORTE|: ${totalExtractoImporte.toFixed(2)} (${extractoITF.length} registros)`);
                
                // Verificar si los totales coinciden
                const diferenciaTotales = Math.abs(totalMayorHaber - totalExtractoImporte);
                const totalesCoinciden = diferenciaTotales < 0.01; // Tolerancia para decimales
                
                // // console.log(`   üí∞ Diferencia: ${diferenciaTotales.toFixed(4)}`);
                // // console.log(`   üí∞ ¬øTotales coinciden? ${totalesCoinciden ? '‚úÖ S√ç' : '‚ùå NO'}`);
                
                if (totalesCoinciden) {
                    // CONCILIACI√ìN EXITOSA: Asignar estados a TODOS los registros
                    const refMayor = extractoITF.length > 0 ? extractoITF[0].referencia : 'SANT-ITF';
                    const refExtracto = candidatosMayorITF.length > 0 ? `${candidatosMayorITF[0].libro}-${candidatosMayorITF[0].comprob}` : '09-ITF';
                    
                    // Asignar estados a TODOS los registros del mayor ITF
                    candidatosMayorITF.forEach((item, idx) => {
                        estadosFilas.set(item.indice, {
                            estado: 'P11 - Conciliada',
                            ref: refMayor
                        });
                        // // console.log(`   ‚úÖ SANT Mayor ${idx + 1}: GLOSA="${item.glosa.substring(0, 20)}...", HABER=${item.haber} ‚Üí REF="${refMayor}"`);
                    });
                    
                    // Asignar estados a TODOS los registros del extracto ITF
                    extractoITF.forEach((item, idx) => {
                        estadosExtracto.set(item.indiceOriginal, {
                            estado: 'P11 - Conciliada',
                            ref: refExtracto
                        });
                        // // console.log(`   ‚úÖ SANT Extracto ${idx + 1}: DESC="${item.descripcion.substring(0, 20)}...", IMPORTE=${item.monto} ‚Üí REF="${refExtracto}"`);
                    });
                    
                    conciliados = candidatosMayorITF.length + extractoITF.length;
                    
                    // // console.log(`‚úÖ SANT PASO 11 COMPLETADO: ${conciliados} registros conciliados (${candidatosMayorITF.length} mayor + ${extractoITF.length} extracto)`);
                } else {
                    // // console.log(`‚ùå SANT PASO 11: Los totales NO coinciden`);
                }
                
                return {
                    candidatos: candidatosLibro09ITF,
                    candidatosExtracto: candidatosExtractoITF,
                    conciliados: conciliados,
                    totalMayor: totalMayorHaber,
                    totalExtracto: totalExtractoImporte,
                    diferencia: diferenciaTotales
                };
            },

            procesarPaso11BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 11 BBVA - ITF ESPEC√çFICO:
                
                ESTRATEGIA ESPEC√çFICA:
                - Mayor: GLOSA contiene "ITF" + HABER
                - Extracto: Concepto contiene "ITF", identificar total de operaciones
                - Mapeo: Suma HABER (Mayor) vs suma |IMPORTE| (Extracto)
                
                HEADERS BBVA: F. Operaci√≥n, F. Valor, C√≥digo, N¬∫. Doc., Concepto, Importe, Oficina, ESTADO, #REF
                
                ESTADOS RESULTANTES:
                - "P11 - Conciliada"
                - Mayor: #REF = [Primera referencia del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del primer registro Mayor ITF
                */
                
                // Paso 11 BBVA ITF
                // Estad√≠sticas iniciales BBVA ITF
                
                let candidatosMayorITF = 0;
                let candidatosExtractoITF = 0;
                let conciliados = 0;
                
                // === 1. IDENTIFICAR ITF EN MAYOR ===
                // // console.log(`\nüèõÔ∏è === ETAPA 1: IDENTIFICACI√ìN ITF EN MAYOR ===`);
                const candidatosMayor = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    const libro = filaMayor[idxM.libro] || '';
                    
                    // Verificar si GLOSA contiene "ITF" y tiene HABER
                    if (glosa.includes('ITF') && haber > 0) {
                        candidatosMayorITF++;
                        candidatosMayor.push({
                            indice: i,
                            fila: filaMayor,
                            glosa: glosa,
                            haber: haber,
                            debe: debe,
                            comprob: comprob,
                            libro: libro
                        });
                        
                        if (candidatosMayorITF <= 10) {
                            // // console.log(`üìù Mayor ITF ${candidatosMayorITF}: GLOSA="${glosa.substring(0, 40)}...", HABER=${haber.toFixed(2)}, LIBRO="${libro}"`);
                        }
                    }
                }
                
                // // console.log(`üìä MAYOR - Candidatos ITF encontrados: ${candidatosMayorITF}`);
                
                if (candidatosMayorITF === 0) {
                    // // console.log(`‚ö†Ô∏è BBVA: No se encontraron candidatos ITF en Mayor`);
                    return { candidatos: 0, candidatosExtracto: 0, conciliados: 0 };
                }
                
                // === 2. IDENTIFICAR "ITF" EN EXTRACTO BBVA ===
                // // console.log(`\nüè¶ === ETAPA 2: IDENTIFICACI√ìN ITF EN EXTRACTO BBVA ===`);
                const extractoITF = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fOperacion = filaExtracto[0] || ''; // F. Operaci√≥n (Col A)
                    const concepto = (filaExtracto[4] || '').toString().toUpperCase(); // Concepto (Col E)
                    const importe = this.normalizarMonto(filaExtracto[5] || '0'); // Importe (Col F)
                    
                    // Verificar si Concepto contiene "ITF"
                    if (concepto.includes('ITF')) {
                        candidatosExtractoITF++;
                        extractoITF.push({
                            indice: i,
                            fila: filaExtracto,
                            fOperacion: fOperacion,
                            concepto: concepto,
                            importe: importe,
                            importeAbsoluto: Math.abs(importe)
                        });
                        
                        if (candidatosExtractoITF <= 10) {
                            // Extracto ITF procesado
                        }
                    }
                }
                
                // Candidatos ITF encontrados
                
                if (candidatosExtractoITF === 0) {
                    // No se encontraron candidatos ITF
                    return { candidatos: candidatosMayorITF, candidatosExtracto: 0, conciliados: 0 };
                }
                
                // === 3. MAPEAR: SUMA HABER vs SUMA |IMPORTE| ===
                // Etapa 3: Mapeo total
                const totalMayorHaber = candidatosMayor.reduce((suma, item) => suma + item.haber, 0);
                const totalExtractoImporte = extractoITF.reduce((suma, item) => suma + item.importeAbsoluto, 0);
                const diferenciaTotales = Math.abs(totalMayorHaber - totalExtractoImporte);
                
                // Totales ITF calculados
                
                // Verificar si los totales coinciden (diferencia < 0.01)
                if (diferenciaTotales < 0.01) {
                    // Totales coinciden, conciliando
                    
                    // Conciliar todos los registros del Mayor ITF
                    candidatosMayor.forEach((candidato, idx) => {
                        estadosFilas.set(candidato.indice, {
                            estado: 'P11 - Conciliada',
                            ref: `BBVA-ITF-${idx + 1}`
                        });
                    });
                    
                    // Conciliar todos los registros del Extracto ITF
                    extractoITF.forEach((item, idx) => {
                        estadosExtracto.set(item.indice, {
                            estado: 'P11 - Conciliada',
                            ref: `ITF-${candidatosMayor[0]?.libro || 'XX'}-${candidatosMayor[0]?.comprob || 'XXXX'}`
                        });
                    });
                    
                    conciliados = candidatosMayor.length + extractoITF.length;
                    
                    // // console.log(`‚úÖ BBVA PASO 11 COMPLETADO: ${conciliados} registros conciliados (${candidatosMayor.length} mayor + ${extractoITF.length} extracto)`);
                } else {
                    // // console.log(`‚ùå BBVA PASO 11: Los totales NO coinciden - Diferencia: ${diferenciaTotales.toFixed(2)}`);
                }
                
                // // console.log(`\nüìä RESUMEN FINAL PASO 11 BBVA:`);
                // // console.log(`‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
                // // console.log(`‚îÇ       CONCEPTO      ‚îÇ  VALOR  ‚îÇ`);
                // // console.log(`‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§`);
                // // console.log(`‚îÇ Candidatos Mayor    ‚îÇ ${candidatosMayorITF.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Candidatos Extracto ‚îÇ ${candidatosExtractoITF.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Total Mayor HABER   ‚îÇ ${totalMayorHaber.toFixed(2).padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Total Extracto |IMP|‚îÇ ${totalExtractoImporte.toFixed(2).padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ Diferencia          ‚îÇ ${diferenciaTotales.toFixed(2).padStart(7)} ‚îÇ`);
                // // console.log(`‚îÇ REGISTROS CONCILIAD ‚îÇ ${conciliados.toString().padStart(7)} ‚îÇ`);
                // // console.log(`‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`);
                
                return {
                    candidatos: candidatosMayorITF,
                    candidatosExtracto: candidatosExtractoITF,
                    conciliados: conciliados,
                    totalMayor: totalMayorHaber,
                    totalExtracto: totalExtractoImporte,
                    diferencia: diferenciaTotales
                };
            },

            procesarPaso11SBP(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 11 SBP (SCOTIABANK) - ITF ESPEC√çFICO:
                
                Mayor (EST√ÅNDAR): 
                - LIBRO = "09" + GLOSA contiene "ITF" + ESTADO = "Pendiente"
                - Suma total HABER de todos los registros ITF
                
                Extracto SBP (ESPEC√çFICO):
                - Movimiento contiene "IMPUESTO" 
                - IDENTIFICAR TOTAL DE OPERACIONES "IMPUESTO"
                - Suma total |IMPORTE| de todos los registros IMPUESTO
                
                MAPEO:
                - Suma HABER (Mayor) vs suma |IMPORTE| (Extracto)
                
                ESTADOS RESULTANTES:
                - "P11 - Conciliada" para todos los registros si totales coinciden
                */
                
                // // console.log(`\nüí∞ === PASO 11 SBP: ITF IMPUESTO ===`);
                // // console.log(`üîç Total filas Mayor a revisar: ${filasFiltradasMayor.length}`);
                // // console.log(`üîç Total filas Extracto disponibles: ${extractoProcesable.length}`);
                // // console.log(`üîç Estados ya procesados - Mayor: ${estadosFilas.size}, Extracto: ${estadosExtracto.size}`);
                
                let candidatosMayorITF = 0;
                let candidatosExtractoITF = 0;
                let conciliados = 0;
                
                // === 1. IDENTIFICAR ITF EN MAYOR (L√ìGICA EST√ÅNDAR) ===
                const candidatosITFMayor = [];
                let totalMayorHaber = 0;
                
                // // console.log(`\nüîç === PASO 11 SBP: ANALIZANDO MAYOR ITF ===`);
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue; // Solo procesar pendientes
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                                    // Debug: mostrar los primeros registros
                if (i < 10) {
                    const glosaSafe = glosa ? glosa.substring(0, 40) : '';
                    // // console.log(`üìã Mayor ${i}: LIBRO="${libro}" GLOSA="${glosaSafe}..." HABER=${haber}`);
                }
                    
                    // Verificar criterios ITF: LIBRO = "09" + GLOSA contiene "ITF"
                    const esITF = String(libro || '').trim() === '09' && glosa.includes('ITF') && haber > 0;
                    
                    if (esITF) {
                        candidatosMayorITF++;
                        totalMayorHaber += haber;
                        
                        // // console.log(`‚úÖ MAYOR ITF ${candidatosMayorITF}: LIBRO=${libro} HABER=${haber} GLOSA="${glosa.substring(0, 40)}..."`);
                        
                        candidatosITFMayor.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            haber: haber,
                            comprob: comprob
                        });
                    }
                }
                
                // // console.log(`üìä Mayor ITF: ${candidatosMayorITF} candidatos, TOTAL HABER=${totalMayorHaber.toFixed(2)}`);
                
                // === 2. IDENTIFICAR IMPUESTO EN EXTRACTO SBP ===
                const candidatosImpuestoExtracto = [];
                let totalExtractoImporte = 0;
                
                // Analizando extracto SBP
                
                for (let j = 0; j < extractoProcesable.length; j++) {
                    if (estadosExtracto.has(j)) continue; // Solo procesar pendientes
                    
                    const itemExtracto = extractoProcesable[j];
                    const filaExtracto = itemExtracto.fila;
                    const movimiento = (filaExtracto[idxE.descripcion] || '').toString().toUpperCase();
                    const importe = this.normalizarMonto(filaExtracto[idxE.monto] || '0');
                    const operacion = filaExtracto[idxE.operacion] || '';
                    
                    // Debug: mostrar los primeros registros
                    if (j < 10) {
                        // // console.log(`üìã Extracto ${j}: movimiento="${movimiento.substring(0, 30)}..." importe=${Math.abs(importe).toFixed(2)}`);
                    }
                    
                    // Verificar criterios IMPUESTO: Movimiento contiene "IMPUESTO"
                    if (movimiento.includes('IMPUESTO') && importe !== 0) {
                        candidatosExtractoITF++;
                        totalExtractoImporte += Math.abs(importe);
                        
                        // Extracto impuesto procesado
                        
                        candidatosImpuestoExtracto.push({
                            indice: j,
                            fila: filaExtracto,
                            movimiento: movimiento,
                            importe: Math.abs(importe),
                            operacion: operacion
                        });
                    }
                }
                
                // Resumen extracto impuesto
                
                // === 3. MAPEAR TOTALES MAYOR vs EXTRACTO ===
                // Mapeando totales SBP
                
                const diferenciaTotales = Math.abs(totalMayorHaber - totalExtractoImporte);
                
                // Comparando totales SBP
                
                if (diferenciaTotales < 0.01 && candidatosMayorITF > 0 && candidatosExtractoITF > 0) {
                    // ‚úÖ MATCH ENCONTRADO - Conciliar todos los registros
                    const refExtracto = candidatosImpuestoExtracto.length > 0 ? candidatosImpuestoExtracto[0].operacion : '';
                    const refMayor = candidatosITFMayor.length > 0 ? `${candidatosITFMayor[0].libro}-${candidatosITFMayor[0].comprob}` : '';
                    
                    // // console.log(`‚úÖ MATCH! Conciliando ${candidatosMayorITF} Mayor ITF + ${candidatosExtractoITF} Extracto IMPUESTO`);
                    
                    // Marcar todos los ITF del Mayor como conciliados
                    candidatosITFMayor.forEach(item => {
                        estadosFilas.set(item.indice, {
                            estado: 'P11 - Conciliada',
                            ref: refExtracto
                        });
                        conciliados++;
                        const glosaSafe = item.glosa ? item.glosa.substring(0, 30) : '';
                        // // console.log(`   ‚úÖ Mayor ITF ${item.indice}: "${glosaSafe}..." ‚Üí REF="${refExtracto}"`);
                    });
                    
                    // Marcar todos los IMPUESTO del Extracto como conciliados
                    candidatosImpuestoExtracto.forEach(item => {
                        estadosExtracto.set(item.indice, {
                            estado: 'P11 - Conciliada',
                            ref: refMayor
                        });
                        conciliados++;
                        const movSafe = item.movimiento ? item.movimiento.substring(0, 30) : '';
                        // Extracto ITF conciliado
                    });
                } else {
                    // No match por diferencia o candidatos insuficientes
                }
                
                // SBP Paso 11 completado
                
                return {
                    candidatos: candidatosMayorITF,
                    candidatosExtracto: candidatosExtractoITF,
                    conciliados: conciliados,
                    totalMayor: totalMayorHaber,
                    totalExtracto: totalExtractoImporte,
                    diferencia: diferenciaTotales
                };
            },

            procesarPaso12(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 12 - CONCILIACI√ìN MULTI-CRITERIO PROGRESIVA:
                
                ESTRATEGIA PROGRESIVA:
                - Etapa 12A: Tolerancia Ampliada (¬±5.0) - FECHA exacta + MONTO flexible
                - Etapa 12B: Fechas Aproximadas (¬±2 d√≠as) - MONTO exacto + FECHA flexible
                - Etapa 12C: Solo Montos Exactos - Ignorar fechas completamente
                
                CRITERIOS:
                - Solo registros PENDIENTES de cualquier libro
                - Cada etapa toma lo que la anterior no pudo conciliar
                - Normalizaci√≥n completa de fechas y montos
                
                ESTADOS RESULTANTES:
                - "P12 - Conciliaci√≥n A" (tolerancia ampliada)
                - "P12 - Conciliaci√≥n B" (fechas aproximadas)
                - "P12 - Conciliaci√≥n C" (solo montos exactos)
                
                REFERENCIAS:
                - Mayor: #REF = [Operaci√≥n - N√∫mero del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                // // // console.log(`üìà PASO 12: Iniciando conciliaci√≥n MULTI-CRITERIO PROGRESIVA`);
                // // console.log(`üîç Total filas a revisar: ${filasFiltradasMayor.length}`);
                // // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                let conciliadosEtapa12A = 0;
                let conciliadosEtapa12B = 0;
                let conciliadosEtapa12C = 0;
                
                // Identificar candidatos PENDIENTES (cualquier libro)
                const candidatosPendientes = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Determinar monto principal (DEBE o HABER, el que sea mayor)
                    const montoPrincipal = Math.max(debe, haber);
                    
                    if (montoPrincipal > 0) {
                        candidatosPendientes.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            fdoc: fdoc,
                            debe: debe,
                            haber: haber,
                            montoPrincipal: montoPrincipal,
                            comprob: comprob
                        });
                    }
                }
                
                // // // console.log(`üìä PASO 12 - CANDIDATOS PENDIENTES:`);
                // // console.log(`   üéØ Total registros pendientes: ${candidatosPendientes.length}`);
                
                if (candidatosPendientes.length === 0) {
                    // // // console.log(`‚ö†Ô∏è No se encontraron registros pendientes para PASO 12`);
                    return { etapa12a: 0, etapa12b: 0, etapa12c: 0, totalConciliados: 0 };
                }
                
                // ETAPA 12A: Tolerancia Ampliada (¬±5.0)
                // // console.log(`\nüéØ ETAPA 12A: Tolerancia Ampliada (¬±5.0)`);
                conciliadosEtapa12A = this.procesarEtapa12A(candidatosPendientes, extractoProcesable, idxE, estadosFilas, estadosExtracto);
                // // console.log(`   ‚úÖ Etapa 12A: ${conciliadosEtapa12A} conciliaciones con tolerancia ampliada`);
                
                // ETAPA 12B: Fechas Aproximadas (¬±2 d√≠as)
                // // console.log(`\nüéØ ETAPA 12B: Fechas Aproximadas (¬±2 d√≠as)`);
                conciliadosEtapa12B = this.procesarEtapa12B(candidatosPendientes, extractoProcesable, idxE, estadosFilas, estadosExtracto);
                // // console.log(`   ‚úÖ Etapa 12B: ${conciliadosEtapa12B} conciliaciones con fechas aproximadas`);
                
                // ETAPA 12C: Solo Montos Exactos
                // // console.log(`\nüéØ ETAPA 12C: Solo Montos Exactos (ignorar fechas)`);
                conciliadosEtapa12C = this.procesarEtapa12C(candidatosPendientes, extractoProcesable, idxE, estadosFilas, estadosExtracto);
                // // console.log(`   ‚úÖ Etapa 12C: ${conciliadosEtapa12C} conciliaciones por montos exactos`);
                
                const totalConciliados = conciliadosEtapa12A + conciliadosEtapa12B + conciliadosEtapa12C;
                
                // // // console.log(`üìä PASO 12 - RESUMEN COMPLETO:`);
                // // console.log(`   üéØ Registros pendientes iniciales: ${candidatosPendientes.length}`);
                // // console.log(`   üÖ∞Ô∏è Etapa 12A (Tolerancia ¬±5.0): ${conciliadosEtapa12A} conciliaciones`);
                // // console.log(`   üÖ±Ô∏è Etapa 12B (Fechas ¬±2 d√≠as): ${conciliadosEtapa12B} conciliaciones`);
                // // console.log(`   üÖ≤ Etapa 12C (Solo montos): ${conciliadosEtapa12C} conciliaciones`);
                // // console.log(`   üìà TOTAL conciliado: ${totalConciliados} registros`);
                // // console.log(`   üí∞ Estrategia: Conciliaci√≥n progresiva multi-criterio`);
                
                return {
                    candidatos: candidatosPendientes.length,
                    etapa12a: conciliadosEtapa12A,
                    etapa12b: conciliadosEtapa12B,
                    etapa12c: conciliadosEtapa12C,
                    totalConciliados: totalConciliados
                };
            },

            procesarEtapa12A(candidatosPendientes, extractoProcesable, idxE, estadosFilas, estadosExtracto) {
                /*
                ETAPA 12A - TOLERANCIA AMPLIADA:
                - FECHA exacta + MONTO con tolerancia ¬±5.0
                - Estado: "P12 - Conciliaci√≥n A"
                */
                let conciliados = 0;
                
                for (const candidato of candidatosPendientes) {
                    // Saltar si ya fue procesado
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    const match = this.buscarMatchPorToleranciaAmpliada(candidato.fdoc, candidato.montoPrincipal, extractoProcesable, idxE, estadosExtracto);
                    
                    if (match.encontrado) {
                        const refMayor = match.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P12 - Conciliaci√≥n A',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(match.indice, {
                            estado: 'P12 - Conciliaci√≥n A',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                        // // console.log(`‚úÖ ETAPA 12A - CONCILIACI√ìN:`);
                        // // console.log(`   üìã Mayor: LIBRO=${candidato.libro}, FDOC="${candidato.fdoc}", MONTO=${candidato.montoPrincipal}, COMPROB=${candidato.comprob} ‚Üí REF="${refMayor}"`);
                        // // console.log(`   üìã Extracto: FECHA="${match.fecha}", MONTO=${match.monto}, Diferencia: ${match.diferencia.toFixed(4)} ‚Üí REF="${refExtracto}"`);
                    }
                }
                
                return conciliados;
            },

            procesarEtapa12B(candidatosPendientes, extractoProcesable, idxE, estadosFilas, estadosExtracto) {
                /*
                ETAPA 12B - FECHAS APROXIMADAS:
                - MONTO exacto (tolerancia ¬±0.1) + FECHA ¬±2 d√≠as
                - Estado: "P12 - Conciliaci√≥n B"
                */
                let conciliados = 0;
                
                for (const candidato of candidatosPendientes) {
                    // Saltar si ya fue procesado
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    const match = this.buscarMatchPorFechasAproximadas(candidato.fdoc, candidato.montoPrincipal, extractoProcesable, idxE, estadosExtracto);
                    
                    if (match.encontrado) {
                        const refMayor = match.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P12 - Conciliaci√≥n B',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(match.indice, {
                            estado: 'P12 - Conciliaci√≥n B',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                        // // console.log(`‚úÖ ETAPA 12B - CONCILIACI√ìN:`);
                        // // console.log(`   üìã Mayor: LIBRO=${candidato.libro}, FDOC="${candidato.fdoc}", MONTO=${candidato.montoPrincipal}, COMPROB=${candidato.comprob} ‚Üí REF="${refMayor}"`);
                        // // console.log(`   üìã Extracto: FECHA="${match.fecha}", MONTO=${match.monto}, Diferencia d√≠as: ${match.diferenciaDias} ‚Üí REF="${refExtracto}"`);
                    }
                }
                
                return conciliados;
            },

            procesarEtapa12C(candidatosPendientes, extractoProcesable, idxE, estadosFilas, estadosExtracto) {
                /*
                ETAPA 12C - SOLO MONTOS EXACTOS:
                - Solo MONTO exacto (tolerancia ¬±0.1), ignorar fechas
                - Estado: "P12 - Conciliaci√≥n C"
                */
                let conciliados = 0;
                
                for (const candidato of candidatosPendientes) {
                    // Saltar si ya fue procesado
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    const match = this.buscarMatchSoloMonto(candidato.montoPrincipal, extractoProcesable, idxE, estadosExtracto);
                    
                    if (match.encontrado) {
                        const refMayor = match.operacionNumero;
                        const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                        
                        // Asignar estados
                        estadosFilas.set(candidato.indice, {
                            estado: 'P12 - Conciliaci√≥n C',
                            ref: refMayor
                        });
                        
                        estadosExtracto.set(match.indice, {
                            estado: 'P12 - Conciliaci√≥n C',
                            ref: refExtracto
                        });
                        
                        conciliados++;
                        
                        // // console.log(`‚úÖ ETAPA 12C - CONCILIACI√ìN:`);
                        // // console.log(`   üìã Mayor: LIBRO=${candidato.libro}, MONTO=${candidato.montoPrincipal}, COMPROB=${candidato.comprob} ‚Üí REF="${refMayor}"`);
                        // // console.log(`   üìã Extracto: FECHA="${match.fecha}", MONTO=${match.monto} (fecha ignorada) ‚Üí REF="${refExtracto}"`);
                    }
                }
                
                return conciliados;
            },

            buscarMatchPorToleranciaAmpliada(fdocMayor, montoMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                ETAPA 12A: FECHA exacta + MONTO con tolerancia ¬±5.0
                */
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[6] || '';
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtracto = Math.abs(this.normalizarMonto(montoExtractoRaw));
                    
                    // FECHA exacta + MONTO tolerancia ¬±5.0
                    const fechasCoinciden = fechaMayorNormalizada === fechaExtractoNormalizada;
                    const diferenciaMonto = Math.abs(montoMayor - montoExtracto);
                    const montosCoinciden = diferenciaMonto <= 5.0; // Tolerancia ampliada
                    
                    if (fechasCoinciden && montosCoinciden) {
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            diferencia: diferenciaMonto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                return { encontrado: false };
            },

            buscarMatchPorFechasAproximadas(fdocMayor, montoMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                ETAPA 12B: MONTO exacto (¬±0.1) + FECHA ¬±2 d√≠as
                */
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                if (!fechaMayorNormalizada) return { encontrado: false };
                
                const fechaMayorObj = new Date(fechaMayorNormalizada);
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[6] || '';
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtracto = Math.abs(this.normalizarMonto(montoExtractoRaw));
                    
                    if (!fechaExtractoNormalizada) continue;
                    const fechaExtractoObj = new Date(fechaExtractoNormalizada);
                    
                    // MONTO exacto + FECHA ¬±2 d√≠as
                    const diferenciaMonto = Math.abs(montoMayor - montoExtracto);
                    const montosCoinciden = diferenciaMonto <= 0.1; // Tolerancia normal
                    
                    const diferenciaDias = Math.abs((fechaMayorObj - fechaExtractoObj) / (1000 * 60 * 60 * 24));
                    const fechasAproximadas = diferenciaDias <= 2; // ¬±2 d√≠as
                    
                    if (montosCoinciden && fechasAproximadas) {
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            diferenciaDias: diferenciaDias,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                return { encontrado: false };
            },

            buscarMatchSoloMonto(montoMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                ETAPA 12C: Solo MONTO exacto (¬±0.1), ignorar fechas completamente
                */
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[6] || '';
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtracto = Math.abs(this.normalizarMonto(montoExtractoRaw));
                    
                    // Solo MONTO exacto (ignorar fechas)
                    const diferenciaMonto = Math.abs(montoMayor - montoExtracto);
                    const montosCoinciden = diferenciaMonto <= 0.1; // Tolerancia normal
                    
                    if (montosCoinciden) {
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                return { encontrado: false };
            },

            buscarMatchExtractoPorGrupo(fechaGrupo, totalHaber, extractoProcesable, idxE, estadosExtracto) {
                /*
                Busca un match en el extracto para PASO 5 (grupos):
                - Compara fecha del grupo vs FECHA (Extracto col A)
                - Compara total HABER del grupo vs |MONTO| (Extracto col D en VALOR ABSOLUTO)
                - Retorna datos del match si se encuentra
                NOTA: Los montos del extracto est√°n en negativo, se usa Math.abs()
                */
                
                // // // console.log(`üîç Buscando match para grupo: fecha="${fechaGrupo}", total=${totalHaber}`);
                
                let candidatosRevisados = 0;
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    // // console.log(`‚ùå Error: extractoProcesable no es v√°lido`);
                    return { encontrado: false };
                }
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    candidatosRevisados++;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    const fechaExtractoRaw = filaExtracto[idxE.fecha] || '';
                    const montoExtractoRaw = filaExtracto[idxE.monto] || '0';
                    const operacionNumero = filaExtracto[6] || ''; // Columna G - Operaci√≥n N√∫mero
                    
                    // Normalizar fecha y monto del extracto
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtractoRaw);
                    const montoExtractoRaw_parsed = this.normalizarMonto(montoExtractoRaw);
                    const montoExtracto = Math.abs(montoExtractoRaw_parsed); // VALOR ABSOLUTO para extracto
                    
                    // Comparar fechas y montos
                    const fechasCoinciden = fechaGrupo === fechaExtractoNormalizada;
                    const diferenciaMonto = Math.abs(totalHaber - montoExtracto);
                    const montosCoinciden = diferenciaMonto === 0; // Exacto
                    
                    // if (candidatosRevisados <= 5) {
                    //     // // console.log(`   üîç Candidato ${candidatosRevisados}:`);
                    //     // // console.log(`      Fecha: "${fechaExtractoRaw}" ‚Üí "${fechaExtractoNormalizada}" | Match: ${fechasCoinciden ? '‚úÖ' : '‚ùå'}`);
                    //     // // console.log(`      Monto: ${montoExtractoRaw} ‚Üí abs(${montoExtracto}) | Diferencia: ${diferenciaMonto.toFixed(4)} | Match: ${montosCoinciden ? '‚úÖ' : '‚ùå'}`);
                    // }
                    
                    if (fechasCoinciden && montosCoinciden) {
                        // // // console.log(`‚úÖ MATCH COMPLETO encontrado en √≠ndice ${i}`);
                        // // // console.log(`   üìã Operaci√≥n-N√∫mero del extracto: "${operacionNumero}" (se asignar√° a todas las filas del grupo)`);
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtractoNormalizada,
                            monto: montoExtracto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                // // // console.log(`‚ùå No se encontr√≥ match despu√©s de revisar ${candidatosRevisados} candidatos`);
                return { encontrado: false };
            },

            buscarMatchExtracto(fdocMayor, debeMayor, extractoProcesable, idxE, estadosExtracto) {
                /*
                Busca un match en el extracto para PASO 4:
                - Compara FDOC (Mayor) vs FECHA (Extracto col A)
                - Compara DEBE (Mayor) vs |MONTO| (Extracto col D en VALOR ABSOLUTO)
                - Retorna datos del match si se encuentra
                NOTA: Los montos del extracto est√°n en negativo, se usa Math.abs()
                */
                
                const fechaMayorNormalizada = this.normalizarFecha(fdocMayor);
                // // // console.log(`üîç Buscando match para FDOC="${fdocMayor}" (normalizado: "${fechaMayorNormalizada}"), DEBE=${debeMayor}`);
                
                let candidatosRevisados = 0;
                let mejoresMatches = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Saltar si ya est√° procesado
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila; // Acceder a la fila dentro del objeto
                    const fechaExtracto = filaExtracto[0] || ''; // Columna A
                    const montoExtractoRaw = this.normalizarMonto(filaExtracto[3] || '0'); // Columna D
                    const montoExtracto = Math.abs(montoExtractoRaw); // VALOR ABSOLUTO para extracto
                    const operacionNumero = filaExtracto[6] || ''; // Columna G
                    
                    const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                    
                    // Comparar fechas y montos
                    const fechasCoinciden = fechaMayorNormalizada && fechaExtractoNormalizada && fechaMayorNormalizada === fechaExtractoNormalizada;
                    const diferenciaMontos = Math.abs(debeMayor - montoExtracto);
                    const montosCoinciden = diferenciaMontos === 0; // Exacto para PASO 4
                    
                    candidatosRevisados++;
                    
                    // Log detallado solo para matches prometedores
                    if (fechasCoinciden || montosCoinciden || candidatosRevisados <= 2) {
                        // // // console.log(`   üîç Candidato ${candidatosRevisados} (√≠ndice ${i}):`);
                        // // // console.log(`      Fecha: "${fechaExtracto}" ‚Üí "${fechaExtractoNormalizada}" | Match: ${fechasCoinciden ? '‚úÖ' : '‚ùå'}`);
                        // // // console.log(`      Monto: ${montoExtractoRaw} ‚Üí abs(${montoExtracto}) | Diferencia: ${diferenciaMontos.toFixed(4)} | Match: ${montosCoinciden ? '‚úÖ' : '‚ùå'}`);
                        // // // console.log(`      Operaci√≥n: "${operacionNumero}"`);
                        
                        if (fechasCoinciden || montosCoinciden) {
                            mejoresMatches.push({
                                indice: i,
                                fechaMatch: fechasCoinciden,
                                montoMatch: montosCoinciden,
                                diferenciaMonto: diferenciaMontos,
                                fechaExtracto: fechaExtracto,
                                montoExtracto: montoExtracto
                            });
                        }
                    }
                    
                    if (fechasCoinciden && montosCoinciden) {
                        // // console.log(`‚úÖ MATCH COMPLETO encontrado en √≠ndice ${i}`);
                        return {
                            encontrado: true,
                            indice: i,
                            fecha: fechaExtracto,
                            monto: montoExtracto,
                            operacionNumero: operacionNumero
                        };
                    }
                }
                
                // // console.log(`‚ùå No se encontr√≥ match completo. Revisados: ${candidatosRevisados} candidatos`);
                if (mejoresMatches.length > 0) {
                    // // console.log(`   üìã Mejores candidatos parciales:`);
                    mejoresMatches.slice(0, 3).forEach((match, idx) => {
                        // // console.log(`      ${idx + 1}. Fecha ${match.fechaMatch ? '‚úÖ' : '‚ùå'}, Monto ${match.montoMatch ? '‚úÖ' : '‚ùå'} (diff: ${match.diferenciaMonto.toFixed(4)})`);
                    });
                }
                
                return {
                    encontrado: false,
                    indice: -1,
                    fecha: '',
                    monto: 0,
                    operacionNumero: ''
                };
            },

            normalizarFecha(fechaRaw) {
                /*
                Normaliza fechas a formato YYYY-MM-DD para comparaci√≥n
                Maneja m√∫ltiples formatos de entrada:
                - DD/MM/YYYY, DD-MM-YYYY
                - YYYY/MM/DD, YYYY-MM-DD
                - DD/MM/YY, etc.
                - N√∫meros seriales de Excel (45809 = d√≠as desde 1900-01-01)
                */
                
                // DEBUG GENERAL
                // if (fechaRaw && fechaRaw.toString().includes('2025.06')) {
                //     console.log(`üîß ENTRADA normalizarFecha: "${fechaRaw}"`);
                // }
                
                if (!fechaRaw) return '';
                
                const fechaStr = fechaRaw.toString().trim();
                if (!fechaStr) return '';
                
                // Detectar si es un n√∫mero serial de Excel (5 d√≠gitos aproximadamente)
                const numeroSerial = parseFloat(fechaStr);
                if (!isNaN(numeroSerial) && numeroSerial > 1 && numeroSerial < 100000 && !fechaStr.includes('/') && !fechaStr.includes('-') && !fechaStr.includes('.')) {
                    const fechaConvertida = this.convertirSerialExcelAFecha(numeroSerial);
                    // MEJORADO: Log para m√°s casos espec√≠ficos que estamos analizando
                    // if (numeroSerial >= 45800 && numeroSerial <= 45900) {
                    //     // // console.log(`üîÑ FECHA Serial Excel ${numeroSerial} ‚Üí "${fechaConvertida}"`);
                    // }
                    return fechaConvertida;
                }
                
                // Limpiar y detectar separadores para fechas normales
                const separadores = ['-', '/', '.'];
                let separador = null;
                
                for (const sep of separadores) {
                    if (fechaStr.includes(sep)) {
                        separador = sep;
                        break;
                    }
                }
                
                if (!separador) {
                    return '';
                }
                
                const partes = fechaStr.split(separador);
                if (partes.length !== 3) {
                    return '';
                }
                
                let dia, mes, ano;
                
                // Detectar formato basado en longitud y valores
                const [p1, p2, p3] = partes.map(p => parseInt(p, 10));
                
                // DEBUG: Log para parseo DET
                // if (fechaStr.includes('2025.06.30')) {
                //     console.log(`üîß DEBUG PARSEO: "${fechaStr}" ‚Üí p1=${p1}, p2=${p2}, p3=${p3}, separador="${separador}"`);
                //     console.log(`üîß Condiciones: p1>1900=${p1 > 1900}, p1<2100=${p1 < 2100}, separador==='.'=${separador === '.'}`);
                // }
                
                // FORMATO DET ESPEC√çFICO: aaaa.mm.dd (ejemplo: 2025.06.03)
                if (p1 > 1900 && p1 < 2100 && separador === '.') {
                    // Formato DET: YYYY.MM.DD
                    ano = p1;
                    mes = p2;
                    dia = p3;
                    // if (fechaStr.includes('2025.06.30')) {
                    //     console.log(`üîß TOMANDO RUTA DET: ano=${ano}, mes=${mes}, dia=${dia}`);
                    // }
                } else if (p1 > 31) {
                    // Formato YYYY-MM-DD o YYYY-DD-MM
                    ano = p1;
                    if (p2 > 12) {
                        mes = p3;
                        dia = p2;
                    } else {
                        mes = p2;
                        dia = p3;
                    }
                } else if (p3 > 31 || (p3 > 24 && p3 < 100)) {
                    // Formato DD-MM-YYYY o MM-DD-YYYY
                    ano = p3 < 100 ? 2000 + p3 : p3;
                    if (p1 > 12) {
                        dia = p1;
                        mes = p2;
                    } else if (p2 > 12) {
                        dia = p2;
                        mes = p1;
                    } else {
                        // Asumir DD-MM-YYYY
                        dia = p1;
                        mes = p2;
                    }
                } else {
                    return '';
                }
                
                // Validar rangos
                if (mes < 1 || mes > 12 || dia < 1 || dia > 31 || ano < 1900) {
                    return '';
                }
                
                // Formatear con ceros a la izquierda
                const mesStr = mes.toString().padStart(2, '0');
                const diaStr = dia.toString().padStart(2, '0');
                
                const resultado = `${ano}-${mesStr}-${diaStr}`;
                
                // DEBUG: Log resultado final
                // if (fechaStr.includes('2025.06.30')) {
                //     console.log(`üîß RESULTADO FINAL: "${fechaStr}" ‚Üí "${resultado}"`);
                // }
                
                return resultado;
            },

            convertirSerialExcelAFecha(serial) {
                /*
                Convierte n√∫meros seriales de Excel a fechas
                Excel usa 1899-12-30 como d√≠a 0, 1900-01-01 como d√≠a 2 (bug hist√≥rico)
                */
                
                // Fecha base de Excel: 1899-12-30 00:00:00 (d√≠a 0)
                const fechaBase = new Date(1899, 11, 30, 0, 0, 0, 0);
                
                // Agregar los d√≠as directamente
                const fechaResultado = new Date(fechaBase.getTime() + serial * 24 * 60 * 60 * 1000);
                
                // Formatear a YYYY-MM-DD
                const a√±o = fechaResultado.getFullYear();
                const mes = (fechaResultado.getMonth() + 1).toString().padStart(2, '0');
                const dia = fechaResultado.getDate().toString().padStart(2, '0');
                
                return `${a√±o}-${mes}-${dia}`;
            },

            procesarPaso3(filaMayor, extracto, idxM, idxE, todasLasFilasMayor, saldoData = null, indiceFilaActual = -1) {
        /*
        PASO 3 - PROCESAMIENTO DE DOCUMENTOS ANULADOS (3 ETAPAS):
        
        ETAPA 3a: Filtrar por GLOSA contiene "ANULADO" (se hace en el bucle principal)
        ETAPA 3b: Mayor vs Saldo por NUMDOC ‚Üí ESTADO="P3 - Conciliada", REF="Anulado Saldo" (PRIMERO)
        ETAPA 3c: Mayor interno por NUMDOC + coincidencia exacta (SEGUNDO):
        - DEBE ‚Üí ESTADO="P3 - Conciliada", REF="Anula a [valor_comprob]" 
        - HABER ‚Üí ESTADO="P3 - Conciliada", REF="Anulado por [valor_comprob]"
        */
        
        const glosa = filaMayor[idxM.glosa] || '';
        
        // ETAPA 3a: Verificar si tiene "ANULADO" en GLOSA
        if (!glosa.toUpperCase().includes("ANULADO")) {
            return { estado: '', ref: '', etapa: 0 };
        }
        
        const fecha = filaMayor[idxM.fdoc];
        const montoDebe = this.normalizarMonto(filaMayor[idxM.debe] || 0);
        const montoHaber = this.normalizarMonto(filaMayor[idxM.haber] || 0);
        const numdoc = filaMayor[idxM.numdoc] || '';
        const comprob = filaMayor[idxM.comprob] || '';
        
        // Determinar si est√° en DEBE o HABER y el monto a buscar
        const estaEnDebe = montoDebe > 0;
        const montoABuscar = estaEnDebe ? montoDebe : montoHaber;
        
        // // // console.log(`üîç PASO 3 procesando: NUMDOC=${numdoc}, DEBE=${montoDebe}, HABER=${montoHaber}, estaEnDebe=${estaEnDebe}`);
        
        // ETAPA 3b: MAPEAR MAYOR VS SALDO POR NUMDOC ‚Üí ESTADO="P3 - Conciliada", REF="Anulado Saldo" (PRIMERO)
        if (saldoData && saldoData.length > 1) {
            // Mapear √≠ndices del saldo
            const headerSaldo = saldoData[0] || [];
            const indicesSaldo = this.buscarIndicesColumnas(headerSaldo, {
                cuenta: ['CUENTA'], numdoc: ['NUMDOC'], debe: ['DEBE'], haber: ['HABER'], 
                fdoc: ['FDOC'], comprobante: ['COMPROBANTE', 'COMPROB']
            });
            
            const filasSaldo = saldoData.slice(1);
            
            // Normalizar NUMDOC del mayor para comparaci√≥n
            const numdocMayorNormalizado = this.normalizarTexto(numdoc);
            
            for (let idx = 0; idx < filasSaldo.length; idx++) {
                const filaSaldo = filasSaldo[idx];
                const numdocSaldoRaw = filaSaldo[indicesSaldo.numdoc] || '';
                const numdocSaldoNormalizado = this.normalizarTexto(numdocSaldoRaw);
                const debeSaldoRaw = filaSaldo[indicesSaldo.debe] || '';
                const haberSaldoRaw = filaSaldo[indicesSaldo.haber] || '';
                
                // Normalizar y parsear montos
                const debeSaldo = this.normalizarMonto(debeSaldoRaw);
                const haberSaldo = this.normalizarMonto(haberSaldoRaw);
                
                // Columna M (√≠ndice 12) para Comprobante
                const comprobanteSaldo = filaSaldo[12] || filaSaldo[indicesSaldo.comprobante] || '';
                
                // Buscar por NUMDOC normalizado
                if (numdocMayorNormalizado && numdocSaldoNormalizado && numdocMayorNormalizado === numdocSaldoNormalizado) {
                    // // console.log(`   üéØ MATCH NUMDOC encontrado en fila ${idx + 2} del saldo:`);
                    // // console.log(`      Mayor NUMDOC: "${numdoc}" ‚Üí normalizado: "${numdocMayorNormalizado}"`);
                    // // console.log(`      Saldo NUMDOC: "${numdocSaldoRaw}" ‚Üí normalizado: "${numdocSaldoNormalizado}"`);
                    // // console.log(`      Saldo DEBE raw: "${debeSaldoRaw}" ‚Üí parseado: ${debeSaldo}`);
                    // // console.log(`      Saldo HABER raw: "${haberSaldoRaw}" ‚Üí parseado: ${haberSaldo}`);
                    // // console.log(`      Saldo Comprobante (col M): "${comprobanteSaldo}"`);
                    // // console.log(`      Mayor: DEBE=${montoDebe}, HABER=${montoHaber}, estaEnDebe=${estaEnDebe}, montoABuscar=${montoABuscar}`);
                    
                    // Comparar tanto DEBE como HABER del saldo con el monto del mayor
                    const diferenciaDebe = Math.abs(montoABuscar - debeSaldo);
                    const diferenciaHaber = Math.abs(montoABuscar - haberSaldo);
                    
                    // // console.log(`      Comparando montos:`);
                    // // console.log(`        Mayor ${estaEnDebe ? 'DEBE' : 'HABER'}=${montoABuscar} vs Saldo DEBE=${debeSaldo}, diferencia=${diferenciaDebe}`);
                    // // console.log(`        Mayor ${estaEnDebe ? 'DEBE' : 'HABER'}=${montoABuscar} vs Saldo HABER=${haberSaldo}, diferencia=${diferenciaHaber}`);
                    
                    // Si cualquiera de las dos diferencias es exacta, es un match
                    if (diferenciaDebe === 0 || diferenciaHaber === 0) {
                        const mejorMatch = diferenciaDebe < diferenciaHaber ? 'DEBE' : 'HABER';
                        const mejorDiferencia = Math.min(diferenciaDebe, diferenciaHaber);
                        // // // console.log(`‚úÖ ETAPA 3b - ANULADO SALDO: Mayor NUMDOC=${numdoc} ‚Üî Saldo NUMDOC=${numdocSaldoRaw}`);
                        // // // console.log(`   üìã Mejor match: Saldo ${mejorMatch} (diferencia: ${mejorDiferencia})`);
                        // // // console.log(`   üìã REF asignado: "${comprobanteSaldo}"`);
                        return { 
                            estado: 'P3 - Conciliada', 
                            ref: 'Anulado Saldo', 
                            etapa: 2,
                            indiceParejaEncontrada: idx,
                            estadoPareja: 'P3 - Conciliada',
                            refPareja: 'Anulado Mayor'
                        };
                    } else {
                        // // console.log(`   ‚ùå Montos no coinciden (mejores diferencias: DEBE=${diferenciaDebe}, HABER=${diferenciaHaber})`);
                    }
                }
            }
            
        } else {
            // // // console.log(`‚ö†Ô∏è ETAPA 3b: No hay datos de saldo disponibles`);
        }
        
        // ETAPA 3c: MAPEAR DENTRO DEL MAYOR POR NUMDOC CON DEBE/HABER (SEGUNDO)
        // // // console.log(`‚ö° ETAPA 3c: Buscando mapeo interno en mayor para NUMDOC=${numdoc}`);
        // // // console.log(`   üìã Registro actual: DEBE=${montoDebe}, HABER=${montoHaber} ‚Üí busca ${estaEnDebe ? 'HABER' : 'DEBE'} con monto ${montoABuscar}`);
        
        let candidatosEncontrados = 0;
        const numdocMayorNormalizado = this.normalizarTexto(numdoc);
        const candidatosDetalle = [];
        
        for (let i = 0; i < todasLasFilasMayor.length; i++) {
            const otraFila = todasLasFilasMayor[i];
            
            // Saltar la misma fila
            if (otraFila === filaMayor) continue;
            
            const otroMontoDebe = this.normalizarMonto(otraFila[idxM.debe] || 0);
            const otroMontoHaber = this.normalizarMonto(otraFila[idxM.haber] || 0);
            const otroNumdocRaw = otraFila[idxM.numdoc] || '';
            const otroNumdocNormalizado = this.normalizarTexto(otroNumdocRaw);
            const otroComprob = otraFila[idxM.comprob] || '';
            const otraGlosa = otraFila[idxM.glosa] || '';
            
            // Criterios: mismo NUMDOC normalizado
            const coincidenNumdoc = numdocMayorNormalizado && otroNumdocNormalizado && (numdocMayorNormalizado === otroNumdocNormalizado);
            
            if (coincidenNumdoc) {
                candidatosEncontrados++;
                
                // Verificar si est√° en la columna contraria y con el mismo monto (exacto)
                const montoAComparar = estaEnDebe ? otroMontoHaber : otroMontoDebe;
                const diferenciaMonto = Math.abs(montoAComparar - montoABuscar);
                const coincideMonto = diferenciaMonto === 0;
                
                // Guardar detalles del candidato
                candidatosDetalle.push({
                    fila: i + 1,
                    numdoc: otroNumdocRaw,
                    debe: otroMontoDebe,
                    haber: otroMontoHaber,
                    comprob: otroComprob,
                    montoComparar: montoAComparar,
                    diferencia: diferenciaMonto,
                    coincide: coincideMonto
                });
                
                // // console.log(`   üîç Candidato ${candidatosEncontrados}: NUMDOC="${otroNumdocRaw}" (fila ${i + 1})`);
                // // console.log(`      Este: DEBE=${montoDebe}, HABER=${montoHaber}, busca ${estaEnDebe ? 'HABER' : 'DEBE'}=${montoABuscar}`);
                // // console.log(`      Otro: DEBE=${otroMontoDebe}, HABER=${otroMontoHaber}, encontrado=${montoAComparar}`);
                // // console.log(`      Diferencia: ${diferenciaMonto.toFixed(4)} ${coincideMonto ? '‚úÖ COINCIDE' : '‚ùå NO COINCIDE'}`);
                // // console.log(`      COMPROB: "${otroComprob}"`);
                
                if (coincideMonto) {
                    // // // console.log(`\n‚úÖ ETAPA 3c - ¬°ANULACI√ìN ENCONTRADA!`);
                    // // // console.log(`   üéØ NUMDOC: ${numdoc} (normalizado: ${numdocMayorNormalizado})`);
                    // // // console.log(`   üìã Registro A (actual): DEBE=${montoDebe}, HABER=${montoHaber}, COMPROB="${comprob}"`);
                    // // // console.log(`   üìã Registro B (pareja): DEBE=${otroMontoDebe}, HABER=${otroMontoHaber}, COMPROB="${otroComprob}"`);
                    // // // console.log(`   üí∞ Monto que coincide: ${montoABuscar}`);
                    
                    // Determinar estados seg√∫n DEBE/HABER y usar COMPROB de la pareja
                    if (estaEnDebe) {
                        // Este registro est√° en DEBE ‚Üí "Anula a [comprob_de_la_pareja]"
                        // La pareja est√° en HABER ‚Üí "Anulado por [comprob_de_este]"
                        // // console.log(`   ‚úÖ Este registro (DEBE) ANULA AL OTRO (HABER)`);
                        // // console.log(`   üìã Este: ESTADO="P3 - Conciliada", REF="Anula a ${otroComprob}"`);
                        // // console.log(`   üìã Pareja: ESTADO="P3 - Conciliada", REF="Anulado por ${comprob}"`);
                        
                        return { 
                            estado: 'P3 - Conciliada', 
                            ref: `Anula a ${otroComprob}`, 
                            etapa: 3,
                            indiceParejaEncontrada: i,
                            estadoPareja: 'P3 - Conciliada',
                            refPareja: `Anulado por ${comprob}`
                        };
                    } else {
                        // Este registro est√° en HABER ‚Üí "Anulado por [comprob_de_la_pareja]"
                        // La pareja est√° en DEBE ‚Üí "Anula a [comprob_de_este]"
                        // // console.log(`   ‚úÖ Este registro (HABER) ES ANULADO POR EL OTRO (DEBE)`);
                        // // console.log(`   üìã Este: ESTADO="P3 - Conciliada", REF="Anulado por ${otroComprob}"`);
                        // // console.log(`   üìã Pareja: ESTADO="P3 - Conciliada", REF="Anula a ${comprob}"`);
                        
                        return { 
                            estado: 'P3 - Conciliada', 
                            ref: `Anulado por ${otroComprob}`, 
                            etapa: 3,
                            indiceParejaEncontrada: i,
                            estadoPareja: 'P3 - Conciliada',
                            refPareja: `Anula a ${comprob}`
                        };
                    }
                }
            }
        }
        
        // Si llegamos aqu√≠, mostrar resumen
        // // // console.log(`   üìä ETAPA 3c - Resumen: ${candidatosEncontrados} candidatos con mismo NUMDOC`);
        if (candidatosDetalle.length > 0) {
            // // // console.log(`   üìã Candidatos encontrados:`);
            candidatosDetalle.forEach((cand, idx) => {
                // // // console.log(`      ${idx + 1}. Fila ${cand.fila}: DEBE=${cand.debe}, HABER=${cand.haber}, diff=${cand.diferencia.toFixed(4)} ${cand.coincide ? '‚úÖ' : '‚ùå'}`);
            });
        }
        
        // Si llegamos aqu√≠, no se pudo procesar la anulaci√≥n
        // // // console.log(`‚ùå PASO 3 - No procesado: NUMDOC=${numdoc} (${candidatosEncontrados} candidatos internos encontrados)`);
        return { 
            estado: '', 
            ref: '', 
            etapa: 0,
            indiceParejaEncontrada: -1,
            estadoPareja: '',
            refPareja: ''
        };
            },
     
            buscarIndicesColumnas(headers, mapeo) {
         const indices = {};
         for (const [clave, posiblesNombres] of Object.entries(mapeo)) {
            let encontrado = false;
             for (let i = 0; i < headers.length; i++) {
                 const header = (headers[i] || '').toString().toUpperCase().trim();
                if (posiblesNombres.some(nombre => header.includes(nombre.toUpperCase()))) {
                         indices[clave] = i;
                    encontrado = true;
                         break;
                     }
                 }
            if (!encontrado) indices[clave] = -1;
         }
         return indices;
            },
     
            // Funci√≥n para normalizar texto (eliminar espacios, convertir a may√∫sculas)
            normalizarTexto(texto) {
                if (!texto) return '';
                let normalizado = texto.toString().trim().toUpperCase().replace(/\s+/g, '');
                
                // Si es un n√∫mero puro, eliminar ceros a la izquierda pero mantener al menos un d√≠gito
                if (/^\d+$/.test(normalizado)) {
                    normalizado = normalizado.replace(/^0+/, '') || '0';
                }
                
                return normalizado;
            },
            
            // Funci√≥n para normalizar y parsear montos
            normalizarMonto(montoRaw) {
                if (!montoRaw) return 0;
                
                // Convertir a string y limpiar espacios
                let montoStr = montoRaw.toString().trim().replace(/\s+/g, '');
                
                // Si est√° vac√≠o despu√©s de limpiar, retornar 0
                if (!montoStr) return 0;
                
                // Detectar diferentes formatos de n√∫meros
                let montoLimpio;
                let tipoFormato = '';
                
                // NUEVO: Manejar n√∫meros negativos
                const esNegativo = montoStr.startsWith('-');
                if (esNegativo) {
                    montoStr = montoStr.substring(1);
                }
                
                // Formato 1: Solo n√∫meros con coma decimal (18956,26)
                if (/^\d+,\d+$/.test(montoStr)) {
                    montoLimpio = montoStr.replace(',', '.');
                    tipoFormato = 'europeo simple';
                }
                // Formato 2: Formato europeo con separador de miles punto y decimal coma (46.744,48)
                else if (/^\d{1,3}(\.\d{3})+,\d{2,}$/.test(montoStr)) {
                    montoLimpio = montoStr.replace(/\./g, '').replace(',', '.');
                    tipoFormato = 'europeo con separador miles';
                }
                // Formato 3: Formato americano con separador de miles coma y decimal punto (46,744.48)
                else if (/^\d{1,3}(,\d{3})+\.\d{2,}$/.test(montoStr)) {
                    montoLimpio = montoStr.replace(/,/g, '');
                    tipoFormato = 'americano con separador miles';
                }
                // Formato 4: Solo punto decimal (18956.26)
                else if (/^\d+\.\d+$/.test(montoStr)) {
                    montoLimpio = montoStr;
                    tipoFormato = 'decimal punto';
                }
                // Formato 5: Solo n√∫meros enteros (18956)
                else if (/^\d+$/.test(montoStr)) {
                    montoLimpio = montoStr;
                    tipoFormato = 'entero';
                }
                // MEJORADO: Formato mixto problem√°tico - detectar contexto
                else if (montoStr.includes(',') && montoStr.includes('.')) {
                    // Si hay m√°s puntos que comas, probablemente sea europeo (46.744,48)
                    const puntos = (montoStr.match(/\./g) || []).length;
                    const comas = (montoStr.match(/,/g) || []).length;
                    
                    if (puntos > comas) {
                        // Europeo: punto separador miles, coma decimal
                        montoLimpio = montoStr.replace(/\./g, '').replace(',', '.');
                        tipoFormato = 'mixto - europeo detectado';
                    } else {
                        // Americano: coma separador miles, punto decimal
                        montoLimpio = montoStr.replace(/,/g, '');
                        tipoFormato = 'mixto - americano detectado';
                    }
                }
                // Por defecto: eliminar todo excepto n√∫meros y punto
                else {
                    montoLimpio = montoStr.replace(/[^0-9.]/g, '');
                    tipoFormato = 'limpieza general';
                }
                
                let monto = parseFloat(montoLimpio);
                if (isNaN(monto)) monto = 0;
                
                // Aplicar signo negativo si corresponde
                if (esNegativo) monto = -monto;
                
                const resultado = monto;
                
                // MEJORADO: Log detallado para casos espec√≠ficos y problem√°ticos
                // if (montoStr.includes('46744') || montoStr.includes('46.744') || 
                //     montoStr.includes('18956') || montoStr.includes('27788') ||
                //     resultado === 0 || tipoFormato.includes('mixto') || tipoFormato === 'limpieza general') {
                //     // // console.log(`üí∞ MONTO "${montoStr}" (${tipoFormato}) ‚Üí ${resultado.toFixed(2)}`);
                // }
                
                return resultado;
            },

            // === FACTORY DE ESTRATEGIAS POR CUENTA ===
            
            // Ejecutar estrategia espec√≠fica por cuenta y paso (simplificado)
            executeAccountStrategy(codigoCuenta, numeroPaso, ...args) {
                const estrategia = this.getEstrategiaProcesamiento(codigoCuenta, numeroPaso);
                
                // Por ahora, usar l√≥gica existente con estrategia como par√°metro adicional
                // En el futuro aqu√≠ se implementar√° la l√≥gica espec√≠fica por banco
                return this[`procesarPaso${numeroPaso}`](...args);
            },
            
            // Procesar l√≥gica espec√≠fica por cuenta (preparado para futuro)
            processAccountSpecificLogic(codigoCuenta, paso, data) {
                const config = this.cuentasConfig[codigoCuenta];
                if (!config || !config.activo) {
                    return null;
                }
                
                const estrategia = config.pasos[`paso${paso}`];
                
                // Placeholder para futuras implementaciones espec√≠ficas
                switch (estrategia) {
                    case 'anulaciones_bcp02':
                        return this.procesarAnulacionesBCP02(data);
                    case 'depositos_bancarios_bcp02':
                        return this.procesarDepositosBCP02(data);
                    case 'anulaciones_santander':
                        return this.procesarAnulacionesSantander(data);
                    case 'anulaciones_ibk':
                        return this.procesarAnulacionesIBK(data);
                    default:
                        return null; // Usar l√≥gica est√°ndar
                }
            },

            procesarPaso9BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 9 BBVA - AGRUPACI√ìN POR COMISIONES:
                
                CRITERIOS DE FILTRADO:
                - GLOSA debe contener "COMISION REC" (Mayor)
                - Concepto debe contener "COMISION REC" (BBVA Extracto)
                
                ESTRATEGIA:
                1. Agrupar por FDOC + TOTAL HABER (Mayor)
                2. Agrupar por F. Operaci√≥n + |Total importe| (BBVA Extracto)
                3. Comparar grupos por fecha y monto total
                
                MAPEO:
                - FDOC + TOTAL HABER (Mayor) ‚Üî F. Operaci√≥n + |Total importe| (BBVA Extracto)
                
                ESTADOS RESULTANTES:
                - "P9 - Conciliada" para ambos registros
                - Mayor: #REF = [Operaci√≥n - N√∫mero del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                // // console.log(`üè¶ PASO 9 BBVA: Iniciando procesamiento de comisiones`);
                // // console.log(`üîç Total filas Mayor a revisar: ${filasFiltradasMayor.length}`);
                // // console.log(`üîç Total filas Extracto BBVA a revisar: ${extractoProcesable.length}`);
                
                let candidatosComisionRec = 0;
                let gruposMayorFormados = 0;
                let gruposExtractoFormados = 0;
                let conciliados = 0;
                
                // === 1. AGRUPAR POR COMISIONES EN MAYOR ===
                const gruposPorComisionMayor = new Map();
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const numdoc = filaMayor[idxM.numdoc] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const libro = filaMayor[idxM.libro] || '';
                    const comprob = filaMayor[idxM.comprob] || '';
                    const glosa = filaMayor[idxM.glosa] || '';
                    
                    // Verificar si GLOSA contiene "COMISION REC"
                    const glosaUpper = glosa.toString().toUpperCase().trim();
                    const esComisionRec = glosaUpper.includes('COMISION REC');
                    
                    if (esComisionRec) {
                        // Contar candidatos de comisi√≥n
                        candidatosComisionRec++;
                        
                        // Debug: Mostrar los primeros 3 candidatos del Mayor
                        if (candidatosComisionRec <= 3) {
                            // // console.log(`üîç Mayor Candidato ${candidatosComisionRec}: NUMDOC="${numdoc}", FDOC="${fdoc}", HABER=${haber}, GLOSA="${glosa}"`);
                        }
                        
                        // Crear clave de agrupaci√≥n solo por FECHA (no por monto individual)
                        const fechaNormalizada = this.normalizarFecha(fdoc);
                        const claveGrupo = fechaNormalizada;
                        
                        if (!gruposPorComisionMayor.has(claveGrupo)) {
                            gruposPorComisionMayor.set(claveGrupo, {
                                fecha: fechaNormalizada,
                                fechaOriginal: fdoc,
                                totalHaber: 0,
                                filas: []
                            });
                        }
                        
                        const grupo = gruposPorComisionMayor.get(claveGrupo);
                        grupo.totalHaber += haber;
                        grupo.filas.push({
                            indice: i,
                            fila: filaMayor,
                            numdoc: numdoc,
                            fdoc: fdoc,
                            haber: haber,
                            libro: libro,
                            comprob: comprob,
                            glosa: glosa
                        });
                    }
                }
                
                gruposMayorFormados = gruposPorComisionMayor.size;
                
                // // console.log(`üìä PASO 9 BBVA - AGRUPACI√ìN MAYOR:`);
                // // console.log(`   üí∞ Candidatos COMISION REC (GLOSA): ${candidatosComisionRec}`);
                // // console.log(`   üîó Grupos formados: ${gruposMayorFormados}`);
                
                // Debug: Mostrar los primeros 3 grupos formados en el mayor
                let grupoNumMayor = 1;
                for (const [fecha, grupo] of gruposPorComisionMayor.entries()) {
                    if (grupoNumMayor <= 3) {
                        // // console.log(`   üìÖ Grupo ${grupoNumMayor}: Fecha="${fecha}", Total=${grupo.totalHaber.toFixed(2)}, Registros=${grupo.filas.length}`);
                    }
                    grupoNumMayor++;
                }
                
                if (gruposMayorFormados === 0) {
                    // // console.log(`‚ö†Ô∏è No se encontraron grupos de comisiones en Mayor para PASO 9 BBVA`);
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                // === 2. AGRUPAR POR COMISIONES EN EXTRACTO BBVA ===
                const gruposPorComisionExtracto = new Map();
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // === MAPEO ESPEC√çFICO BBVA CORREGIDO ===
                    // Columna A (√≠ndice 0): F. Operaci√≥n
                    // Columna F (√≠ndice 5): Importe
                    // Columna D (√≠ndice 3): N¬∫. Doc.
                    // Columna E (√≠ndice 4): Concepto
                    const fechaOperacion = filaExtracto[0] || '';
                    const importe = filaExtracto[5] || '0'; // √çndice 5 - Importe
                    const operacionNumero = filaExtracto[3] || ''; // √çndice 3 - N¬∫. Doc.
                    const concepto = filaExtracto[4] || ''; // √çndice 4 - Concepto
                    
                    // Verificar si concepto CONTIENE "COMISION REC"
                    const conceptoUpper = concepto.toString().toUpperCase().trim();
                    const esComisionRecExtracto = conceptoUpper.includes('COMISION REC');
                    
                    if (esComisionRecExtracto) {
                        const fechaNormalizada = this.normalizarFecha(fechaOperacion);
                        const montoOriginal = this.normalizarMonto(importe); // SIN valor absoluto a√∫n
                        
                        // Debug: Mostrar estructura y primeros 3 candidatos del extracto BBVA
                        if (gruposPorComisionExtracto.size < 3) {
                            // // console.log(`üîç Extracto BBVA Candidato ${gruposPorComisionExtracto.size + 1}:`);
                            // // console.log(`   ESTRUCTURA: [${filaExtracto.slice(0, 8).map((col, idx) => `${idx}:"${col}"`).join(', ')}]`);
                            // // console.log(`   F.Operaci√≥n[0]="${fechaOperacion}"‚Üí"${fechaNormalizada}", Importe[5]="${importe}"‚Üí${montoOriginal}, Concepto[4]="${concepto}"`);
                        }
                        
                        // Crear clave de agrupaci√≥n solo por FECHA (no por monto individual)
                        const claveGrupo = fechaNormalizada;
                        
                        if (!gruposPorComisionExtracto.has(claveGrupo)) {
                            gruposPorComisionExtracto.set(claveGrupo, {
                                fecha: fechaNormalizada,
                                fechaOriginal: fechaOperacion,
                                totalImporte: 0, // Suma directa SIN valor absoluto
                                filas: []
                            });
                        }
                        
                        const grupo = gruposPorComisionExtracto.get(claveGrupo);
                        grupo.totalImporte += montoOriginal; // Sumar con signo original
                        grupo.filas.push({
                            indice: i,
                            fila: filaExtracto,
                            fecha: fechaOperacion,
                            importe: importe,
                            montoOriginal: montoOriginal,
                            operacionNumero: operacionNumero,
                            concepto: concepto
                        });
                    }
                }
                
                gruposExtractoFormados = gruposPorComisionExtracto.size;
                
                // // console.log(`üìä PASO 9 BBVA - AGRUPACI√ìN EXTRACTO:`);
                // // console.log(`   üîó Grupos formados: ${gruposExtractoFormados}`);
                
                // Debug: Mostrar los primeros 3 grupos formados en el extracto
                let grupoNum = 1;
                for (const [fecha, grupo] of gruposPorComisionExtracto.entries()) {
                    if (grupoNum <= 3) {
                        // // console.log(`   üìÖ Grupo ${grupoNum}: Fecha="${fecha}", Total=${grupo.totalImporte.toFixed(2)}, |Total|=${Math.abs(grupo.totalImporte).toFixed(2)}, Registros=${grupo.filas.length}`);
                    }
                    grupoNum++;
                }
                
                if (gruposExtractoFormados === 0) {
                    // // console.log(`‚ö†Ô∏è No se encontraron grupos de comisiones en Extracto BBVA para PASO 9`);
                    return { candidatos: candidatosComisionRec, grupos: gruposMayorFormados, conciliados: 0 };
                }
                
                // === 3. COMPARAR GRUPOS Y CONCILIAR ===
                // // console.log(`\nüîç PASO 9 BBVA - COMPARACI√ìN DE GRUPOS:`);
                
                for (const [claveMayor, grupoMayor] of gruposPorComisionMayor.entries()) {
                    // Buscar grupo correspondiente en extracto
                    const grupoExtracto = gruposPorComisionExtracto.get(claveMayor);
                    
                    if (grupoExtracto) {
                        // PASO 3: Comparar aplicando valor absoluto AL TOTAL del extracto
                        const totalMayor = grupoMayor.totalHaber;
                        const totalExtractoAbsoluto = Math.abs(grupoExtracto.totalImporte);
                        const diferenciaMonto = Math.abs(totalMayor - totalExtractoAbsoluto);
                        const montosCoinciden = diferenciaMonto === 0;
                        
                        // // console.log(`üîç Comparando grupo fecha "${claveMayor}": Mayor=${totalMayor.toFixed(2)} vs |BBVA|=${totalExtractoAbsoluto.toFixed(2)} (original: ${grupoExtracto.totalImporte.toFixed(2)}), Diferencia=${diferenciaMonto.toFixed(4)}`);
                        
                        if (montosCoinciden) {
                            // CONCILIACI√ìN EXITOSA: Asignar estados a TODOS los registros de ambos grupos
                            const refMayor = grupoExtracto.filas.length > 0 ? grupoExtracto.filas[0].operacionNumero : 'COMISION-GLOBAL';
                            const refExtracto = grupoMayor.filas.length > 0 ? `${grupoMayor.filas[0].libro}-${grupoMayor.filas[0].comprob}` : 'COMISION-MAYOR';
                            
                            // Asignar estados a TODOS los registros del mayor
                            grupoMayor.filas.forEach((item, idx) => {
                                estadosFilas.set(item.indice, {
                                    estado: 'P9 - Conciliada',
                                    ref: refMayor
                                });
                                
                                // // console.log(`   ‚úÖ Mayor ${idx + 1}/${grupoMayor.filas.length}: √çndice ${item.indice}, GLOSA="${item.glosa.substring(0, 30)}...", HABER=${item.haber} ‚Üí REF="${refMayor}"`);
                            });
                            
                            // Asignar estados a TODOS los registros del extracto
                            grupoExtracto.filas.forEach((item, idx) => {
                                estadosExtracto.set(item.indice, {
                                    estado: 'P9 - Conciliada',
                                    ref: refExtracto
                                });
                                
                                // // console.log(`   ‚úÖ Extracto ${idx + 1}/${grupoExtracto.filas.length}: √çndice ${item.indice}, CONCEPTO="${item.concepto.substring(0, 30)}...", IMPORTE=${item.montoOriginal} ‚Üí REF="${refExtracto}"`);
                            });
                            
                            conciliados += grupoMayor.filas.length + grupoExtracto.filas.length;
                            
                            // // console.log(`‚úÖ GRUPO CONCILIADO: FECHA="${grupoMayor.fecha}", TOTAL Mayor=${totalMayor.toFixed(2)}, TOTAL |Extracto|=${totalExtractoAbsoluto.toFixed(2)} (original: ${grupoExtracto.totalImporte.toFixed(2)})`);
                        }
                    }
                }
                
                // // console.log(`\nüìä PASO 9 BBVA - RESUMEN FINAL:`);
                // // console.log(`   üí∞ Total candidatos comisiones: ${candidatosComisionRec}`);
                // // console.log(`   üîó Grupos Mayor formados: ${gruposMayorFormados}`);
                // // console.log(`   üîó Grupos Extracto formados: ${gruposExtractoFormados}`);
                // // console.log(`   ‚úÖ Total registros conciliados: ${conciliados}`);
                
                return {
                    candidatos: candidatosComisionRec,
                    grupos: gruposMayorFormados,
                    conciliados: conciliados,
                    comisionRec: candidatosComisionRec
                };
            },

            procesarPaso12BBVA(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 12 BBVA USD - MAPEO DIRECTO POR MONTOS:
                
                ESTRATEGIA SIMPLIFICADA:
                1. Tomar todos los pendientes del Mayor (cualquier DEBE o HABER no cero)
                2. Tomar todos los pendientes del Extracto BBVA
                3. Mapear: MONTO Mayor (DEBE o HABER) ‚Üî |Monto| Extracto BBVA
                
                CRITERIO:
                - Coincidencia exacta de montos (con tolerancia m√≠nima)
                
                ESTADOS RESULTANTES:
                - "P12 - Conciliada" para ambos registros
                - Mayor: #REF = N√∫mero del Extracto
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                const esBBVAUSD = cuentaConfig && cuentaConfig.codigo === '1041202';
                if (esBBVAUSD) {
                    console.log(`üè¶ PASO 12 BBVA.USD: Mapeo directo por montos`);
                    console.log(`üîç Total filas Mayor a revisar: ${filasFiltradasMayor.length}`);
                    console.log(`üîç Total filas Extracto BBVA a revisar: ${extractoProcesable.length}`);
                }
                
                let candidatosMayor = 0;
                let candidatosExtracto = 0;
                let conciliados = 0;
                
                // === 1. RECOPILAR PENDIENTES DEL MAYOR ===
                const pendientesMayor = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    const libro = filaMayor[idxM.libro] || '';
                    
                    // Tomar el monto no cero (DEBE o HABER)
                    let montoMayor = 0;
                    if (debe !== 0) montoMayor = debe;
                    else if (haber !== 0) montoMayor = haber;
                    
                    if (montoMayor !== 0) {
                        candidatosMayor++;
                        
                        pendientesMayor.push({
                            indice: i,
                            fila: filaMayor,
                            monto: montoMayor,
                            comprob: comprob,
                            libro: libro,
                            tipo: debe !== 0 ? 'DEBE' : 'HABER'
                        });
                        
                        if (esBBVAUSD && candidatosMayor <= 5) {
                            console.log(`üîç Mayor[${i}]: ${montoMayor.toFixed(2)} (${debe !== 0 ? 'DEBE' : 'HABER'}) - LIBRO="${libro}", COMPROB="${comprob}"`);
                        }
                    }
                }
                
                if (esBBVAUSD) {
                    console.log(`üìä Mayor: ${candidatosMayor} candidatos encontrados`);
                }
                
                if (candidatosMayor === 0) {
                    if (esBBVAUSD) console.log(`‚ö†Ô∏è No se encontraron candidatos en Mayor para PASO 12 BBVA.USD`);
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                // === 2. RECOPILAR PENDIENTES DEL EXTRACTO ===
                const pendientesExtracto = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // Columna F (√≠ndice 5): Importe
                    // Columna D (√≠ndice 3): N¬∫. Doc.
                    const importe = filaExtracto[5] || '0';
                    const operacionNumero = filaExtracto[3] || '';
                    
                    const montoOriginal = this.normalizarMonto(importe);
                    const montoAbsoluto = Math.abs(montoOriginal);
                    
                    if (montoAbsoluto !== 0) {
                        candidatosExtracto++;
                        
                        pendientesExtracto.push({
                            indice: i,
                            fila: filaExtracto,
                            montoOriginal: montoOriginal,
                            montoAbsoluto: montoAbsoluto,
                            operacionNumero: operacionNumero
                        });
                        
                        if (esBBVAUSD && candidatosExtracto <= 5) {
                            console.log(`üîç Extracto[${i}]: ${montoAbsoluto.toFixed(2)} (orig: ${montoOriginal.toFixed(2)}) - DOC="${operacionNumero}"`);
                        }
                    }
                }
                
                if (esBBVAUSD) {
                    console.log(`üìä Extracto: ${candidatosExtracto} candidatos encontrados`);
                }
                
                if (candidatosExtracto === 0) {
                    if (esBBVAUSD) console.log(`‚ö†Ô∏è No se encontraron candidatos en Extracto para PASO 12 BBVA.USD`);
                    return { candidatos: candidatosMayor, grupos: 0, conciliados: 0 };
                }
                
                // === 3. MAPEO DIRECTO POR MONTOS ===
                if (esBBVAUSD) {
                    console.log(`\nüîç PASO 12 BBVA.USD - MAPEO DIRECTO:`);
                    console.log(`üìä ${pendientesMayor.length} pendientes Mayor vs ${pendientesExtracto.length} pendientes Extracto`);
                }
                
                const usadosExtracto = new Set();
                
                for (const pendienteMayor of pendientesMayor) {
                    const montoMayor = pendienteMayor.monto;
                    
                    // Buscar coincidencia en extracto
                    for (const pendienteExtracto of pendientesExtracto) {
                        if (usadosExtracto.has(pendienteExtracto.indice)) continue;
                        
                        const montoExtracto = pendienteExtracto.montoAbsoluto;
                        const diferencia = Math.abs(montoMayor - montoExtracto);
                        
                        if (diferencia < 0.01) { // Tolerancia de 1 centavo
                            // CONCILIACI√ìN DIRECTA EXITOSA
                            const refMayor = pendienteExtracto.operacionNumero || 'BBVA-DIRECTO';
                            const refExtracto = `${pendienteMayor.libro}-${pendienteMayor.comprob}` || 'MAYOR-DIRECTO';
                            
                            // Asignar estados
                            estadosFilas.set(pendienteMayor.indice, {
                                estado: 'P12 - Conciliada',
                                ref: refMayor
                            });
                            
                            estadosExtracto.set(pendienteExtracto.indice, {
                                estado: 'P12 - Conciliada',
                                ref: refExtracto
                            });
                            
                            usadosExtracto.add(pendienteExtracto.indice);
                            conciliados += 2;
                            
                            if (esBBVAUSD) {
                                console.log(`‚úÖ MAPEO: Mayor[${pendienteMayor.indice}] ${montoMayor.toFixed(2)} (${pendienteMayor.tipo}) ‚Üî Extracto[${pendienteExtracto.indice}] ${montoExtracto.toFixed(2)} (diff: ${diferencia.toFixed(2)})`);
                            }
                            break;
                        }
                    }
                }
                
                if (esBBVAUSD) {
                    console.log(`\nüìä PASO 12 BBVA.USD - RESUMEN FINAL:`);
                    console.log(`   üí∞ Candidatos Mayor: ${candidatosMayor}`);
                    console.log(`   üí∞ Candidatos Extracto: ${candidatosExtracto}`);
                    console.log(`   üéØ Total registros conciliados: ${conciliados}`);
                }
                
                return {
                    candidatos: candidatosMayor + candidatosExtracto,
                    grupos: 0, // No usamos grupos en la versi√≥n simplificada
                    conciliados: conciliados
                };
            },

            procesarPaso12SBPDirecto(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 12 SBP.USD - MAPEO DIRECTO POR MONTOS:
                
                ESTRATEGIA SIMPLIFICADA:
                1. Tomar todos los pendientes del Mayor (cualquier DEBE o HABER no cero)
                2. Tomar todos los pendientes del Extracto SBP
                3. Mapear: MONTO Mayor (DEBE o HABER) ‚Üî |Monto| Extracto SBP
                
                CRITERIO:
                - Coincidencia exacta de montos (tolerancia 0.01)
                
                ESTADOS RESULTANTES:
                - "P12 - Conciliada" para ambos registros
                - Mayor: #REF = Referencia del Extracto
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                console.log(`üè¶ PASO 12 SBP.USD: Mapeo directo por montos`);
                console.log(`üîç Total filas Mayor a revisar: ${filasFiltradasMayor.length}`);
                console.log(`üîç Total filas Extracto SBP a revisar: ${extractoProcesable.length}`);
                
                let candidatosMayor = 0;
                let candidatosExtracto = 0;
                let conciliados = 0;
                
                // === 1. RECOPILAR PENDIENTES DEL MAYOR ===
                const pendientesMayor = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    const libro = filaMayor[idxM.libro] || '';
                    
                    // Tomar el monto no cero (DEBE o HABER)
                    let montoMayor = 0;
                    if (debe !== 0) montoMayor = debe;
                    else if (haber !== 0) montoMayor = haber;
                    
                    if (montoMayor !== 0) {
                        candidatosMayor++;
                        
                        pendientesMayor.push({
                        indice: i,
                            fila: filaMayor,
                            monto: montoMayor,
                            comprob: comprob,
                            libro: libro,
                            tipo: debe !== 0 ? 'DEBE' : 'HABER'
                        });
                        
                        if (candidatosMayor <= 5) {
                            console.log(`üîç Mayor[${i}]: ${montoMayor.toFixed(2)} (${debe !== 0 ? 'DEBE' : 'HABER'}) - LIBRO="${libro}", COMPROB="${comprob}"`);
                        }
                    }
                }
                
                console.log(`üìä Mayor: ${candidatosMayor} candidatos encontrados`);
                
                if (candidatosMayor === 0) {
                    console.log(`‚ö†Ô∏è No se encontraron candidatos en Mayor para PASO 12 SBP.USD`);
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                // === 2. RECOPILAR PENDIENTES DEL EXTRACTO ===
                const pendientesExtracto = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    // Solo revisar filas no procesadas del extracto
                    if (estadosExtracto.has(i)) continue;
                    
                    const itemExtracto = extractoProcesable[i];
                    const filaExtracto = itemExtracto.fila;
                    
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // Para SBP: Importe suele estar en columna E (√≠ndice 4)
                    const importe = filaExtracto[4] || '0';
                    const referencia = filaExtracto[3] || ''; // Referencia en columna D (√≠ndice 3)
                    
                    const montoOriginal = this.normalizarMonto(importe);
                    const montoAbsoluto = Math.abs(montoOriginal);
                    
                    if (montoAbsoluto !== 0) {
                        candidatosExtracto++;
                        
                        pendientesExtracto.push({
                            indice: i,
                            fila: filaExtracto,
                            montoOriginal: montoOriginal,
                            montoAbsoluto: montoAbsoluto,
                            referencia: referencia
                        });
                        
                        if (candidatosExtracto <= 5) {
                            console.log(`üîç Extracto[${i}]: ${montoAbsoluto.toFixed(2)} (orig: ${montoOriginal.toFixed(2)}) - REF="${referencia}"`);
                        }
                    }
                }
                
                console.log(`üìä Extracto: ${candidatosExtracto} candidatos encontrados`);
                
                if (candidatosExtracto === 0) {
                    console.log(`‚ö†Ô∏è No se encontraron candidatos en Extracto para PASO 12 SBP.USD`);
                    return { candidatos: candidatosMayor, grupos: 0, conciliados: 0 };
                }
                
                // === 3. MAPEO DIRECTO POR MONTOS ===
                console.log(`\nüîç PASO 12 SBP.USD - MAPEO DIRECTO:`);
                console.log(`üìä ${pendientesMayor.length} pendientes Mayor vs ${pendientesExtracto.length} pendientes Extracto`);
                
                const usadosExtracto = new Set();
                
                for (const pendienteMayor of pendientesMayor) {
                    const montoMayor = pendienteMayor.monto;
                    
                    // Buscar coincidencia en extracto
                    for (const pendienteExtracto of pendientesExtracto) {
                        if (usadosExtracto.has(pendienteExtracto.indice)) continue;
                        
                        const montoExtracto = pendienteExtracto.montoAbsoluto;
                        const diferencia = Math.abs(montoMayor - montoExtracto);
                        
                        if (diferencia < 0.01) { // Tolerancia de 1 centavo
                            // CONCILIACI√ìN DIRECTA EXITOSA
                            const refMayor = pendienteExtracto.referencia || 'SBP-DIRECTO';
                            const refExtracto = `${pendienteMayor.libro}-${pendienteMayor.comprob}` || 'MAYOR-DIRECTO';
                            
                            // Asignar estados
                            estadosFilas.set(pendienteMayor.indice, {
                                    estado: 'P12 - Conciliada',
                                    ref: refMayor
                                });
                                
                            estadosExtracto.set(pendienteExtracto.indice, {
                                    estado: 'P12 - Conciliada',
                                    ref: refExtracto
                                });
                                
                            usadosExtracto.add(pendienteExtracto.indice);
                            conciliados += 2;
                            
                            console.log(`‚úÖ MAPEO: Mayor[${pendienteMayor.indice}] ${montoMayor.toFixed(2)} (${pendienteMayor.tipo}) ‚Üî Extracto[${pendienteExtracto.indice}] ${montoExtracto.toFixed(2)} (diff: ${diferencia.toFixed(4)})`);
                            break;
                        }
                    }
                }
                
                console.log(`\nüìä PASO 12 SBP.USD - RESUMEN FINAL:`);
                console.log(`   üí∞ Candidatos Mayor: ${candidatosMayor}`);
                console.log(`   üí∞ Candidatos Extracto: ${candidatosExtracto}`);
                console.log(`   üéØ Total registros conciliados: ${conciliados}`);
                
                return {
                    candidatos: candidatosMayor + candidatosExtracto,
                    grupos: 0, // No usamos grupos en la versi√≥n simplificada
                    conciliados: conciliados
                };
            },

            // M√©todos placeholder para futuras implementaciones espec√≠ficas
            procesarAnulacionesBCP02(data) {
                // TODO: Implementar l√≥gica espec√≠fica BCP.02
                return { estado: 'Pendiente', ref: '' };
            },
            
            procesarDepositosBCP02(data) {
                // TODO: Implementar l√≥gica espec√≠fica BCP.02
                return { conciliados: 0 };
            },
            
            procesarAnulacionesSantander(data) {
                // TODO: Implementar l√≥gica espec√≠fica Santander
                return { estado: 'Pendiente', ref: '' };
            },

            procesarAnulacionesIBK(data) {
                // TODO: Implementar l√≥gica espec√≠fica IBK para anulaciones
                return { estado: 'Pendiente', ref: '' };
            },

            procesarPaso4IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 4 IBK - OPERACIONES BNA (DOS ETAPAS COMO OTROS BANCOS):
                
                ETAPA 1 - MAPEO EXTRACTO IBK vs MAYOR:
                CRITERIOS EXTRACTO:
                1. CRITERIO 1: Movimiento (Col E orig) = "FINANC. DE DOCS" Y Cargo (Col H orig) = "-8"
                   ‚Üí Importe = Cargo + Abono = (-8) + 0 = -8 (negativo)
                   
                2. CRITERIO 2: Descripci√≥n (Col F orig) = "FCD ABON.CTA" 
                   ‚Üí Importe = Cargo + Abono = 0 + (+monto) = +monto (positivo)
                   
                3. Agrupar por Fecha de operaci√≥n (Col B orig) del mismo d√≠a
                4. Para cada fila del grupo: Cargo + Abono, luego sumar todo el grupo
                
                CRITERIOS MAYOR:
                - DES_TDOP="Bna" + LIBRO="04" + DEBE > 0
                - Agrupar por FDOC, sumar DEBE
                
                MAPEO: FDOC + DEBE (Mayor) vs Fecha + Total Grupo (Extracto)
                
                ETAPA 2 - MAPEO INTERNO MAYOR (LIBRO 04 vs LIBRO 09):
                CRITERIOS:
                - Candidatos: LIBRO="04" + DEBE > 0 (pendientes de Etapa 1)
                - Destinos: LIBRO="09" + HABER > 0 
                - Mapeo: Mismo FDOC + DEBE = HABER (coincidencia exacta)
                
                ESTADOS RESULTANTES:
                - Etapa 1: "P4 - Conciliada", Extracto‚ÜíMayor, Mayor‚ÜíExtracto  
                - Etapa 2: "P4 - Conciliada", L04‚Üí"09-COMPROB", L09‚Üí"04-COMPROB"
                
                ESTRUCTURA IBK ORIGINAL (extractoProcesable):
                A=vac√≠o, B=Fecha operaci√≥n, C=Fecha proceso, D=Nro operaci√≥n, E=Movimiento, 
                F=Descripci√≥n, G=Canal, H=Cargo, I=Abono, J=Saldo contable
                
                ESTRUCTURA IBK REORGANIZADA (pesta√±a):
                A=Fecha operaci√≥n, B=Fecha proceso, C=Nro operaci√≥n, D=Movimiento, 
                E=Descripci√≥n, F=Canal, G=Cargo, H=Abono, I=Saldo, J=ESTADO, K=#REF
                */
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { conciliados: 0 };
                }
                
                // PASO 1: Buscar TODOS los registros candidatos del grupo IBK
                const candidatosGrupoIBK = [];
                
                // // console.log(`\nüîç === DEBUG IBK PASO 4 - BUSCANDO CANDIDATOS ===`);
                // // console.log(`üìä Total filas extracto procesable: ${extractoProcesable.length}`);
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) continue;
                    
                    const item = extractoProcesable[i];
                    const fila = item.fila;
                    if (!fila || !Array.isArray(fila)) continue;
                    
                    // IBK estructura ORIGINAL: A=vac√≠o, B=Fecha op, C=Fecha proc, D=Nro op, E=Movimiento, F=Descripci√≥n, G=Canal, H=Cargo, I=Abono, J=Saldo
                    const fechaOperacion = fila[1] || '';     // B (√≠ndice 1)
                    const fechaProceso = fila[2] || '';       // C (√≠ndice 2)
                    const nroOperacion = fila[3] || '';       // D (√≠ndice 3)
                    const movimiento = (fila[4] || '').toString();  // E (√≠ndice 4)
                    const descripcion = (fila[5] || '').toString(); // F (√≠ndice 5)
                    const canal = fila[6] || '';              // G (√≠ndice 6)
                    const cargo = (fila[7] || '').toString();       // H (√≠ndice 7)
                    const abono = fila[8] || '';              // I (√≠ndice 8)
                    const saldoContable = fila[9] || '';      // J (√≠ndice 9)
                    
                    // Debug de las primeras 3 filas para ver la estructura
                    if (i < 3) {
                        // // console.log(`üîç Fila ${i}: [${fila.slice(0, 9).map((col, idx) => `${idx}:"${col}"`).join(', ')}]`);
                        // // console.log(`   Fecha="${fechaOperacion}", Movimiento="${movimiento}", Descripci√≥n="${descripcion}", Cargo="${cargo}", Abono="${abono}"`);
                    }
                    
                    let esCandidata = false;
                    let tipoRegistro = '';
                    
                    // Criterio 1: FINANC. DE DOCS en MOVIMIENTO (col D) Y cargo -8 (col G)
                    if (movimiento.trim() === 'FINANC. DE DOCS' && cargo && cargo.trim() === '-8') {
                        esCandidata = true;
                        tipoRegistro = 'FINANC_DOCS';
                        // console.log(`‚úÖ CRITERIO 1 - FINANC_DOCS encontrado en fila ${i}: Mov="${movimiento}" Cargo="${cargo}"`);
                    }
                    
                    // Criterio 2: FCD ABON.CTA en DESCRIPCI√ìN (col E)
                    if (descripcion.trim() === 'FCD ABON.CTA') {
                        esCandidata = true;
                        tipoRegistro = 'FCD_ABON';
                        // console.log(`‚úÖ CRITERIO 2 - FCD_ABON encontrado en fila ${i}: Desc="${descripcion}" Cargo="${cargo}" Abono="${abono}"`);
                    }
                    
                    if (esCandidata) {
                        const cargoNumerico = this.normalizarMonto(cargo || '0');
                        const abonoNumerico = this.normalizarMonto(abono || '0');
                        const importeFila = cargoNumerico + abonoNumerico; // Cargo + Abono para esta fila
                        
                        candidatosGrupoIBK.push({
                            tipo: tipoRegistro,
                            indice: i,
                            fechaOperacion: fechaOperacion,
                            fechaProceso: fechaProceso,
                            nroOperacion: nroOperacion,
                            movimiento: movimiento,
                            descripcion: descripcion,
                            canal: canal,
                            cargo: cargo,
                            cargoNumerico: cargoNumerico,
                            abono: abono,
                            abonoNumerico: abonoNumerico,
                            importeFila: importeFila, // Cargo + Abono
                            saldoContable: saldoContable,
                            fila: fila
                        });
                        
                        // console.log(`üìù Candidato ${candidatosGrupoIBK.length}: Tipo="${tipoRegistro}" Fecha="${fechaOperacion}" Importe=${importeFila.toFixed(2)}`);
                    }
                }
                
                // console.log(`üìä CANDIDATOS ENCONTRADOS: ${candidatosGrupoIBK.length} total`);
                
                // PASO 2: Agrupar por fecha y calcular suma de importes (Cargo + Abono)
                const gruposPorFecha = new Map();
                
                // console.log(`\nüóÇÔ∏è === DEBUG IBK PASO 4 - AGRUPANDO POR FECHA ===`);
                
                candidatosGrupoIBK.forEach((candidato, idx) => {
                    const fechaNormalizada = this.normalizarFecha(candidato.fechaOperacion);
                    
                    // console.log(`üóìÔ∏è Candidato ${idx + 1}: Fecha original="${candidato.fechaOperacion}" ‚Üí Normalizada="${fechaNormalizada}"`);
                    
                    if (!fechaNormalizada || fechaNormalizada === '') {
                        // console.log(`‚ùå FECHA VAC√çA para candidato ${idx + 1}! Fecha original="${candidato.fechaOperacion}"`);
                        return; // Skip este candidato
                    }
                    
                    if (!gruposPorFecha.has(fechaNormalizada)) {
                        gruposPorFecha.set(fechaNormalizada, {
                            fecha: fechaNormalizada,
                            fechaOriginal: candidato.fechaOperacion,
                            registros: [],
                            financDocs: [],
                            fcdAbon: [],
                            totalImporteGrupo: 0 // Suma de todos los importeFila del grupo
                        });
                        // console.log(`üìÖ NUEVO GRUPO creado para fecha "${fechaNormalizada}"`);
                    }
                    
                    const grupo = gruposPorFecha.get(fechaNormalizada);
                    grupo.registros.push(candidato);
                    grupo.totalImporteGrupo += candidato.importeFila; // Sumar Cargo + Abono de esta fila
                    
                    // console.log(`‚ûï A√±adido al grupo "${fechaNormalizada}": Importe=${candidato.importeFila.toFixed(2)}, Total grupo=${grupo.totalImporteGrupo.toFixed(2)}`);
                    
                    // Clasificar por tipo para logs
                    if (candidato.tipo === 'FINANC_DOCS') {
                        grupo.financDocs.push(candidato);
                    } else if (candidato.tipo === 'FCD_ABON') {
                        grupo.fcdAbon.push(candidato);
                    }
                });
                
                // console.log(`üìä AGRUPACI√ìN EXTRACTO COMPLETADA: ${gruposPorFecha.size} grupos formados`);
                
                // PASO 3: Formar grupos del MAYOR (IGUAL QUE OTRAS CUENTAS: DES_TDOP="Bna" + LIBRO="04")
                // console.log(`\nüìã === DEBUG IBK PASO 4 - AGRUPANDO MAYOR ===`);
                
                const gruposMayorPorFecha = new Map();
                let candidatosMayor = 0;
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    if (!filaMayor || !Array.isArray(filaMayor)) continue;
                    
                    // USAR √çNDICES EST√ÅNDAR COMO OTRAS CUENTAS
                    const desTdop = filaMayor[idxM.desTdop] || '';
                    const numdoc = filaMayor[idxM.numdoc] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const libro = filaMayor[idxM.libro] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    
                    // FILTRO MAYOR IBK EST√ÅNDAR: DES_TDOP="Bna" Y LIBRO="04" (igual que BCP/SANT)
                    if (String(desTdop || '').trim().toLowerCase() === 'bna' && String(libro || '').trim() === '04') {
                        candidatosMayor++;
                        const fechaNormalizada = this.normalizarFecha(fdoc);
                        const importeMayor = debe; // Para IBK usar DEBE como importe principal (corregido)
                        
                        if (candidatosMayor <= 5) {
                            // console.log(`‚úÖ MAYOR IBK ${candidatosMayor}: Fecha="${fdoc}" ‚Üí "${fechaNormalizada}", NUMDOC="${numdoc}", LIBRO="${libro}", DEBE=${debe}`);
                        }
                        
                        if (!fechaNormalizada || fechaNormalizada === '') {
                            // console.log(`‚ùå FECHA VAC√çA en Mayor para fila ${i}! FDOC="${fdoc}"`);
                            continue;
                        }
                        
                        if (!gruposMayorPorFecha.has(fechaNormalizada)) {
                            gruposMayorPorFecha.set(fechaNormalizada, {
                                fecha: fechaNormalizada,
                                fechaOriginal: fdoc,
                                registros: [],
                                totalImporteMayor: 0
                            });
                        }
                        
                        const grupoMayor = gruposMayorPorFecha.get(fechaNormalizada);
                        grupoMayor.registros.push({
                            indice: i,
                            numdoc: numdoc,
                            fdoc: fdoc,
                            debe: debe,
                            haber: haber,
                            importeMayor: importeMayor,
                            fila: filaMayor
                        });
                        grupoMayor.totalImporteMayor += importeMayor;
                    }
                }
                
                // console.log(`üìä MAYOR IBK: ${candidatosMayor} candidatos encontrados, ${gruposMayorPorFecha.size} grupos por fecha`);
                
                // PASO 4: Comparar grupos Extracto vs Mayor
                // console.log(`\nüîÑ === DEBUG IBK PASO 4 - COMPARACI√ìN GRUPOS ===`);
                
                let conciliados = 0;
                const tolerancia = 0.01; // Tolerancia para diferencias de centavos
                
                gruposPorFecha.forEach((grupoExtracto, fechaExtracto) => {
                    const grupoMayor = gruposMayorPorFecha.get(fechaExtracto);
                    
                    // console.log(`\nüìÖ COMPARANDO FECHA "${fechaExtracto}":`);
                    // console.log(`   üìä EXTRACTO: ${grupoExtracto.registros.length} registros, Total: S/ ${grupoExtracto.totalImporteGrupo.toFixed(2)}`);
                    
                    if (grupoMayor) {
                        // console.log(`   üìã MAYOR: ${grupoMayor.registros.length} registros, Total: S/ ${grupoMayor.totalImporteMayor.toFixed(2)}`);
                        
                        const diferencia = Math.abs(grupoExtracto.totalImporteGrupo - grupoMayor.totalImporteMayor);
                        // console.log(`   üí∞ DIFERENCIA: S/ ${diferencia.toFixed(4)} (tolerancia: S/ ${tolerancia.toFixed(2)})`);
                        
                        if (diferencia <= tolerancia) {
                            // console.log(`   ‚úÖ GRUPO CONCILIADO! Fecha="${fechaExtracto}"`);
                            
                            // Marcar registros de extracto como conciliados
                            grupoExtracto.registros.forEach(regExtracto => {
                                estadosExtracto.set(regExtracto.indice, {
                                    estado: 'P4 - Conciliada',
                                    ref: `IBK-${fechaExtracto}`
                                });
                            });
                            
                            // Marcar registros de mayor como conciliados
                            grupoMayor.registros.forEach(regMayor => {
                                estadosFilas.set(regMayor.indice, {
                                    estado: 'P4 - Conciliada', 
                                    ref: `IBK-${fechaExtracto}`
                                });
                            });
                            
                            conciliados++;
                        } else {
                            // console.log(`   ‚ùå NO CONCILIA: Diferencia mayor a tolerancia`);
                        }
                    } else {
                        // console.log(`   ‚ùå MAYOR: No encontrado para esta fecha`);
                    }
                });
                
                // SOLO LOGS DE GRUPOS IBK PASO 4 - SEPARADOS POR CRITERIO
                const totalFinancDocs = candidatosGrupoIBK.filter(c => c.tipo === 'FINANC_DOCS').length;
                const totalFcdAbon = candidatosGrupoIBK.filter(c => c.tipo === 'FCD_ABON').length;
                
                // console.log(`\nüè¶ === IBK PASO 4 - GRUPOS FORMADOS ===`);
                // console.log(`üìä CANDIDATOS POR CRITERIO:`);
                // console.log(`   üî∏ CRITERIO 1 (FINANC. DE DOCS + Cargo -8): ${totalFinancDocs} registros`);
                // console.log(`   üî∏ CRITERIO 2 (FCD ABON.CTA): ${totalFcdAbon} registros`);
                // console.log(`   üìä TOTAL CANDIDATOS: ${candidatosGrupoIBK.length} registros`);
                // console.log(`üìä Total grupos por fecha: ${gruposPorFecha.size}`);
                
                gruposPorFecha.forEach((grupo, fecha) => {
                    // console.log(`\nüìÖ GRUPO ${fecha}:`);
                    // console.log(`   FINANC. DE DOCS (Cargo -8): ${grupo.financDocs.length} registros`);
                    // console.log(`   FCD ABON.CTA: ${grupo.fcdAbon.length} registros`);
                    // console.log(`   TOTAL REGISTROS: ${grupo.registros.length}`);
                    // console.log(`   TOTAL IMPORTE GRUPO: S/ ${grupo.totalImporteGrupo.toFixed(2)}`);
                    
                    // Mostrar detalles de registros
                    if (grupo.financDocs.length > 0) {
                        // console.log(`   üìã FINANC. DE DOCS:`);
                        grupo.financDocs.slice(0, 4).forEach((item, idx) => {
                            // console.log(`      ${idx + 1}. ${item.fechaOperacion} | ${item.nroOperacion} | Cargo=${item.cargo} Abono=${item.abono} | Importe=${item.importeFila.toFixed(2)}`);
                        });
                    }
                    
                    if (grupo.fcdAbon.length > 0) {
                        // console.log(`   üìã FCD ABON.CTA:`);
                        grupo.fcdAbon.slice(0, 4).forEach((item, idx) => {
                            // console.log(`      ${idx + 1}. ${item.fechaOperacion} | ${item.movimiento} | Cargo=${item.cargo} Abono=${item.abono} | Importe=${item.importeFila.toFixed(2)}`);
                        });
                    }
                });
                
                // TABLA COMPARATIVA FINAL
                // console.log(`\nüìä === TABLA COMPARATIVA IBK PASO 4 ===`);
                // console.log(`‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê`);
                // console.log(`‚îÇ    FECHA    ‚îÇ   EXTRACTO   ‚îÇ    MAYOR     ‚îÇ  DIFERENCIA  ‚îÇ   ESTADO   ‚îÇ`);
                // console.log(`‚îÇ             ‚îÇ   (8 regs)   ‚îÇ   (X regs)   ‚îÇ   (S/)       ‚îÇ            ‚îÇ`);
                // console.log(`‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§`);
                
                // Crear lista de todas las fechas √∫nicas
                const todasLasFechas = new Set([...gruposPorFecha.keys(), ...gruposMayorPorFecha.keys()]);
                
                todasLasFechas.forEach(fecha => {
                    const grupoExtracto = gruposPorFecha.get(fecha);
                    const grupoMayor = gruposMayorPorFecha.get(fecha);
                    
                    const totalExtracto = grupoExtracto ? grupoExtracto.totalImporteGrupo : 0;
                    const totalMayor = grupoMayor ? grupoMayor.totalImporteMayor : 0;
                    const cantExtracto = grupoExtracto ? grupoExtracto.registros.length : 0;
                    const cantMayor = grupoMayor ? grupoMayor.registros.length : 0;
                    const diferencia = Math.abs(totalExtracto - totalMayor);
                    
                    let estado = '';
                    if (!grupoExtracto && !grupoMayor) {
                        estado = 'Sin datos';
                    } else if (!grupoExtracto) {
                        estado = 'Solo Mayor';
                    } else if (!grupoMayor) {
                        estado = 'Solo Extracto';
                    } else if (diferencia <= 0.01) {
                        estado = '‚úÖ CONCILIADO';
                    } else {
                        estado = '‚ùå Diferencia';
                    }
                    
                    const fechaCorta = fecha.substring(5); // MM-DD
                    const extractoStr = grupoExtracto ? `${totalExtracto.toFixed(2)}(${cantExtracto})` : 'N/A';
                    const mayorStr = grupoMayor ? `${totalMayor.toFixed(2)}(${cantMayor})` : 'N/A';
                    const difStr = diferencia > 0 ? diferencia.toFixed(2) : '0.00';
                    
                    // console.log(`‚îÇ ${fechaCorta.padEnd(11)} ‚îÇ ${extractoStr.padEnd(12)} ‚îÇ ${mayorStr.padEnd(12)} ‚îÇ ${difStr.padEnd(12)} ‚îÇ ${estado.padEnd(10)} ‚îÇ`);
                });
                
                // console.log(`‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò`);
                // =======================================================
                // ETAPA 2: MAPEO INTERNO MAYOR (LIBRO 04 vs LIBRO 09)
                // =======================================================
                // console.log(`\nüÖ±Ô∏è === IBK PASO 4 - ETAPA 2: MAPEO INTERNO MAYOR ===`);
                
                let candidatosLibro04 = 0;
                let candidatosLibro09 = 0;
                let conciliadosInternos = 0;
                
                // Buscar filas pendientes con LIBRO="04"
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    // Solo procesar filas pendientes
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    
                    // Solo filas con LIBRO="04" y DEBE > 0
                    if (String(libro || '').trim() === '04' && debe > 0) {
                        candidatosLibro04++;
                        
                        if (candidatosLibro04 <= 3) {
                            // console.log(`üîç Candidato LIBRO 04 (${candidatosLibro04}): FDOC="${fdoc}", DEBE=${debe}, COMPROB="${comprob}"`);
                        }
                        
                        // Buscar coincidencia en LIBRO="09" con HABER similar
                        for (let j = 0; j < filasFiltradasMayor.length; j++) {
                            if (i === j || estadosFilas.has(j)) continue;
                            
                            const otraFila = filasFiltradasMayor[j];
                            const otroLibro = otraFila[idxM.libro] || '';
                            const otroHaber = this.normalizarMonto(otraFila[idxM.haber] || '0');
                            const otroComprob = otraFila[idxM.comprob] || '';
                            const otroFdoc = otraFila[idxM.fdoc] || '';
                            
                            if (String(otroLibro || '').trim() === '09' && otroHaber > 0) {
                                candidatosLibro09++;
                                
                                // Verificar coincidencia de montos (exacto) y misma fecha
                                const diferencia = Math.abs(debe - otroHaber);
                                const mismoDia = this.normalizarFecha(fdoc) === this.normalizarFecha(otroFdoc);
                                const coincide = diferencia === 0 && mismoDia;
                                
                                if (candidatosLibro04 <= 3 && candidatosLibro09 <= 6) {
                                    // console.log(`   üîÑ vs LIBRO 09: FDOC="${otroFdoc}", HABER=${otroHaber}, diff=${diferencia.toFixed(4)}, fecha=${mismoDia ? '‚úÖ' : '‚ùå'} ${coincide ? '‚úÖ MATCH' : '‚ùå'}`);
                                }
                                
                                if (coincide) {
                                    // Asignar estados a ambas filas
                                    estadosFilas.set(i, {
                                        estado: 'P4 - Conciliada',
                                        ref: `09-${otroComprob}`
                                    });
                                    
                                    estadosFilas.set(j, {
                                        estado: 'P4 - Conciliada', 
                                        ref: `04-${comprob}`
                                    });
                                    
                                    conciliadosInternos++;
                                    
                                    // console.log(`‚úÖ ETAPA 2 - CONCILIACI√ìN INTERNA:`);
                                    // console.log(`   LIBRO 04 (fila ${i}): DEBE=${debe} ‚Üí REF="09-${otroComprob}"`);
                                    // console.log(`   LIBRO 09 (fila ${j}): HABER=${otroHaber} ‚Üí REF="04-${comprob}"`);
                                    
                                    // Salir del bucle interno ya que encontramos el match
                                    break;
                                }
                            }
                        }
                    }
                }
                
                // console.log(`üìä ETAPA 2 COMPLETADA: ${candidatosLibro04} candidatos L04, ${conciliadosInternos} conciliaciones internas`);
                
                // ACTUALIZAR TABLA COMPARATIVA PARA INCLUIR ETAPA 2
                const totalConciliados = conciliados + conciliadosInternos;
                
                // console.log(`üìà RESUMEN FINAL: ${totalConciliados} conciliaciones totales (${conciliados} extracto + ${conciliadosInternos} internas)`);
                // console.log(`üéØ EXTRACTO: ${candidatosGrupoIBK.length} candidatos (${totalFinancDocs} FINANC.DOCS + ${totalFcdAbon} FCD.ABON)`);
                // console.log(`üéØ MAYOR: ${candidatosMayor} candidatos (DES_TDOP=Bna + LIBRO=04)`);
                // console.log(`üéØ INTERNO: ${candidatosLibro04} candidatos LIBRO=04 para mapeo interno`);
                
                return { 
                    conciliados: totalConciliados, // Cantidad real total de conciliaciones
                    etapa1: conciliados, // Conciliaciones extracto vs mayor
                    etapa2: conciliadosInternos, // Conciliaciones internas mayor
                    gruposExtracto: gruposPorFecha,
                    gruposMayor: gruposMayorPorFecha,
                    totalCandidatos: candidatosGrupoIBK.length,
                    candidatosFinancDocs: totalFinancDocs,
                    candidatosFcdAbon: totalFcdAbon
                };
            },

            procesarPaso5IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 5 IBK - OPERACIONES FINANC. DE DOCS -78:
                
                CRITERIOS EXTRACTO IBK:
                1. Movimiento (Col E orig) = "FINANC. DE DOCS" 
                2. Cargo (Col H orig) = "-78.00" (espec√≠fico para P5)
                3. Agrupar por Fecha de operaci√≥n (Col B orig)
                4. Importe = |Cargo| = |-78.00| = 78.00 (valor absoluto)
                
                CRITERIOS MAYOR (EST√ÅNDAR):
                - LIBRO = "04" + GLOSA inicia con "PROT" (Protestos)
                - LIBRO = "03" o "09" + GLOSA inicia con "DEV" (Devoluciones)
                - Agrupar por FDOC, sumar HABER
                
                MAPEO: FDOC + HABER (Mayor) vs Fecha + |Cargo| (Extracto IBK)
                
                ESTADOS RESULTANTES:
                - "P5 - Conciliada" para registros mapeados
                - Mayor ‚Üí REF extracto, Extracto ‚Üí REF "LIBRO-COMPROB"
                */
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                // console.log(`\nüìà === IBK PASO 5 - FINANC. DE DOCS -78 ===`);
                
                // ETAPA 1: Buscar candidatos EXTRACTO IBK (FINANC. DE DOCS + Cargo -78)
                const candidatosExtractoIBK = [];
                
                for (let i = 0; i < extractoProcesable.length; i++) {
                    if (estadosExtracto.has(i)) continue;
                    
                    const item = extractoProcesable[i];
                    const fila = item.fila;
                    if (!fila || !Array.isArray(fila)) continue;
                    
                    // IBK estructura ORIGINAL: A=vac√≠o, B=Fecha op, C=Fecha proc, D=Nro op, E=Movimiento, F=Descripci√≥n, G=Canal, H=Cargo, I=Abono, J=Saldo
                    const fechaOperacion = fila[1] || '';         // B (√≠ndice 1)
                    const movimiento = (fila[4] || '').toString(); // E (√≠ndice 4)
                    const cargo = (fila[7] || '').toString();      // H (√≠ndice 7)
                    
                    // CRITERIO IBK P5: FINANC. DE DOCS con cargo -78
                    if (movimiento.trim() === 'FINANC. DE DOCS' && cargo.trim() === '-78') {
                        const cargoNumerico = this.normalizarMonto(cargo);
                        const importeAbsoluto = Math.abs(cargoNumerico); // |-78| = 78
                        
                        candidatosExtractoIBK.push({
                            indice: i,
                            fechaOperacion: fechaOperacion,
                            movimiento: movimiento,
                            cargo: cargo,
                            cargoNumerico: cargoNumerico,
                            importeAbsoluto: importeAbsoluto,
                            fila: fila
                        });
                        
                        if (candidatosExtractoIBK.length <= 5) {
                            // console.log(`‚úÖ Extracto IBK P5 ${candidatosExtractoIBK.length}: Fecha="${fechaOperacion}", Mov="${movimiento}", Cargo="${cargo}", |Cargo|=${importeAbsoluto}`);
                        }
                    }
                }
                
                // ETAPA 2: Agrupar extracto IBK por fecha
                const gruposExtractoPorFecha = new Map();
                
                candidatosExtractoIBK.forEach(candidato => {
                    const fechaNormalizada = this.normalizarFecha(candidato.fechaOperacion);
                    
                    if (!fechaNormalizada || fechaNormalizada === '') {
                        // console.log(`‚ùå FECHA VAC√çA en extracto IBK: "${candidato.fechaOperacion}"`);
                        return;
                    }
                    
                    if (!gruposExtractoPorFecha.has(fechaNormalizada)) {
                        gruposExtractoPorFecha.set(fechaNormalizada, {
                            fecha: fechaNormalizada,
                            fechaOriginal: candidato.fechaOperacion,
                            registros: [],
                            totalImporte: 0
                        });
                    }
                    
                    const grupo = gruposExtractoPorFecha.get(fechaNormalizada);
                    grupo.registros.push(candidato);
                    grupo.totalImporte += candidato.importeAbsoluto; // Sumar |cargo|
                });
                
                // console.log(`üìä EXTRACTO IBK P5: ${candidatosExtractoIBK.length} candidatos, ${gruposExtractoPorFecha.size} grupos por fecha`);
                
                // ETAPA 3: Formar grupos del MAYOR (EST√ÅNDAR: PROT + DEV)
                let candidatosPROT = 0;
                let candidatosDEV = 0;
                const gruposMayorPorFecha = new Map();
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Criterios est√°ndar P5: PROT (L04) + DEV (L03/L09)
                    const esPROT = String(libro || '').trim() === '04' && (glosa.startsWith('PROT') || glosa.includes('PROT'));
                    const esDEV = (String(libro || '').trim() === '03' || String(libro || '').trim() === '09') && (glosa.startsWith('DEV') || glosa.includes('DEV'));
                    
                    if ((esPROT || esDEV) && haber > 0) {
                        if (esPROT) candidatosPROT++;
                        if (esDEV) candidatosDEV++;
                        
                        const fechaNormalizada = this.normalizarFecha(fdoc);
                        
                        if (candidatosPROT + candidatosDEV <= 5) {
                            // console.log(`‚úÖ Mayor P5 ${candidatosPROT + candidatosDEV}: LIBRO="${libro}", GLOSA="${glosa.substring(0, 20)}", FDOC="${fdoc}", HABER=${haber}`);
                        }
                        
                        if (!fechaNormalizada || fechaNormalizada === '') {
                            // console.log(`‚ùå FECHA VAC√çA en mayor: FDOC="${fdoc}"`);
                            continue;
                        }
                        
                        if (!gruposMayorPorFecha.has(fechaNormalizada)) {
                            gruposMayorPorFecha.set(fechaNormalizada, {
                                fecha: fechaNormalizada,
                                fechaOriginal: fdoc,
                                registros: [],
                                totalHaber: 0
                            });
                        }
                        
                        const grupo = gruposMayorPorFecha.get(fechaNormalizada);
                        grupo.registros.push({
                            indice: i,
                            libro: libro,
                            glosa: glosa,
                            fdoc: fdoc,
                            haber: haber,
                            comprob: comprob,
                            fila: filaMayor
                        });
                        grupo.totalHaber += haber;
                    }
                }
                
                // console.log(`üìä MAYOR P5: ${candidatosPROT} PROT + ${candidatosDEV} DEV = ${candidatosPROT + candidatosDEV} candidatos, ${gruposMayorPorFecha.size} grupos por fecha`);
                
                // ETAPA 4: Comparar y conciliar grupos
                // console.log(`\nüîÑ === IBK PASO 5 - COMPARACI√ìN GRUPOS ===`);
                
                let conciliados = 0;
                const tolerancia = 0.01;
                
                gruposExtractoPorFecha.forEach((grupoExtracto, fechaExtracto) => {
                    const grupoMayor = gruposMayorPorFecha.get(fechaExtracto);
                    
                    // console.log(`\nüìÖ COMPARANDO FECHA "${fechaExtracto}":`);
                    // console.log(`   üìä EXTRACTO IBK: ${grupoExtracto.registros.length} registros, Total: S/ ${grupoExtracto.totalImporte.toFixed(2)}`);
                    
                    if (grupoMayor) {
                        // console.log(`   üìã MAYOR: ${grupoMayor.registros.length} registros, Total: S/ ${grupoMayor.totalHaber.toFixed(2)}`);
                        
                        const diferencia = Math.abs(grupoExtracto.totalImporte - grupoMayor.totalHaber);
                        // console.log(`   üí∞ DIFERENCIA: S/ ${diferencia.toFixed(4)} (tolerancia: S/ ${tolerancia.toFixed(2)})`);
                        
                        if (diferencia <= tolerancia) {
                            // console.log(`   ‚úÖ GRUPO CONCILIADO P5! Fecha="${fechaExtracto}"`);
                            
                            // Marcar registros de extracto como conciliados
                            grupoExtracto.registros.forEach(regExtracto => {
                                estadosExtracto.set(regExtracto.indice, {
                                    estado: 'P5 - Conciliada',
                                    ref: `P5-${fechaExtracto}`
                                });
                            });
                            
                            // Marcar registros de mayor como conciliados
                            grupoMayor.registros.forEach(regMayor => {
                                estadosFilas.set(regMayor.indice, {
                                    estado: 'P5 - Conciliada',
                                    ref: `IBK-P5-${fechaExtracto}`
                                });
                            });
                            
                            conciliados++;
                        } else {
                            // console.log(`   ‚ùå NO CONCILIA: Diferencia mayor a tolerancia`);
                        }
                    } else {
                        // console.log(`   ‚ùå MAYOR: No encontrado para esta fecha`);
                    }
                });
                
                // console.log(`üìà RESUMEN IBK P5: ${conciliados} grupos conciliados`);
                // console.log(`üéØ EXTRACTO IBK: ${candidatosExtractoIBK.length} candidatos (FINANC.DOCS -78)`);
                // console.log(`üéØ MAYOR: ${candidatosPROT + candidatosDEV} candidatos (PROT+DEV)`);
                
                return {
                    candidatos: candidatosExtractoIBK.length + candidatosPROT + candidatosDEV,
                    grupos: Math.max(gruposExtractoPorFecha.size, gruposMayorPorFecha.size),
                    conciliados: conciliados
                };
            },

            procesarPaso6IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 6 IBK - DEP√ìSITOS BANCARIOS:
                
                CRITERIOS MAYOR (IGUAL QUE BCP):
                - LIBRO = "01"
                - GLOSA inicia con "DEPOSITO BANCARIO"
                - ESTADO = "Pendiente"
                
                DIFERENCIA IBK: 
                - Extracto usa columna ABONO (I en original, √≠ndice 8) en lugar de MONTO est√°ndar
                - En pesta√±a IBK: ABONO aparece en columna H pero el procesamiento usa el extracto original
                
                ETAPA 6A - Mapeo por NUMDOC:
                1. NUMDOC (Mayor) ‚Üî Operaci√≥n - N√∫mero (Extracto)
                
                ETAPA 6B - Mapeo por FDOC+DEBE:
                2. FDOC + DEBE (Mayor) ‚Üî FECHA + ABONO (Extracto IBK)
                3. Validaci√≥n: DEBE (Mayor) vs ABONO (Extracto IBK)
                
                ESTADOS RESULTANTES:
                - "P6 - Conciliada"
                - Mayor: #REF = [Operaci√≥n - N√∫mero del Extracto]  
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // // console.log(`\nüìà === IBK PASO 6 - DEP√ìSITOS BANCARIOS ===`);
                
                let candidatosDepositos = 0;
                let conciliadosEtapa6A = 0;
                let conciliadosEtapa6B = 0;
                
                // ETAPA 1: Identificar candidatos MAYOR (LIBRO="01" + INICIA CON DEPOSITO BANCARIO)
                const candidatosPaso6 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    
                    const esLibro01 = String(libro || '').trim() === '01';
                    const esDepositoBancario = glosa.startsWith('DEPOSITO BANCARIO');
                    
                    if (esLibro01 && esDepositoBancario) {
                        candidatosDepositos++;
                        const numdoc = filaMayor[idxM.numdoc] || '';
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosPaso6.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            numdoc: this.normalizarTexto(numdoc),
                            fdoc: fdoc,
                            debe: debe,
                            comprob: comprob
                        });
                        
                        // if (candidatosDepositos <= 5) {
                        //     // console.log(`‚úÖ Mayor P6 ${candidatosDepositos}: LIBRO="${libro}", GLOSA="${glosa.substring(0, 30)}...", NUMDOC="${numdoc}", FDOC="${fdoc}", DEBE=${debe}`);
                        // }
                    }
                }
                
                // // console.log(`üìä Mayor P6: ${candidatosDepositos} candidatos (LIBRO=01 + INICIA CON DEPOSITO BANCARIO)`);
                
                if (candidatosDepositos === 0) {
                    // // console.log(`‚ö†Ô∏è No se encontraron candidatos para PASO 6 IBK`);
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // ETAPA 6A: MAPEO POR NUMDOC vs OPERACI√ìN-N√öMERO
                // // console.log(`\nüÖ∞Ô∏è === IBK PASO 6A - MAPEO POR NUMDOC ===`);
                
                for (const candidato of candidatosPaso6) {
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    // Buscar coincidencia por NUMDOC en extracto
                    for (let j = 0; j < extractoProcesable.length; j++) {
                        if (estadosExtracto.has(j)) continue;
                        
                        const itemExtracto = extractoProcesable[j];
                        const filaExtracto = itemExtracto.fila;
                        if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                        
                        // IBK estructura: Operaci√≥n-N√∫mero en columna D (√≠ndice 3)
                        const operacionNumero = this.normalizarTexto(filaExtracto[3] || '');
                        
                        if (candidato.numdoc && operacionNumero && candidato.numdoc === operacionNumero) {
                            // Conciliar por NUMDOC
                            estadosFilas.set(candidato.indice, {
                                estado: 'P6 - Conciliada',
                                ref: operacionNumero
                            });
                            
                            estadosExtracto.set(j, {
                                estado: 'P6 - Conciliada',
                                ref: `${candidato.libro}-${candidato.comprob}`
                            });
                            
                            conciliadosEtapa6A++;
                            // // console.log(`‚úÖ P6A CONCILIADO: NUMDOC="${candidato.numdoc}" ‚Üî OperNum="${operacionNumero}"`);
                            break;
                        }
                    }
                }
                
                // ETAPA 6B: MAPEO POR FDOC+DEBE vs FECHA+ABONO
                // // console.log(`\nüÖ±Ô∏è === IBK PASO 6B - MAPEO POR FDOC+DEBE vs FECHA+ABONO ===`);
                
                for (const candidato of candidatosPaso6) {
                    if (estadosFilas.has(candidato.indice)) continue; // Ya conciliado en 6A
                    
                    const fechaMayorNormalizada = this.normalizarFecha(candidato.fdoc);
                    
                    // Buscar coincidencia por FDOC+DEBE vs FECHA+ABONO
                    for (let j = 0; j < extractoProcesable.length; j++) {
                        if (estadosExtracto.has(j)) continue;
                        
                        const itemExtracto = extractoProcesable[j];
                        const filaExtracto = itemExtracto.fila;
                        if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                        
                        // IBK estructura original: B=Fecha op(1), I=Abono(8)  
                        const fechaExtracto = filaExtracto[1] || '';
                        const abonoExtracto = this.normalizarMonto(filaExtracto[8] || '0');
                        const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                        
                        const fechaCoincide = fechaMayorNormalizada === fechaExtractoNormalizada;
                        const montoCoincide = Math.abs(candidato.debe - abonoExtracto) < 0.01;
                        
                        if (fechaCoincide && montoCoincide) {
                            const operacionNumero = filaExtracto[3] || '';
                            
                            estadosFilas.set(candidato.indice, {
                                estado: 'P6 - Conciliada',
                                ref: operacionNumero || `P6B-${fechaMayorNormalizada}`
                            });
                            
                            estadosExtracto.set(j, {
                                estado: 'P6 - Conciliada', 
                                ref: `${candidato.libro}-${candidato.comprob}`
                            });
                            
                            conciliadosEtapa6B++;
                            // // console.log(`‚úÖ P6B CONCILIADO: FDOC="${candidato.fdoc}" + DEBE=${candidato.debe} ‚Üî Fecha="${fechaExtracto}" + ABONO=${abonoExtracto}`);
                            break;
                        }
                    }
                }
                
                const totalConciliados = conciliadosEtapa6A + conciliadosEtapa6B;
                // // console.log(`üìà RESUMEN IBK P6: ${totalConciliados} conciliados (${conciliadosEtapa6A} por NUMDOC + ${conciliadosEtapa6B} por FDOC+DEBE)`);
                
                return {
                    candidatos: candidatosDepositos,
                    conciliados: totalConciliados,
                    etapa6A: conciliadosEtapa6A,
                    etapa6B: conciliadosEtapa6B
                };
            },

            procesarPaso6DET(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 6 DET - DEP√ìSITOS BANCARIOS:
                
                CRITERIOS MAYOR:
                - LIBRO = "01"
                - GLOSA inicia con "DEPOSITO BANCARIO"
                - ESTADO = "Pendiente"
                
                MAPEO DET:
                - Mayor: FDOC + DEBE
                - Extracto DET: Fecha (columna B, √≠ndice 1) + Abono (columna H, √≠ndice 7)
                - Formato fecha: aaaa.mm.dd
                
                ESTADOS RESULTANTES:
                - "P6 - Conciliada" para registros mapeados
                */
                
                // console.log(`üè¶ PASO 6 DET: Iniciando dep√≥sitos bancarios`);
                // console.log(`üîç Mayor: ${filasFiltradasMayor.length} filas disponibles`);
                // console.log(`üîç Extracto: ${extractoProcesable.length} filas disponibles`);
                // console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                let candidatosDepositos = 0;
                let conciliados = 0;
                
                // Identificar candidatos LIBRO="01" + GLOSA inicia con "DEPOSITO BANCARIO"
                const candidatosPaso6 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    
                    const esLibro01 = String(libro || '').trim() === '01';
                    const esDepositoBancario = glosa.startsWith('DEPOSITO BANCARIO');
                    
                    if (esLibro01 && esDepositoBancario) {
                        candidatosDepositos++;
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        // console.log(`üìã DET P6 Candidato ${candidatosDepositos}: LIBRO="${libro}", GLOSA="${glosa.substring(0, 50)}...", FDOC="${fdoc}", DEBE=${debe}, COMPROB="${comprob}"`);
                        
                        candidatosPaso6.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            fdoc: fdoc,
                            debe: debe,
                            comprob: comprob
                        });
                    }
                }
                
                // console.log(`üéØ DET P6: ${candidatosDepositos} candidatos dep√≥sitos bancarios encontrados`);
                
                if (candidatosDepositos === 0) {
                    // console.log(`‚ö†Ô∏è DET P6: No se encontraron candidatos. Verificando primeras 3 filas del mayor:`);
                    // for (let i = 0; i < Math.min(3, filasFiltradasMayor.length); i++) {
                    //     const fila = filasFiltradasMayor[i];
                    //     const libro = fila[idxM.libro] || '';
                    //     const glosa = (fila[idxM.glosa] || '').toString().toUpperCase();
                    //     console.log(`   Fila ${i}: LIBRO="${libro}", GLOSA="${glosa.substring(0, 60)}..."`);
                    // }
                }
                
                // MAPEO: FDOC+DEBE vs FECHA+ABONO
                for (const candidato of candidatosPaso6) {
                    const fechaMayorNormalizada = this.normalizarFecha(candidato.fdoc);
                    
                    for (let j = 0; j < extractoProcesable.length; j++) {
                        if (estadosExtracto.has(j)) continue;
                        
                        const itemExtracto = extractoProcesable[j];
                        const filaExtracto = itemExtracto.fila;
                        if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                        
                        // DET estructura: B=Fecha(1), H=Abono(7)
                        const fechaExtracto = filaExtracto[1] || '';
                        const abonoExtracto = this.normalizarMonto(filaExtracto[7] || '0');
                        const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                        
                        // Log espec√≠fico para parseo DET
                        // if (j < 3) {
                        //     console.log(`üîß DET PARSEO: "${fechaExtracto}" ‚Üí "${fechaExtractoNormalizada}"`);
                        // }
                        
                        const fechaCoincide = fechaMayorNormalizada === fechaExtractoNormalizada;
                        const montoCoincide = Math.abs(candidato.debe - abonoExtracto) < 0.01;
                        
                        // Debug detallado para primeras comparaciones
                        // if (j < 5 || fechaCoincide || montoCoincide) {
                        //     console.log(`üîç DET Comparando #${j}:`);
                        //     console.log(`   Mayor: FDOC="${candidato.fdoc}" ‚Üí "${fechaMayorNormalizada}", DEBE=${candidato.debe}`);
                        //     console.log(`   Extracto: Fecha="${fechaExtracto}" ‚Üí "${fechaExtractoNormalizada}", Abono=${abonoExtracto}`);
                        //     console.log(`   Coincidencias: Fecha=${fechaCoincide}, Monto=${montoCoincide} (diff: ${Math.abs(candidato.debe - abonoExtracto).toFixed(6)})`);
                        // }
                        
                        if (fechaCoincide && montoCoincide) {
                            const nroOperacion = filaExtracto[0] || '';
                            
                            estadosFilas.set(candidato.indice, {
                                estado: 'P6 - Conciliada',
                                ref: nroOperacion || `P6-${fechaMayorNormalizada}`
                            });
                            
                            estadosExtracto.set(j, {
                                estado: 'P6 - Conciliada',
                                ref: `${candidato.libro}-${candidato.comprob}`
                            });
                            
                            conciliados++;
                            // console.log(`‚úÖ P6 DET CONCILIADO #${conciliados}:`);
                            // console.log(`   üìã Mayor: FDOC="${candidato.fdoc}" + DEBE=${candidato.debe} (√≠ndice ${candidato.indice})`);
                            // console.log(`   üìã Extracto: Fecha="${fechaExtracto}" + ABONO=${abonoExtracto} (√≠ndice ${j})`);
                            // console.log(`   üîó Referencias: Mayor="${nroOperacion || `P6-${fechaMayorNormalizada}`}", Extracto="${candidato.libro}-${candidato.comprob}"`);
                            break;
                        }
                    }
                }
                
                // console.log(`üìà RESUMEN DET P6: ${conciliados} conciliados de ${candidatosDepositos} candidatos`);
                // console.log(`üìä DET P6 Eficiencia: ${candidatosDepositos > 0 ? ((conciliados / candidatosDepositos) * 100).toFixed(1) : 0}%`);
                
                return {
                    candidatos: candidatosDepositos,
                    conciliados: conciliados
                };
            },

            procesarPaso8DET(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 8 DET - OPERACIONES M√öLTIPLES LIBROS:
                
                CRITERIOS MAYOR:
                - LIBRO = "03", "09", "14", "15"
                - ESTADO = "Pendiente"
                
                MAPEO DET:
                - Mayor: FDOC + HABER
                - Extracto DET: Fecha (columna B, √≠ndice 1) + Cargo (columna G, √≠ndice 6)
                - Formato fecha: aaaa.mm.dd
                - Cargo puede estar en letras, convertir a n√∫mero
                
                ESTADOS RESULTANTES:
                - "P8 - Conciliada" para registros mapeados
                */
                
                console.log(`üè¶ PASO 8 DET: Iniciando operaciones m√∫ltiples libros`);
                console.log(`üîç Mayor: ${filasFiltradasMayor.length} filas disponibles`);
                console.log(`üîç Extracto: ${extractoProcesable.length} filas disponibles`);
                console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                let candidatosEncontrados = 0;
                let conciliados = 0;
                
                // Libros objetivo para PASO 8
                const librosObjetivo = ['03', '09', '14', '15'];
                
                // Identificar candidatos LIBRO = 03, 09, 14, 15 + ESTADO = Pendiente
                const candidatosPaso8 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    
                    if (librosObjetivo.includes(String(libro || '').trim())) {
                        candidatosEncontrados++;
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        console.log(`üìã DET P8 Candidato ${candidatosEncontrados}: LIBRO="${libro}", FDOC="${fdoc}", HABER=${haber}, COMPROB="${comprob}"`);
                        
                        candidatosPaso8.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            fdoc: fdoc,
                            haber: haber,
                            comprob: comprob
                        });
                    }
                }
                
                console.log(`üéØ DET P8: ${candidatosEncontrados} candidatos m√∫ltiples libros encontrados`);
                
                if (candidatosEncontrados === 0) {
                    console.log(`‚ö†Ô∏è DET P8: No se encontraron candidatos.`);
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // MAPEO: FDOC+HABER vs FECHA+ABONO
                for (const candidato of candidatosPaso8) {
                    const fechaMayorNormalizada = this.normalizarFecha(candidato.fdoc);
                    
                    for (let j = 0; j < extractoProcesable.length; j++) {
                        if (estadosExtracto.has(j)) continue;
                        
                        const itemExtracto = extractoProcesable[j];
                        const filaExtracto = itemExtracto.fila;
                        if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                        
                        // DET estructura: B=Fecha(1), G=Cargo(6) 
                        const fechaExtracto = filaExtracto[1] || '';
                        const cargoRaw = filaExtracto[6] || '';
                        
                        // Normalizar cargo (puede estar en letras)
                        const cargoExtracto = this.normalizarMonto(cargoRaw);
                        const cargoAbsoluto = Math.abs(cargoExtracto);
                        
                        const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                        
                        const fechaCoincide = fechaMayorNormalizada === fechaExtractoNormalizada;
                        const montoCoincide = Math.abs(candidato.haber - cargoAbsoluto) < 0.01;
                        
                        // Debug detallado para primeras comparaciones
                        if (j < 5 || fechaCoincide || montoCoincide) {
                            console.log(`üîç DET P8 Comparando #${j}:`);
                            console.log(`   Mayor: FDOC="${candidato.fdoc}" ‚Üí "${fechaMayorNormalizada}", HABER=${candidato.haber}`);
                            console.log(`   Extracto: Fecha="${fechaExtracto}" ‚Üí "${fechaExtractoNormalizada}", Cargo(G)="${cargoRaw}" ‚Üí ${cargoAbsoluto}`);
                            console.log(`   Coincidencias: Fecha=${fechaCoincide}, Monto=${montoCoincide} (diff: ${Math.abs(candidato.haber - cargoAbsoluto).toFixed(6)})`);
                        }
                        
                        if (fechaCoincide && montoCoincide) {
                            const nroOperacion = filaExtracto[0] || '';
                            
                            estadosFilas.set(candidato.indice, {
                                estado: 'P8 - Conciliada',
                                ref: nroOperacion || `P8-${fechaMayorNormalizada}`
                            });
                            
                            estadosExtracto.set(j, {
                                estado: 'P8 - Conciliada',
                                ref: `${candidato.libro}-${candidato.comprob}`
                            });
                            
                            conciliados++;
                            console.log(`‚úÖ P8 DET CONCILIADO #${conciliados}:`);
                            console.log(`   üìã Mayor: LIBRO="${candidato.libro}", FDOC="${candidato.fdoc}" + HABER=${candidato.haber} (√≠ndice ${candidato.indice})`);
                            console.log(`   üìã Extracto: Fecha="${fechaExtracto}" + CARGO(G)=${cargoAbsoluto} (√≠ndice ${j})`);
                            console.log(`   üîó Referencias: Mayor="${nroOperacion || `P8-${fechaMayorNormalizada}`}", Extracto="${candidato.libro}-${candidato.comprob}"`);
                            break;
                        }
                    }
                }
                
                console.log(`üìà RESUMEN DET P8: ${conciliados} conciliados de ${candidatosEncontrados} candidatos`);
                console.log(`üìä DET P8 Eficiencia: ${candidatosEncontrados > 0 ? ((conciliados / candidatosEncontrados) * 100).toFixed(1) : 0}%`);
                
                return {
                    candidatos: candidatosEncontrados,
                    conciliados: conciliados
                };
            },

            procesarPaso11BN(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 11 BN - ITF ESPEC√çFICO:
                
                CRITERIOS MAYOR:
                - LIBRO = "09"
                - GLOSA contiene "ITF"
                - HABER > 0
                - ESTADO = "Pendiente"
                
                CRITERIOS EXTRACTO BN:
                - Trans contiene "IMPT.ITF" (asumir columna C, √≠ndice 2)
                - Usar valor absoluto de Cargo (columna F, √≠ndice 5)
                
                MAPEO:
                - Suma HABER (Mayor) vs suma |CARGO| (Extracto BN)
                
                ESTADOS RESULTANTES:
                - "P11 - Conciliada" para todos los registros si totales coinciden
                */
                
                console.log(`üè¶ PASO 11 BN: Iniciando procesamiento ITF`);
                console.log(`üîç Mayor: ${filasFiltradasMayor.length} filas disponibles`);
                console.log(`üîç Extracto: ${extractoProcesable.length} filas disponibles`);
                console.log(`üîç Estados ya procesados: ${estadosFilas.size}`);
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                let candidatosMayorITF = 0;
                let candidatosExtractoITF = 0;
                let conciliados = 0;
                
                // === 1. IDENTIFICAR ITF EN MAYOR ===
                console.log(`\nüèõÔ∏è === ETAPA 1: IDENTIFICACI√ìN ITF EN MAYOR ===`);
                const candidatosMayor = [];
                let totalHaberMayor = 0;
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    
                    // Criterios: LIBRO = "09" + GLOSA contiene "ITF" + HABER > 0
                    const esLibro09 = String(libro || '').trim() === '09';
                    const contieneITF = glosa.includes('ITF');
                    const tieneHaber = haber > 0;
                    
                    if (esLibro09 && contieneITF && tieneHaber) {
                        candidatosMayorITF++;
                        totalHaberMayor += haber;
                        
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        console.log(`üìã BN P11 Mayor ITF ${candidatosMayorITF}: LIBRO="${libro}", GLOSA="${glosa.substring(0, 40)}...", HABER=${haber}, FDOC="${fdoc}"`);
                        
                        candidatosMayor.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            haber: haber,
                            fdoc: fdoc,
                            comprob: comprob
                        });
                    }
                }
                
                console.log(`üéØ BN P11: ${candidatosMayorITF} candidatos ITF en Mayor encontrados`);
                console.log(`üí∞ Total HABER Mayor ITF: ${totalHaberMayor.toFixed(2)}`);
                
                if (candidatosMayorITF === 0) {
                    console.log(`‚ö†Ô∏è BN P11: No se encontraron candidatos ITF en Mayor`);
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // === 2. IDENTIFICAR "IMPT.ITF" EN EXTRACTO BN ===
                console.log(`\nüè¶ === ETAPA 2: IDENTIFICACI√ìN "IMPT.ITF" EN EXTRACTO BN ===`);
                const candidatosExtracto = [];
                let totalCargoExtracto = 0;
                
                for (let j = 0; j < extractoProcesable.length; j++) {
                    if (estadosExtracto.has(j)) continue;
                    
                    const itemExtracto = extractoProcesable[j];
                    const filaExtracto = itemExtracto.fila;
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // BN estructura: C=Trans(2), F=Cargo(5)
                    const trans = (filaExtracto[2] || '').toString().toUpperCase();
                    const cargoRaw = filaExtracto[5] || '';
                    const cargoExtracto = this.normalizarMonto(cargoRaw);
                    const cargoAbsoluto = Math.abs(cargoExtracto);
                    
                    // Criterio: Trans contiene "IMPT.ITF"
                    const esImpuestoITF = trans.includes('IMPT.ITF') || trans.includes('IMPUESTO ITF') || trans.includes('ITF');
                    
                    if (esImpuestoITF && cargoAbsoluto > 0) {
                        candidatosExtractoITF++;
                        totalCargoExtracto += cargoAbsoluto;
                        
                        const fecha = filaExtracto[1] || '';
                        const nroOperacion = filaExtracto[0] || '';
                        
                        console.log(`üìã BN P11 Extracto ITF ${candidatosExtractoITF}: Trans="${trans.substring(0, 30)}...", Cargo=${cargoAbsoluto}, Fecha="${fecha}"`);
                        
                        candidatosExtracto.push({
                            indice: j,
                            fila: filaExtracto,
                            trans: trans,
                            cargo: cargoAbsoluto,
                            fecha: fecha,
                            nroOperacion: nroOperacion
                        });
                    }
                }
                
                console.log(`üéØ BN P11: ${candidatosExtractoITF} candidatos "IMPT.ITF" en Extracto encontrados`);
                console.log(`üí∞ Total CARGO Extracto ITF: ${totalCargoExtracto.toFixed(2)}`);
                
                if (candidatosExtractoITF === 0) {
                    console.log(`‚ö†Ô∏è BN P11: No se encontraron operaciones "IMPT.ITF" en Extracto`);
                    return { candidatos: candidatosMayorITF, conciliados: 0 };
                }
                
                // === 3. COMPARAR TOTALES ===
                console.log(`\n‚öñÔ∏è === ETAPA 3: COMPARACI√ìN DE TOTALES ITF ===`);
                console.log(`üí∞ Total HABER Mayor: ${totalHaberMayor.toFixed(2)}`);
                console.log(`üí∞ Total CARGO Extracto: ${totalCargoExtracto.toFixed(2)}`);
                
                const diferenciaTotales = Math.abs(totalHaberMayor - totalCargoExtracto);
                const totalesCoinciden = diferenciaTotales < 0.01;
                
                console.log(`üîç Diferencia: ${diferenciaTotales.toFixed(6)}`);
                console.log(`‚öñÔ∏è Totales coinciden: ${totalesCoinciden ? '‚úÖ S√ç' : '‚ùå NO'}`);
                
                if (totalesCoinciden) {
                    // === 4. CONCILIAR TODOS LOS REGISTROS ===
                    console.log(`\n‚úÖ === ETAPA 4: CONCILIACI√ìN MASIVA ITF ===`);
                    
                    const primeraRefExtracto = candidatosExtracto.length > 0 ? candidatosExtracto[0].nroOperacion : '';
                    const primeraRefMayor = candidatosMayor.length > 0 ? `${candidatosMayor[0].libro}-${candidatosMayor[0].comprob}` : '';
                    
                    // Conciliar todos los registros Mayor ITF
                    for (const candidato of candidatosMayor) {
                        estadosFilas.set(candidato.indice, {
                            estado: 'P11 - Conciliada',
                            ref: primeraRefExtracto || `P11-ITF-${candidato.fdoc}`
                        });
                        conciliados++;
                        console.log(`‚úÖ BN P11 Mayor ITF conciliado: LIBRO="${candidato.libro}", HABER=${candidato.haber} ‚Üí REF="${primeraRefExtracto}"`);
                    }
                    
                    // Conciliar todos los registros Extracto ITF
                    for (const candidato of candidatosExtracto) {
                        estadosExtracto.set(candidato.indice, {
                            estado: 'P11 - Conciliada',
                            ref: primeraRefMayor || 'P11-ITF-BN'
                        });
                        console.log(`‚úÖ BN P11 Extracto ITF conciliado: Trans="${candidato.trans.substring(0, 30)}...", Cargo=${candidato.cargo} ‚Üí REF="${primeraRefMayor}"`);
                    }
                    
                    console.log(`üéâ BN P11 CONCILIACI√ìN ITF EXITOSA: ${candidatosMayorITF} registros Mayor + ${candidatosExtractoITF} registros Extracto`);
                } else {
                    console.log(`‚ùå BN P11: Totales ITF no coinciden. Diferencia: ${diferenciaTotales.toFixed(6)}`);
                }
                
                console.log(`üìà RESUMEN BN P11: ${conciliados} conciliados de ${candidatosMayorITF} candidatos Mayor`);
                console.log(`üìä BN P11 Eficiencia: ${candidatosMayorITF > 0 ? ((conciliados / candidatosMayorITF) * 100).toFixed(1) : 0}%`);
                
                return {
                    candidatos: candidatosMayorITF + candidatosExtractoITF,
                    conciliados: conciliados
                };
            },

            procesarPaso6BN(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 6 BN - DEP√ìSITOS BANCARIOS:
                
                CRITERIOS MAYOR:
                - LIBRO = "01"
                - GLOSA inicia con "DEPOSITO BANCARIO"
                - ESTADO = "Pendiente"
                
                MAPEO BN:
                - Mayor: FDOC + DEBE
                - Extracto BN: Fecha (columna B, √≠ndice 1) + Abono (columna G, √≠ndice 6)
                - Formato fecha: aaaa.mm.dd
                
                ESTADOS RESULTANTES:
                - "P6 - Conciliada" para registros mapeados
                */
                
                // console.log(`üè¶ PASO 6 BN: Iniciando dep√≥sitos bancarios`);
                
                let candidatosDepositos = 0;
                let conciliados = 0;
                
                // Identificar candidatos LIBRO="01" + GLOSA inicia con "DEPOSITO BANCARIO"
                const candidatosPaso6 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    
                    const esLibro01 = String(libro || '').trim() === '01';
                    const esDepositoBancario = glosa.startsWith('DEPOSITO BANCARIO');
                    
                    if (esLibro01 && esDepositoBancario) {
                        candidatosDepositos++;
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        candidatosPaso6.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            fdoc: fdoc,
                            debe: debe,
                            comprob: comprob
                        });
                    }
                }
                
                // console.log(`üéØ BN P6: ${candidatosDepositos} candidatos dep√≥sitos bancarios encontrados`);
                
                // MAPEO: FDOC+DEBE vs FECHA+ABONO
                for (const candidato of candidatosPaso6) {
                    const fechaMayorNormalizada = this.normalizarFecha(candidato.fdoc);
                    
                    for (let j = 0; j < extractoProcesable.length; j++) {
                        if (estadosExtracto.has(j)) continue;
                        
                        const itemExtracto = extractoProcesable[j];
                        const filaExtracto = itemExtracto.fila;
                        if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                        
                        // BN estructura: B=Fecha(1), G=Abono(6)
                        const fechaExtracto = filaExtracto[1] || '';
                        const abonoExtracto = this.normalizarMonto(filaExtracto[6] || '0');
                        const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                        
                        const fechaCoincide = fechaMayorNormalizada === fechaExtractoNormalizada;
                        const montoCoincide = Math.abs(candidato.debe - abonoExtracto) < 0.01;
                        
                        // Debug detallado para primeras comparaciones
                        if (j < 3) {
                            // console.log(`üîç BN Comparando:`);
                            // console.log(`   Mayor: FDOC="${candidato.fdoc}" ‚Üí "${fechaMayorNormalizada}", DEBE=${candidato.debe}`);
                            // console.log(`   Extracto: Fecha="${fechaExtracto}" ‚Üí "${fechaExtractoNormalizada}", Abono=${abonoExtracto}`);
                            // console.log(`   Coincidencias: Fecha=${fechaCoincide}, Monto=${montoCoincide} (diff: ${Math.abs(candidato.debe - abonoExtracto).toFixed(6)})`);
                        }
                        
                        if (fechaCoincide && montoCoincide) {
                            const refExtracto = filaExtracto[0] || '';
                            
                            estadosFilas.set(candidato.indice, {
                                estado: 'P6 - Conciliada',
                                ref: refExtracto || `P6-${fechaMayorNormalizada}`
                            });
                            
                            estadosExtracto.set(j, {
                                estado: 'P6 - Conciliada',
                                ref: `${candidato.libro}-${candidato.comprob}`
                            });
                            
                            conciliados++;
                            // console.log(`‚úÖ P6 BN CONCILIADO: FDOC="${candidato.fdoc}" + DEBE=${candidato.debe} ‚Üî Fecha="${fechaExtracto}" + ABONO=${abonoExtracto}`);
                            break;
                        }
                    }
                }
                
                // console.log(`üìà RESUMEN BN P6: ${conciliados} conciliados de ${candidatosDepositos} candidatos`);
                
                return {
                    candidatos: candidatosDepositos,
                    conciliados: conciliados
                };
            },

            procesarPaso7IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 7 IBK - OPERACIONES LIBRO 3:
                
                CRITERIOS MAYOR:
                - LIBRO = "03"
                - DEBE > 0 (solo registros con debe)
                - HABER = 0 (sin haber)
                - ESTADO = "Pendiente"
                
                DIFERENCIA IBK:
                - Extracto usa columna ABONO (I en original, √≠ndice 8) en lugar de MONTO est√°ndar
                - En pesta√±a IBK: ABONO aparece en columna H pero el procesamiento usa el extracto original
                
                MAPEO √öNICO:
                - FDOC + DEBE (Mayor) ‚Üî FECHA + |ABONO| (Extracto IBK)
                - Validaci√≥n: DEBE (Mayor) vs |ABONO| (Extracto IBK)
                
                ESTADOS RESULTANTES:
                - "P7 - Conciliada"
                - Mayor: #REF = [Operaci√≥n - N√∫mero del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // console.log(`\nüìà === IBK PASO 7 - OPERACIONES LIBRO 3 ===`);
                
                let candidatosLibro3 = 0;
                let conciliados = 0;
                
                // ETAPA 1: Identificar candidatos MAYOR (LIBRO="03" con DEBE > 0 y HABER = 0)
                const candidatosPaso7 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    
                    const esLibro03 = String(libro || '').trim() === '03';
                    
                    if (esLibro03) {
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        // Solo conciliar registros con DEBE > 0 y HABER = 0
                        const tieneDebeSinHaber = debe > 0 && Math.abs(haber) < 0.01;
                        
                        if (tieneDebeSinHaber) {
                            candidatosLibro3++;
                            candidatosPaso7.push({
                                indice: i,
                                fila: filaMayor,
                                libro: libro,
                                fdoc: fdoc,
                                debe: debe,
                                haber: haber,
                                comprob: comprob
                            });
                            
                            if (candidatosLibro3 <= 5) {
                                // console.log(`‚úÖ Mayor P7 ${candidatosLibro3}: LIBRO="${libro}", FDOC="${fdoc}", DEBE=${debe}, HABER=${haber}, COMPROB="${comprob}"`);
                            }
                        }
                    }
                }
                
                // console.log(`üìä Mayor P7: ${candidatosLibro3} candidatos (LIBRO=03 + DEBE>0 + HABER=0)`);
                
                if (candidatosLibro3 === 0) {
                    // console.log(`‚ö†Ô∏è No se encontraron candidatos para PASO 7 IBK`);
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // ETAPA 2: MAPEO FDOC+DEBE vs FECHA+|ABONO|
                // console.log(`\nüîÑ === IBK PASO 7 - MAPEO FDOC+DEBE vs FECHA+|ABONO| ===`);
                
                for (const candidato of candidatosPaso7) {
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    const fechaMayorNormalizada = this.normalizarFecha(candidato.fdoc);
                    
                    // Buscar coincidencia en extracto IBK
                    for (let j = 0; j < extractoProcesable.length; j++) {
                        if (estadosExtracto.has(j)) continue;
                        
                        const itemExtracto = extractoProcesable[j];
                        const filaExtracto = itemExtracto.fila;
                        if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                        
                        // IBK estructura original: B=Fecha op(1), I=Abono(8)
                        const fechaExtracto = filaExtracto[1] || '';
                        const abonoExtracto = this.normalizarMonto(filaExtracto[8] || '0');
                        const abonoAbsoluto = Math.abs(abonoExtracto); // |ABONO|
                        const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                        
                        const fechaCoincide = fechaMayorNormalizada === fechaExtractoNormalizada;
                        const montoCoincide = Math.abs(candidato.debe - abonoAbsoluto) < 0.01;
                        
                        if (fechaCoincide && montoCoincide) {
                            const operacionNumero = filaExtracto[3] || '';
                            
                            estadosFilas.set(candidato.indice, {
                                estado: 'P7 - Conciliada',
                                ref: operacionNumero || `P7-${fechaMayorNormalizada}`
                            });
                            
                            estadosExtracto.set(j, {
                                estado: 'P7 - Conciliada',
                                ref: `${candidato.libro}-${candidato.comprob}`
                            });
                            
                            conciliados++;
                            // console.log(`‚úÖ P7 CONCILIADO: FDOC="${candidato.fdoc}" + DEBE=${candidato.debe} ‚Üî Fecha="${fechaExtracto}" + |ABONO|=${abonoAbsoluto}`);
                            break;
                        }
                    }
                }
                
                // console.log(`üìà RESUMEN IBK P7: ${conciliados} conciliados de ${candidatosLibro3} candidatos`);
                
                return {
                    candidatos: candidatosLibro3,
                    conciliados: conciliados
                };
            },

            procesarPaso11IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 11 IBK - ITF ESPEC√çFICO:
                
                CRITERIOS MAYOR (EST√ÅNDAR):
                - LIBRO = "09"
                - GLOSA contiene "ITF"
                - HABER > 0
                - ESTADO = "Pendiente"
                
                CRITERIOS EXTRACTO IBK (ESPEC√çFICO):
                - Movimiento contiene "ITF" (E en extracto original, √≠ndice 4)
                - Usar valor absoluto de CARGO (H en extracto original, √≠ndice 7)
                
                MAPEO:
                - Suma HABER (Mayor) vs suma |CARGO| (Extracto IBK)
                
                ESTADOS RESULTANTES:
                - "P11 - Conciliada"
                - Mayor: #REF = [Primera referencia del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del primer registro Mayor ITF
                */
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // console.log(`\nüìà === IBK PASO 11 - ITF ===`);
                
                let candidatosMayorITF = 0;
                let candidatosExtractoITF = 0;
                let conciliados = 0;
                
                // === 1. IDENTIFICAR ITF EN MAYOR ===
                // console.log(`\nüèõÔ∏è === ETAPA 1: IDENTIFICACI√ìN ITF EN MAYOR ===`);
                const candidatosMayor = [];
                let totalHaberMayor = 0;
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const glosa = (filaMayor[idxM.glosa] || '').toString().toUpperCase();
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    // Verificar criterios: LIBRO=09 + GLOSA contiene ITF + HABER > 0
                    const esLibro09 = String(libro || '').trim() === '09';
                    const contieneITF = glosa.includes('ITF');
                    const tieneHaber = haber > 0;
                    
                    if (esLibro09 && contieneITF && tieneHaber) {
                        candidatosMayorITF++;
                        totalHaberMayor += haber;
                        
                        candidatosMayor.push({
                            indice: i,
                            fila: filaMayor,
                            libro: libro,
                            glosa: glosa,
                            haber: haber,
                            comprob: comprob
                        });
                        
                        if (candidatosMayorITF <= 5) {
                            // console.log(`‚úÖ Mayor ITF ${candidatosMayorITF}: LIBRO="${libro}", GLOSA="${glosa.substring(0, 30)}...", HABER=${haber}`);
                        }
                    }
                }
                
                // console.log(`üìä Mayor ITF: ${candidatosMayorITF} candidatos, Total HABER: ${totalHaberMayor}`);
                
                if (candidatosMayorITF === 0) {
                    // console.log(`‚ö†Ô∏è No se encontraron candidatos ITF en Mayor`);
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // === 2. IDENTIFICAR ITF EN EXTRACTO IBK ===
                // console.log(`\nüí≥ === ETAPA 2: IDENTIFICACI√ìN ITF EN EXTRACTO IBK ===`);
                const candidatosExtracto = [];
                let totalCargoExtracto = 0;
                
                for (let j = 0; j < extractoProcesable.length; j++) {
                    if (estadosExtracto.has(j)) continue;
                    
                    const itemExtracto = extractoProcesable[j];
                    const filaExtracto = itemExtracto.fila;
                    if (!filaExtracto || !Array.isArray(filaExtracto)) continue;
                    
                    // IBK estructura original: E=Movimiento(4), H=Cargo(7)
                    const movimiento = (filaExtracto[4] || '').toString().toUpperCase();
                    const cargo = this.normalizarMonto(filaExtracto[7] || '0');
                    const cargoAbsoluto = Math.abs(cargo); // |CARGO|
                    
                    // DEBUG: Mostrar primeras 3 filas para verificar estructura
                    // if (j < 3) {
                    //     // console.log(`üîç DEBUG Fila ${j}:`);
                    //     // console.log(`   Fila completa:`, filaExtracto);
                    //     // console.log(`   [4] Movimiento: "${movimiento}"`);
                    //     // console.log(`   [7] Cargo: "${filaExtracto[7]}" ‚Üí ${cargo} ‚Üí |${cargoAbsoluto}|`);
                    // }
                    
                    // Verificar criterio: Movimiento contiene "ITF"
                    const contieneITF = movimiento.includes('ITF');
                    
                    if (contieneITF && cargoAbsoluto > 0) {
                        candidatosExtractoITF++;
                        totalCargoExtracto += cargoAbsoluto;
                        
                        candidatosExtracto.push({
                            indice: j,
                            fila: filaExtracto,
                            movimiento: movimiento,
                            cargo: cargo,
                            cargoAbsoluto: cargoAbsoluto
                        });
                        
                        if (candidatosExtractoITF <= 5) {
                            // console.log(`‚úÖ Extracto ITF ${candidatosExtractoITF}: Movimiento="${movimiento.substring(0, 30)}...", |CARGO|=${cargoAbsoluto}`);
                        }
                    }
                }
                
                // console.log(`üí≥ Extracto ITF: ${candidatosExtractoITF} candidatos, Total |CARGO|: ${totalCargoExtracto}`);
                
                if (candidatosExtractoITF === 0) {
                    // console.log(`‚ö†Ô∏è No se encontraron candidatos ITF en Extracto IBK`);
                    return { candidatos: candidatosMayorITF, conciliados: 0 };
                }
                
                // === 3. COMPARACI√ìN Y CONCILIACI√ìN ===
                // console.log(`\nüîÑ === ETAPA 3: COMPARACI√ìN TOTALES ===`);
                const tolerancia = 0.01;
                const diferencia = Math.abs(totalHaberMayor - totalCargoExtracto);
                
                // console.log(`üìä COMPARACI√ìN:`);
                // console.log(`   üèõÔ∏è Total HABER Mayor: ${totalHaberMayor}`);
                // console.log(`   üí≥ Total |CARGO| Extracto: ${totalCargoExtracto}`);
                // console.log(`   üìè Diferencia: ${diferencia}`);
                // console.log(`   ‚úÖ Tolerancia: ${tolerancia}`);
                
                if (diferencia <= tolerancia) {
                    // Conciliar todos los registros ITF
                    const primerComprobMayor = candidatosMayor[0]?.comprob || 'ITF';
                    const primeraRefExtracto = candidatosExtracto[0]?.fila[2] || 'ITF'; // Nro. Operaci√≥n (C en IBK reorganizada)
                    
                    // Marcar todos los candidatos del Mayor como conciliados
                    for (const candidato of candidatosMayor) {
                        estadosFilas.set(candidato.indice, {
                            estado: 'P11 - Conciliada',
                            ref: primeraRefExtracto
                        });
                        conciliados++;
                    }
                    
                    // Marcar todos los candidatos del Extracto como conciliados
                    for (const candidato of candidatosExtracto) {
                        estadosExtracto.set(candidato.indice, {
                            estado: 'P11 - Conciliada',
                            ref: `09-${primerComprobMayor}`
                        });
                    }
                    
                    // console.log(`‚úÖ P11 CONCILIADO: ${candidatosMayorITF} registros Mayor + ${candidatosExtractoITF} registros Extracto`);
                } else {
                    // console.log(`‚ùå P11 NO CONCILIADO: Diferencia ${diferencia} > tolerancia ${tolerancia}`);
                }
                
                // console.log(`üìà RESUMEN IBK P11: ${conciliados} conciliados de ${candidatosMayorITF} candidatos Mayor`);
                
                return {
                    candidatos: candidatosMayorITF + candidatosExtractoITF,
                    conciliados: conciliados,
                    totalMayor: totalHaberMayor,
                    totalExtracto: totalCargoExtracto,
                    diferencia: diferencia
                };
            },

            procesarPaso8IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 8 IBK - OPERACIONES M√öLTIPLES LIBROS INDIVIDUALES:
                
                CRITERIOS MAYOR:
                - LIBRO = "03", "09", "14", "15"
                - ESTADO = "Pendiente"
                - HABER > 0 (solo salidas de dinero)
                
                CRITERIOS EXTRACTO IBK:
                - CARGO < 0 (solo cargos/d√©bitos negativos)
                - ESTADO = "Pendiente"
                
                MAPEO INDIVIDUAL:
                - FDOC + HABER (Mayor) ‚Üî Fecha operaci√≥n + |CARGO| (Extracto IBK)
                - Mapeo 1:1 sin agrupaci√≥n
                
                ESTADOS RESULTANTES:
                - "P8 - Conciliada"
                - Mayor: #REF = [Operaci√≥n - N√∫mero del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del Mayor
                */
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // console.log(`\nüìà === IBK PASO 8 - OPERACIONES M√öLTIPLES LIBROS ===`);
                
                let candidatosLibro03 = 0;
                let candidatosLibro09 = 0;
                let candidatosLibro14 = 0;
                let candidatosLibro15 = 0;
                let conciliados = 0;
                
                // Libros objetivo del Paso 8
                const librosObjetivo = ['03', '09', '14', '15'];
                
                // Identificar candidatos de m√∫ltiples libros
                const candidatosPaso8 = [];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    
                    const esLibroObjetivo = librosObjetivo.includes(String(libro || '').trim());
                    
                    if (esLibroObjetivo) {
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                        const comprob = filaMayor[idxM.comprob] || '';
                        
                        // ‚≠ê FILTRO IBK PASO 8: Solo registros con HABER > 0 (salidas de dinero)
                        if (haber > 0) {
                            // Contar por libro
                            if (String(libro || '').trim() === '03') candidatosLibro03++;
                            else if (String(libro || '').trim() === '09') candidatosLibro09++;
                            else if (String(libro || '').trim() === '14') candidatosLibro14++;
                            else if (String(libro || '').trim() === '15') candidatosLibro15++;
                            
                            candidatosPaso8.push({
                                indice: i,
                                fila: filaMayor,
                                libro: libro,
                                fdoc: fdoc,
                                haber: haber,
                                comprob: comprob
                            });
                        }
                    }
                }
                
                const totalCandidatos = candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15;
                // console.log(`üìä Mayor P8: ${totalCandidatos} candidatos (L03=${candidatosLibro03}, L09=${candidatosLibro09}, L14=${candidatosLibro14}, L15=${candidatosLibro15})`);
                
                if (totalCandidatos === 0) {
                    // console.log(`‚ö†Ô∏è No se encontraron candidatos para PASO 8 IBK`);
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // AN√ÅLISIS DE CANDIDATOS DEL EXTRACTO IBK
                // console.log(`\nüí≥ === IBK PASO 8 - AN√ÅLISIS EXTRACTO ===`);
                const candidatosExtracto = [];
                
                for (let j = 0; j < extractoProcesable.length; j++) {
                    if (estadosExtracto.has(j)) continue;
                    
                    const itemExtracto = extractoProcesable[j];
                    // Para IBK: itemExtracto.fila contiene la estructura original, no reorganizada
                    // Necesitamos reorganizar aqu√≠: slice(1, 10) toma B-J del original
                    const filaOriginal = itemExtracto.fila;
                    if (!filaOriginal || !Array.isArray(filaOriginal)) continue;
                    
                    // Reorganizar IBK: B-J del original (√≠ndices 1-9) ‚Üí A-I del reorganizado (√≠ndices 0-8)
                    const filaExtracto = filaOriginal.slice(1, 10); // B12-J12 ‚Üí A1-I1
                    
                    // DEBUG: Mostrar estructura completa de las primeras 3 filas
                    if (j < 3) {
                        // console.log(`üîç DEBUG Extracto fila ${j}:`);
                        // console.log(`   Fila completa (${filaExtracto.length} elementos):`, filaExtracto);
                        // console.log(`   [0]: "${filaExtracto[0]}" (Fecha)`);
                        // console.log(`   [1]: "${filaExtracto[1]}"`);
                        // console.log(`   [2]: "${filaExtracto[2]}"`);
                        // console.log(`   [3]: "${filaExtracto[3]}"`);
                        // console.log(`   [4]: "${filaExtracto[4]}"`);
                        // console.log(`   [5]: "${filaExtracto[5]}"`);
                        // console.log(`   [6]: "${filaExtracto[6]}" (Cargo)`);
                        // console.log(`   [7]: "${filaExtracto[7]}"`);
                        // console.log(`   [8]: "${filaExtracto[8]}"`);
                        // console.log(`   [9]: "${filaExtracto[9]}"`);
                    }
                    
                    // IBK estructura reorganizada: A=Fecha operaci√≥n(0), G=Cargo(6)
                    const fechaExtracto = filaExtracto[0] || '';
                    const cargo = this.normalizarMonto(filaExtracto[6] || '0');
                    const cargoAbsoluto = Math.abs(cargo);
                    
                    // Para IBK: incluir TODOS los registros (cargo puede ser 0, positivo o negativo)
                    candidatosExtracto.push({
                        indice: j,
                        fechaOriginal: fechaExtracto,
                        fechaNormalizada: this.normalizarFecha(fechaExtracto),
                        cargoOriginal: cargo,
                        cargoAbsoluto: cargoAbsoluto,
                        operacion: filaExtracto[2] || ''
                    });
                }
                
                // console.log(`üìä Extracto IBK: ${candidatosExtracto.length} candidatos totales`);
                
                // DEBUG: Buscar fechas espec√≠ficas del mayor en el extracto
                const fechasMayor = ['2025-06-02', '2025-06-04', '2025-06-05'];
                fechasMayor.forEach(fechaBuscada => {
                    const coincidencias = candidatosExtracto.filter(cand => cand.fechaNormalizada === fechaBuscada);
                    // console.log(`üîç Fecha "${fechaBuscada}": ${coincidencias.length} registros en extracto`);
                    coincidencias.slice(0, 5).forEach((cand, idx) => {
                        // console.log(`   ${idx + 1}. |CARGO|: ${cand.cargoAbsoluto}, Op: "${cand.operacion}"`);
                    });
                });
                
                candidatosExtracto.slice(0, 10).forEach((cand, idx) => {
                    // console.log(`   ${idx + 1}. Fecha: "${cand.fechaOriginal}" ‚Üí "${cand.fechaNormalizada}", |CARGO|: ${cand.cargoAbsoluto}, Op: "${cand.operacion}"`);
                });
                if (candidatosExtracto.length > 10) {
                    // console.log(`   ... y ${candidatosExtracto.length - 10} m√°s`);
                }
                
                // MAPEO: FDOC+HABER vs FECHA+|CARGO|
                // console.log(`\nüîÑ === IBK PASO 8 - MAPEO FDOC+HABER vs FECHA+|CARGO| ===`);
                
                let intentosMapeo = 0;
                
                for (const candidato of candidatosPaso8) {
                    if (estadosFilas.has(candidato.indice)) continue;
                    
                    const fechaMayorNormalizada = this.normalizarFecha(candidato.fdoc);
                    
                    // DEBUG: Mostrar candidatos del mayor
                    if (intentosMapeo < 10) { // Aumentamos l√≠mite para ver todos los candidatos
                        // console.log(`üîç DEBUG Mayor P8 ${intentosMapeo + 1}:`);
                        // console.log(`   LIBRO="${candidato.libro}", FDOC="${candidato.fdoc}" ‚Üí "${fechaMayorNormalizada}", HABER=${candidato.haber}`);
                    }
                    
                    // Buscar coincidencia en extracto IBK
                    let intentosExtracto = 0;
                    for (let j = 0; j < extractoProcesable.length; j++) {
                        if (estadosExtracto.has(j)) continue;
                        
                        const itemExtracto = extractoProcesable[j];
                        // Para IBK: usar estructura ORIGINAL (extractoProcesable mantiene estructura original)
                        const filaOriginal = itemExtracto.fila;
                        if (!filaOriginal || !Array.isArray(filaOriginal)) continue;
                        
                        // IBK estructura ORIGINAL: A=vac√≠o, B=Fecha op, C=Fecha proc, D=Nro op, E=Movimiento, F=Descripci√≥n, G=Canal, H=Cargo, I=Abono, J=Saldo
                        const fechaExtracto = filaOriginal[1] || '';  // B=Fecha operaci√≥n
                        const nroOperacion = filaOriginal[3] || '';   // D=Nro operaci√≥n  
                        const cargo = this.normalizarMonto(filaOriginal[7] || '0'); // H=Cargo
                        
                        // ‚≠ê FILTRO IBK PASO 8: Solo registros con CARGO < 0 (cargos/d√©bitos)
                        if (cargo >= 0) continue; // Saltar registros con cargo positivo o cero
                        
                        const cargoAbsoluto = Math.abs(cargo); // |CARGO|
                        const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                        
                        // DEBUG: Mostrar filas del extracto para cada candidato del mayor
                        if (intentosExtracto < 10) { // Aumentamos l√≠mite para ver m√°s candidatos
                            // console.log(`üîç DEBUG Extracto fila ${j} (candidato ${intentosMapeo + 1}):`);
                            // console.log(`   Fila original completa:`, filaOriginal);
                            // console.log(`   [1]: "${filaOriginal[1]}" (B=Fecha operaci√≥n)`);
                            // console.log(`   [3]: "${filaOriginal[3]}" (D=Nro operaci√≥n)`);
                            // console.log(`   [7]: "${filaOriginal[7]}" (H=Cargo) ‚Üí ${cargo} ‚Üí |${cargoAbsoluto}|`);
                            // console.log(`   Coincide fecha: ${fechaMayorNormalizada} === ${fechaExtractoNormalizada} = ${fechaMayorNormalizada === fechaExtractoNormalizada}`);
                            // console.log(`   Coincide monto: ${candidato.haber} === ${cargoAbsoluto} = ${Math.abs(candidato.haber - cargoAbsoluto) < 0.01}`);
                        }  
                        if (intentosExtracto < 10) { // Aumentamos l√≠mite para debug
                            // console.log(`   Extracto ${intentosExtracto + 1}:`);
                            // console.log(`     Fecha original: "${fechaExtracto}" ‚Üí normalizada: "${fechaExtractoNormalizada}"`);
                            // console.log(`     |CARGO|: ${cargoAbsoluto}`);
                            // console.log(`     Mayor fecha: "${candidato.fdoc}" ‚Üí normalizada: "${fechaMayorNormalizada}"`);
                            // console.log(`     Mayor HABER: ${candidato.haber}`);
                            // console.log(`     ¬øFechas iguales?: ${fechaMayorNormalizada === fechaExtractoNormalizada}`);
                            // console.log(`     ¬øMontos iguales?: ${Math.abs(candidato.haber - cargoAbsoluto) < 0.01} (diff: ${Math.abs(candidato.haber - cargoAbsoluto)})`);
                            intentosExtracto++;
                        }
                        
                        const fechaCoincide = fechaMayorNormalizada === fechaExtractoNormalizada;
                        const tolerancia = 0.01;
                        const diferenciaMonto = Math.abs(candidato.haber - cargoAbsoluto);
                        const montoCoincide = diferenciaMonto < tolerancia;
                        
                        if (fechaCoincide && montoCoincide) {
                            // Para IBK: usar Nro. de operaci√≥n (columna D = √≠ndice 3 original)
                            const refMayor = nroOperacion || `P8-${fechaMayorNormalizada}`;
                            const refExtracto = `${candidato.libro}-${candidato.comprob}`;
                            
                            estadosFilas.set(candidato.indice, {
                                estado: 'P8 - Conciliada',
                                ref: refMayor
                            });
                            
                            estadosExtracto.set(j, {
                                estado: 'P8 - Conciliada',
                                ref: refExtracto
                            });
                            
                            conciliados++;
                            // console.log(`‚úÖ IBK PASO 8 - CONCILIACI√ìN EXITOSA:`);
                            // console.log(`   üìã Mayor: LIBRO=${candidato.libro}, FDOC="${candidato.fdoc}", HABER=${candidato.haber}, COMPROB=${candidato.comprob} ‚Üí REF="${refMayor}"`);
                            // console.log(`   üìã Extracto: FECHA="${fechaExtracto}", |CARGO|=${cargoAbsoluto}, NRO_OP="${nroOperacion}" ‚Üí REF="${refExtracto}"`);
                            break; // Salir del bucle extracto para este candidato Mayor (mapeo 1:1)
                        }
                    }
                    
                    intentosMapeo++;
                    // if (intentosMapeo >= 3) break; // Quitamos l√≠mite para ver todos los candidatos
                }
                
                // console.log(`üìà RESUMEN IBK P8: ${conciliados} conciliados de ${totalCandidatos} candidatos`);
                
                return {
                    candidatos: totalCandidatos,
                    conciliados: conciliados,
                    libro03: candidatosLibro03,
                    libro09: candidatosLibro09,
                    libro14: candidatosLibro14,
                    libro15: candidatosLibro15
                };
            },

            procesarPaso9IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto) {
                /*
                PASO 9 IBK - OPERACIONES M√öLTIPLES LIBROS AGRUPADAS:
                
                CRITERIOS MAYOR:
                - LIBRO = "03", "09", "14", "15"
                - ESTADO = "Pendiente"
                - HABER > 0 (solo salidas de dinero)
                - Agrupar por NUMDOC + FECHA ‚Üí sumar TOTAL HABER
                
                CRITERIOS EXTRACTO IBK:
                - CARGO < 0 (solo cargos/d√©bitos negativos)
                - ESTADO = "Pendiente"
                
                ESTRATEGIA:
                1. Agrupar Mayor por NUMDOC + FECHA ‚Üí sumar TOTAL HABER (solo HABER > 0)
                2. Mapear: FDOC + TOTAL HABER (Grupo) ‚Üî Fecha operaci√≥n + |CARGO| (Extracto IBK)
                3. Solo filas pendientes se incluyen en cada grupo
                
                ESTADOS RESULTANTES:
                - "P9 - Conciliada" para todas las filas del grupo
                - Mayor: #REF = [Operaci√≥n - N√∫mero del Extracto]
                - Extracto: #REF = "LIBRO-COMPROB" del primer registro del grupo
                */
                
                if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
                    return { candidatos: 0, conciliados: 0 };
                }
                
                // console.log(`\nüìà === IBK PASO 9 - OPERACIONES M√öLTIPLES LIBROS AGRUPADAS ===`);
                
                let candidatosLibro03 = 0;
                let candidatosLibro09 = 0;
                let candidatosLibro14 = 0;
                let candidatosLibro15 = 0;
                let gruposFormados = 0;
                let conciliados = 0;
                
                // Libros objetivo del Paso 9
                const librosObjetivo = ['03', '09', '14', '15'];
                
                // Agrupar filas por NUMDOC que cumplan criterios
                const gruposPorNUMDOC = new Map();
                
                // Primera pasada: Identificar candidatos y agrupar por NUMDOC
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    if (estadosFilas.has(i)) continue;
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = filaMayor[idxM.libro] || '';
                    const numdoc = filaMayor[idxM.numdoc] || '';
                    const fdoc = filaMayor[idxM.fdoc] || '';
                    const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
                    const comprob = filaMayor[idxM.comprob] || '';
                    
                    const esLibroObjetivo = librosObjetivo.includes(String(libro || '').trim());
                    
                    if (esLibroObjetivo) {
                        // ‚≠ê FILTRO IBK PASO 9: Solo registros con HABER > 0 (igual que Paso 8)
                        if (haber > 0) {
                            // Contar por libro
                            if (String(libro || '').trim() === '03') candidatosLibro03++;
                            else if (String(libro || '').trim() === '09') candidatosLibro09++;
                            else if (String(libro || '').trim() === '14') candidatosLibro14++;
                            else if (String(libro || '').trim() === '15') candidatosLibro15++;
                            
                            // ‚≠ê AGRUPAR POR NUMDOC + FECHA (evitar mezclar fechas diferentes)
                            const numdocNormalizado = this.normalizarTexto(numdoc);
                            const fechaNormalizada = this.normalizarFecha(fdoc);
                            const claveGrupo = `${numdocNormalizado}_${fechaNormalizada}`; // NUMDOC + FECHA
                            
                            if (!gruposPorNUMDOC.has(claveGrupo)) {
                                gruposPorNUMDOC.set(claveGrupo, {
                                    numdoc: numdocNormalizado,
                                    numdocOriginal: numdoc,
                                    fdoc: fdoc, // Usar FDOC del primer registro para mapeo
                                    fechaNormalizada: fechaNormalizada,
                                    totalHaber: 0,
                                    filas: []
                                });
                            }
                            
                            const grupo = gruposPorNUMDOC.get(claveGrupo);
                            grupo.totalHaber += haber;
                            grupo.filas.push({
                                indice: i,
                                fila: filaMayor,
                                libro: libro,
                                numdoc: numdoc,
                                fdoc: fdoc,
                                haber: haber,
                                comprob: comprob
                            });
                        }
                    }
                }
                
                gruposFormados = gruposPorNUMDOC.size;
                const totalCandidatos = candidatosLibro03 + candidatosLibro09 + candidatosLibro14 + candidatosLibro15;
                
                // console.log(`üìä Mayor P9: ${totalCandidatos} candidatos agrupados en ${gruposFormados} grupos por NUMDOC`);
                // console.log(`üìä Distribuci√≥n: L03=${candidatosLibro03}, L09=${candidatosLibro09}, L14=${candidatosLibro14}, L15=${candidatosLibro15}`);
                
                if (gruposFormados === 0) {
                    // console.log(`‚ö†Ô∏è No se formaron grupos para PASO 9 IBK`);
                    return { candidatos: totalCandidatos, grupos: 0, conciliados: 0 };
                }
                
                // MAPEO: FDOC+TOTAL HABER vs FECHA+|CARGO|
                // console.log(`\nüîÑ === IBK PASO 9 - MAPEO FDOC+TOTAL HABER vs FECHA+|CARGO| ===`);
                
                for (const [numdoc, grupo] of gruposPorNUMDOC) {
                    // ‚≠ê FILTRAR SOLO FILAS PENDIENTES del grupo (no saltar todo el grupo)
                    const filasPendientes = grupo.filas.filter(f => !estadosFilas.has(f.indice));
                    if (filasPendientes.length === 0) continue; // Solo continuar si no hay filas pendientes
                    
                    // Recalcular total HABER solo con filas pendientes
                    const totalHaberPendiente = filasPendientes.reduce((sum, f) => sum + f.haber, 0);
                    
                    const fechaMayorNormalizada = this.normalizarFecha(grupo.fdoc);
                    
                    // Buscar coincidencia en extracto IBK
                    for (let j = 0; j < extractoProcesable.length; j++) {
                        if (estadosExtracto.has(j)) continue;
                        
                        const itemExtracto = extractoProcesable[j];
                        // Para IBK: usar estructura ORIGINAL (igual que Paso 8)
                        const filaOriginal = itemExtracto.fila;
                        if (!filaOriginal || !Array.isArray(filaOriginal)) continue;
                        
                        // IBK estructura ORIGINAL: A=vac√≠o, B=Fecha op, C=Fecha proc, D=Nro op, E=Movimiento, F=Descripci√≥n, G=Canal, H=Cargo, I=Abono, J=Saldo
                        const fechaExtracto = filaOriginal[1] || '';  // B=Fecha operaci√≥n
                        const nroOperacion = filaOriginal[3] || '';   // D=Nro operaci√≥n  
                        const cargo = this.normalizarMonto(filaOriginal[7] || '0'); // H=Cargo
                        
                        // ‚≠ê FILTRO IBK PASO 9: Solo registros con CARGO < 0 (igual que Paso 8)
                        if (cargo >= 0) continue; // Saltar registros con cargo positivo o cero
                        
                        const cargoAbsoluto = Math.abs(cargo); // |CARGO|
                        const fechaExtractoNormalizada = this.normalizarFecha(fechaExtracto);
                        
                        const fechaCoincide = fechaMayorNormalizada === fechaExtractoNormalizada;
                        const montoCoincide = Math.abs(totalHaberPendiente - cargoAbsoluto) < 0.01;
                        
                        if (fechaCoincide && montoCoincide) {
                            // Para IBK: usar Nro. de operaci√≥n (columna D = √≠ndice 3 original)
                            const refMayor = nroOperacion || `P9-${fechaMayorNormalizada}`;
                            const primerComprob = grupo.filas[0]?.comprob || '';
                            const refExtracto = `${grupo.filas[0]?.libro || ''}-${primerComprob}`;
                            
                            // Conciliar solo las filas pendientes del grupo
                            for (const fila of filasPendientes) {
                                estadosFilas.set(fila.indice, {
                                    estado: 'P9 - Conciliada',
                                    ref: refMayor
                                });
                                conciliados++;
                            }
                            
                            estadosExtracto.set(j, {
                                estado: 'P9 - Conciliada',
                                ref: refExtracto
                            });
                            
                            // console.log(`‚úÖ P9 CONCILIADO: Grupo "${numdoc}" (${filasPendientes.length} filas pendientes de ${grupo.filas.length} total) FDOC="${grupo.fdoc}" + TOTAL HABER=${totalHaberPendiente} ‚Üî Fecha="${fechaExtracto}" + |CARGO|=${cargoAbsoluto}`);
                            break;
                        }
                    }
                }
                
                // console.log(`üìà RESUMEN IBK P9: ${conciliados} conciliados de ${totalCandidatos} candidatos en ${gruposFormados} grupos`);
                
                return {
                    candidatos: totalCandidatos,
                    grupos: gruposFormados,
                    conciliados: conciliados,
                    libro03: candidatosLibro03,
                    libro09: candidatosLibro09,
                    libro14: candidatosLibro14,
                    libro15: candidatosLibro15
                };
            },
     
            generateExcelFile(datosCompletos, fileName) {
        try {
            // // console.log(`üìÅ Generando archivo Excel con 3 hojas: ${fileName}`);
            
            // Crear workbook
            const wb = XLSX.utils.book_new();
            
                    // HOJA 1: MAYOR.PEN (renombrado)
            if (datosCompletos.datosMayor && datosCompletos.datosMayor.length > 0) {
                const wsMayor = XLSX.utils.aoa_to_sheet(datosCompletos.datosMayor);
                        XLSX.utils.book_append_sheet(wb, wsMayor, "MAYOR.PEN");
                        // // console.log(`   üìã Hoja 'MAYOR.PEN': ${datosCompletos.datosMayor.length} filas`);
                    }
                    
                    // HOJA 2: MAYOR.USD (nueva pesta√±a para cuenta 1041502)
            if (datosCompletos.datosMayorUSD && datosCompletos.datosMayorUSD.length > 0) {
                const wsMayorUSD = XLSX.utils.aoa_to_sheet(datosCompletos.datosMayorUSD);
                        XLSX.utils.book_append_sheet(wb, wsMayorUSD, "MAYOR.USD");
                        // // console.log(`   üìã Hoja 'MAYOR.USD': ${datosCompletos.datosMayorUSD.length} filas`);
                    }
                    
                    // HOJAS DE EXTRACTOS DIN√ÅMICAS (una por cuenta con sus datos espec√≠ficos)
                    if (datosCompletos.extractosPorCuenta) {
                        console.log(`üîç SBP.USD GENERANDO PESTA√ëAS EXTRACTO: ${datosCompletos.extractosPorCuenta.size} cuentas`);
                        if (datosCompletos.extractosPorCuenta.has('1041302')) {
                            console.log(`‚úÖ SBP.USD encontrado en extractosPorCuenta`);
                        } else {
                            console.log(`‚ùå SBP.USD NO encontrado en extractosPorCuenta`);
                        }
                        datosCompletos.extractosPorCuenta.forEach((extractoInfo, codigoCuenta) => {
                            if (codigoCuenta === '1041302') {
                                console.log(`üìã SBP.USD Procesando pesta√±a ${codigoCuenta} (${extractoInfo.config.pesta√±aExcel}):`);
                                console.log(`   üìä SBP.USD datosExtracto existe: ${!!extractoInfo.datosExtracto}`);
                                console.log(`   üìä SBP.USD datosExtracto longitud: ${extractoInfo.datosExtracto?.length || 0}`);
                            }
                            
                            if (extractoInfo.datosExtracto && extractoInfo.datosExtracto.length > 0) {
                                if (codigoCuenta === '1041302') {
                                    console.log(`   üìã SBP.USD Primera fila (header):`, extractoInfo.datosExtracto[0]);
                                }
                                const wsExtracto = XLSX.utils.aoa_to_sheet(extractoInfo.datosExtracto);
                                XLSX.utils.book_append_sheet(wb, wsExtracto, extractoInfo.config.pesta√±aExcel);
                                if (codigoCuenta === '1041302') {
                                    console.log(`   ‚úÖ SBP.USD Pesta√±a '${extractoInfo.config.pesta√±aExcel}' agregada: ${extractoInfo.datosExtracto.length} filas`);
                                }
                            } else {
                                if (codigoCuenta === '1041302') {
                                    console.log(`   ‚ö†Ô∏è SBP.USD No se agreg√≥ pesta√±a '${extractoInfo.config.pesta√±aExcel}': sin datos`);
                                }
                            }
                        });
                        
                        // SBP.USD y otras cuentas USD ya est√°n manejadas por la l√≥gica normal de extractosPorCuenta
                        // No necesitamos l√≥gica especial aqu√≠
                    } else {
                        // Fallback para compatibilidad con estructura anterior
                        const cuentasActivas = this.getCuentasActivas();
                        cuentasActivas.forEach((cuenta, index) => {
            if (datosCompletos.datosExtracto && datosCompletos.datosExtracto.length > 0) {
                const wsExtracto = XLSX.utils.aoa_to_sheet(datosCompletos.datosExtracto);
                                XLSX.utils.book_append_sheet(wb, wsExtracto, cuenta.pesta√±aExcel);
                                // // console.log(`   üìã Hoja '${cuenta.pesta√±aExcel}': ${datosCompletos.datosExtracto.length} filas`);
                            }
                        });
                    }
                    
                    // HOJA 3: SALDO (nombre fijo)
            if (datosCompletos.datosSaldo && datosCompletos.datosSaldo.length > 0) {
                const wsSaldo = XLSX.utils.aoa_to_sheet(datosCompletos.datosSaldo);
                        XLSX.utils.book_append_sheet(wb, wsSaldo, "SALDO");
                        // // console.log(`   üìã Hoja 'SALDO': ${datosCompletos.datosSaldo.length} filas`);
            }
            
            // Generar archivo
            const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
            
            const blob = new Blob([wbout], { type: 'application/octet-stream' });
            const url = window.URL.createObjectURL(blob);
            
            // Crear enlace de descarga autom√°tica
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            // // console.log(`üíæ Descarga iniciada: ${fileName} con 3 hojas`);
            return url;
        } catch (error) {
            console.error("‚ùå Error generando Excel:", error);
            throw error;
        }
    },

            procesarPaso12BCP(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
                /*
                PASO 12 BCP - AGRUPACI√ìN ESPEC√çFICA PARA BCP (01, 02, USD):
                
                ESTRATEGIA BCP:
                1. Agrupar por FDOC en Mayor: FDOC de LIBROS "03", "09", "14", "15"
                2. Agrupar por FECHA en Extracto: Fecha de transacci√≥n
                3. Mapear: FDOC+TOTAL_HABER (Mayor) vs FECHA+TOTAL_|MONTO| (Extracto)
                4. Usar FDOC como #REF para grupos conciliados
                
                DIFERENCIAS CON SANTANDER:
                - BCP usa FDOC para agrupaci√≥n en lugar de solo fecha
                - Los montos se comparan con tolerancia de centavos
                - Referencia usa formato "BCP-FDOC-[fecha]"
        
        ESTADOS RESULTANTES:
        - "P12 - Conciliada" para registros mapeados
        */
        
                // ‚≠ê VERIFICAR QUE ES BCP
                const esBCP = cuentaConfig && (cuentaConfig.codigo === '1041501' || cuentaConfig.codigo === '1041505' || cuentaConfig.codigo === '1041502');
                
                if (!esBCP) {
                    return { candidatos: 0, grupos: 0, conciliados: 0 };
                }
                
                // // console.log(`\nüè¶ *** BCP PASO 12 INICIADO *** - Agrupaci√≥n por FDOC (${cuentaConfig.alias})`);
                
                let gruposMayorCreados = 0;
                let gruposExtractoCreados = 0;
                let conciliados = 0;
                
                // === 1. CREAR GRUPOS DEL MAYOR (LIBROS 03/09/14/15) ===
                const gruposMayor = new Map(); // Key: FDOC, Value: {registros: [], totalHaber: 0}
                const librosPermitidos = ['03', '09', '14', '15'];
                
                for (let i = 0; i < filasFiltradasMayor.length; i++) {
                    const estadoActual = estadosFilas.get(i);
                    if (estadoActual && estadoActual.estado !== 'Pendiente') {
                        continue; // Saltar registros ya conciliados
                    }
                    
                    const filaMayor = filasFiltradasMayor[i];
                    const libro = String(filaMayor[idxM.libro] || '').trim();
                    const fdoc = String(filaMayor[idxM.fdoc] || '').trim();
                    const haber = parseFloat(filaMayor[idxM.haber] || 0);
                    
                    if (librosPermitidos.includes(libro) && fdoc && haber > 0) {
                        if (!gruposMayor.has(fdoc)) {
                            gruposMayor.set(fdoc, { registros: [], totalHaber: 0 });
                            gruposMayorCreados++;
                        }
                        
                        gruposMayor.get(fdoc).registros.push({ indice: i, haber: haber });
                        gruposMayor.get(fdoc).totalHaber += haber;
                    }
                }
                
                // === 2. CREAR GRUPOS DEL EXTRACTO POR FECHA ===
                const gruposExtracto = new Map(); // Key: FECHA, Value: {registros: [], totalMonto: 0}
                
                for (let j = 0; j < extractoProcesable.length; j++) {
                    const estadoExtracto = estadosExtracto.get(j);
                    if (estadoExtracto && estadoExtracto.estado !== 'Pendiente') {
                        continue; // Saltar registros ya conciliados
                    }
                    
                    const filaExtracto = extractoProcesable[j];
                    const fecha = String(filaExtracto[idxE.fecha] || '').trim();
                    const monto = Math.abs(parseFloat(filaExtracto[idxE.monto] || 0));
                    
                    if (fecha && monto > 0) {
                        if (!gruposExtracto.has(fecha)) {
                            gruposExtracto.set(fecha, { registros: [], totalMonto: 0 });
                            gruposExtractoCreados++;
                        }
                        
                        gruposExtracto.get(fecha).registros.push({ indice: j, monto: monto });
                        gruposExtracto.get(fecha).totalMonto += monto;
                    }
                }
                
                // === 3. MAPEAR GRUPOS: FDOC+HABER vs FECHA+MONTO ===
                gruposMayor.forEach((grupoMayor, fdoc) => {
                    const totalHaber = grupoMayor.totalHaber;
                    
                    // Buscar grupo del extracto con monto similar
                    let mejorMatch = null;
                    let menorDiferencia = Infinity;
                    
                    gruposExtracto.forEach((grupoExtracto, fecha) => {
                        const totalMonto = grupoExtracto.totalMonto;
                        const diferencia = Math.abs(totalHaber - totalMonto);
                        
                        if (diferencia < menorDiferencia && diferencia <= 0.02) { // Tolerancia de 2 centavos
                            mejorMatch = { fecha: fecha, grupo: grupoExtracto };
                            menorDiferencia = diferencia;
                        }
                    });
                    
                    if (mejorMatch) {
                        // CONCILIAR GRUPO COMPLETO
                        const refBCP = `BCP-${fdoc}`;
                        
                        // Marcar registros del Mayor
                        grupoMayor.registros.forEach(item => {
                            estadosFilas.set(item.indice, {
                                estado: 'P12 - Conciliada',
                                ref: refBCP
                            });
                        });
                        
                        // Marcar registros del Extracto  
                        mejorMatch.grupo.registros.forEach(item => {
                            estadosExtracto.set(item.indice, {
                                estado: 'P12 - Conciliada',
                                ref: refBCP
                            });
                        });
                        
                        // Eliminar grupo del extracto para evitar reutilizaci√≥n
                        gruposExtracto.delete(mejorMatch.fecha);
                        
                        conciliados++;
                        
                        // // console.log(`‚úÖ BCP PASO 12 - CONCILIACI√ìN EXITOSA:`);
                        // // console.log(`   üìÖ FDOC: ${fdoc}, Total HABER: ${totalHaber} (${grupoMayor.registros.length} registros)`);
                        // // console.log(`   üìÖ FECHA: ${mejorMatch.fecha}, Total MONTO: ${mejorMatch.grupo.totalMonto} (${mejorMatch.grupo.registros.length} registros)`);
                        // // console.log(`   üîó REF: "${refBCP}"`);
                    }
                });
                
                // // console.log(`üìä BCP PASO 12 - RESUMEN:`);
                // // console.log(`   üìã Grupos Mayor creados: ${gruposMayorCreados}`);
                // // console.log(`   üìã Grupos Extracto creados: ${gruposExtractoCreados}`);
                // // console.log(`   üéØ Conciliados: ${conciliados}`);
                
                return {
                    candidatos: gruposMayorCreados,
                    grupos: gruposExtractoCreados,
                    conciliados: conciliados
                };
            },

            procesarPaso12SBP(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
        /*
        PASO 12 SBP - L√ìGICA DUAL:
        
        SBP.USD (1041302): MAPEO DIRECTO POR MONTOS
        - Estrategia simple: MONTO Mayor (DEBE o HABER) ‚Üî |Monto| Extracto
        - Solo coincidencias exactas con tolerancia 0.01
        
        SBP.PEN (1041301): AGRUPACI√ìN TRADICIONAL
        - Mayor: Libros 2/3/9/14/15 agrupados por COMPROB
        - Extracto: Agrupado por Referencia
        - Comparaci√≥n: FDOC+TOTAL_HABER vs Fecha+|TOTAL_IMPORTE|
        */
        
        const esSBPUSD = cuentaConfig && cuentaConfig.codigo === '1041302';
        
        // Para SBP.USD usar mapeo directo simple
        if (esSBPUSD) {
            return this.procesarPaso12SBPDirecto(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig);
        }
        
        // Para SBP.PEN continuar con l√≥gica tradicional de agrupaci√≥n
        let gruposMayorCreados = 0;
        let gruposExtractoCreados = 0;
        let conciliados = 0;
        
        // === 1. CREAR GRUPOS DEL MAYOR (LIBROS 2/3/9/14/15) ===
        const gruposMayor = new Map(); // Key: COMPROB, Value: {registros: [], fdoc: '', totalHaber: 0}
        const librosPermitidos = ['2', '3', '9', '14', '15'];
        
        // Agrupando Mayor por COMPROB
        // Libros permitidos definidos
        
        for (let i = 0; i < filasFiltradasMayor.length; i++) {
            if (estadosFilas.has(i)) continue; // Solo procesar pendientes
            
            const filaMayor = filasFiltradasMayor[i];
            const libro = (filaMayor[idxM.libro] || '').toString().trim();
            const comprob = (filaMayor[idxM.comprob] || '').toString().trim();
            const fdoc = (filaMayor[idxM.fdoc] || '').toString().trim();
            const haber = this.normalizarMonto(filaMayor[idxM.haber] || '0');
            
            // Debug: mostrar los primeros registros
            if (i < 10) {
                // // console.log(`üìã Mayor ${i}: LIBRO="${libro}" COMPROB="${comprob}" FDOC="${fdoc}" HABER=${haber}`);
            }
            
            // Verificar si est√° en los libros permitidos
            if (!librosPermitidos.includes(libro)) {
                continue;
            }
            
            // Crear o actualizar grupo por COMPROB
            if (!gruposMayor.has(comprob)) {
                gruposMayor.set(comprob, {
                    registros: [],
                    fdoc: fdoc, // Usar FDOC del primer registro
                    totalHaber: 0,
                    libro: libro
                });
                gruposMayorCreados++;
                // // console.log(`‚úÖ GRUPO MAYOR ${gruposMayorCreados}: COMPROB="${comprob}" FDOC="${fdoc}" LIBRO=${libro}`);
            }
            
            const grupo = gruposMayor.get(comprob);
            grupo.registros.push({
                indice: i,
                fila: filaMayor
            });
            grupo.totalHaber += haber;
            
            if (grupo.registros.length <= 3) { // Mostrar solo los primeros de cada grupo
                // Registro agregado al grupo
            }
        }
        
        // Grupos Mayor creados
        
        // === 2. CREAR GRUPOS DEL EXTRACTO (POR REFERENCIA) ===
        const gruposExtracto = new Map(); // Key: Referencia, Value: {registros: [], fecha: '', totalImporte: 0}
        
        // Agrupando extracto por referencia
        
        for (let j = 0; j < extractoProcesable.length; j++) {
            if (estadosExtracto.has(j)) continue; // Solo procesar pendientes
            
            const itemExtracto = extractoProcesable[j];
            const filaExtracto = itemExtracto.fila;
            const referencia = (filaExtracto[idxE.operacion] || '').toString().trim();
            const fecha = (filaExtracto[idxE.fecha] || '').toString().trim();
            const importe = this.normalizarMonto(filaExtracto[idxE.monto] || '0');
            
            // Debug: mostrar los primeros registros
            if (j < 10) {
                // // console.log(`üìã Extracto ${j}: REF="${referencia}" FECHA="${fecha}" IMPORTE=${Math.abs(importe).toFixed(2)}`);
            }
            
            // Solo procesar si tiene referencia
            if (!referencia || referencia === '') {
                continue;
            }
            
            // Crear o actualizar grupo por REFERENCIA
            if (!gruposExtracto.has(referencia)) {
                gruposExtracto.set(referencia, {
                    registros: [],
                    fecha: fecha, // Usar fecha del primer registro
                    totalImporte: 0
                });
                gruposExtractoCreados++;
                // // console.log(`‚úÖ GRUPO EXTRACTO ${gruposExtractoCreados}: REF="${referencia}" FECHA="${fecha}"`);
            }
            
            const grupo = gruposExtracto.get(referencia);
            grupo.registros.push({
                indice: j,
                fila: filaExtracto
            });
            grupo.totalImporte += Math.abs(importe);
            
            if (grupo.registros.length <= 3) { // Mostrar solo los primeros de cada grupo
                // Registro agregado al grupo extracto
            }
        }
        
        // Grupos Extracto creados
        
        // === 3. MAPEAR GRUPOS: FDOC+TOTAL_HABER vs FECHA+|TOTAL_IMPORTE| ===
        // Mapeando grupos SBP
        
        let gruposMatched = 0;
        
        for (const [comprobMayor, grupoMayor] of gruposMayor) {
            const claveMapeoMayor = `${grupoMayor.fdoc}_${grupoMayor.totalHaber.toFixed(2)}`;
            
            // console.log(`üîç Buscando match para COMPROB="${comprobMayor}": FDOC="${grupoMayor.fdoc}" + HABER=${grupoMayor.totalHaber.toFixed(2)} (${grupoMayor.registros.length} registros)`);
            
            let matchEncontrado = false;
            
            for (const [referenciaExtracto, grupoExtracto] of gruposExtracto) {
                const claveMapeoExtracto = `${this.normalizarFecha(grupoExtracto.fecha)}_${grupoExtracto.totalImporte.toFixed(2)}`;
                
                // COMPARAR: FDOC+TOTAL_HABER vs FECHA_NORMALIZADA+|TOTAL_IMPORTE|
                const fechaNormalizadaExtracto = this.normalizarFecha(grupoExtracto.fecha);
                const esMismoBanco = grupoMayor.fdoc === fechaNormalizadaExtracto;
                const esMismoMonto = Math.abs(grupoMayor.totalHaber - grupoExtracto.totalImporte) < 0.01;
                
                if (esMismoBanco && esMismoMonto) {
                    // // console.log(`‚úÖ MATCH ENCONTRADO!`);
                    // // console.log(`   üìã Mayor COMPROB="${comprobMayor}": FDOC="${grupoMayor.fdoc}" HABER=${grupoMayor.totalHaber.toFixed(2)}`);
                    // // console.log(`   üìã Extracto REF="${referenciaExtracto}": FECHA="${fechaNormalizadaExtracto}" IMPORTE=${grupoExtracto.totalImporte.toFixed(2)}`);
                    
                    matchEncontrado = true;
                    gruposMatched++;
                    
                    // Conciliar todos los registros del Mayor en este grupo
                    grupoMayor.registros.forEach((registro, idx) => {
                        estadosFilas.set(registro.indice, {
                            estado: 'P12 - Conciliada',
                            ref: referenciaExtracto
                        });
                        conciliados++;
                        if (idx < 3) { // Solo mostrar los primeros
                            // // console.log(`   ‚úÖ Mayor ${registro.indice}: COMPROB="${comprobMayor}" ‚Üí REF="${referenciaExtracto}"`);
                        }
                    });
                    
                    // Conciliar todos los registros del Extracto en este grupo
                    grupoExtracto.registros.forEach((registro, idx) => {
                        estadosExtracto.set(registro.indice, {
                            estado: 'P12 - Conciliada',
                            ref: `${grupoMayor.libro}-${comprobMayor}`
                        });
                        conciliados++;
                        if (idx < 3) { // Solo mostrar los primeros
                            // // console.log(`   ‚úÖ Extracto ${registro.indice}: REF="${referenciaExtracto}" ‚Üí REF="${grupoMayor.libro}-${comprobMayor}"`);
                        }
                    });
                    
                    // Remover grupo del extracto para evitar m√∫ltiples matches
                    gruposExtracto.delete(referenciaExtracto);
                    break;
                }
            }
            
            if (!matchEncontrado) {
                // No match para grupo mayor
            }
        }
        
        // SBP Paso 12 completado
        // Estad√≠sticas SBP Paso 12
        
        return {
            gruposMayor: gruposMayorCreados,
            gruposExtracto: gruposExtractoCreados,
            gruposMatched: gruposMatched,
            conciliados: conciliados
        };
    },

    procesarPaso12IBK(filasFiltradasMayor, extractoProcesable, idxM, idxE, estadosFilas, estadosExtracto, cuentaConfig = null) {
        /*
        PASO 12 IBK - REPROCESAMIENTO PASO 4:
        
        OBJETIVO:
        Reprocesar la primera fase del Paso 4 IBK para todos los registros que quedaron pendientes
        despu√©s de los 11 pasos anteriores, dando una segunda oportunidad de conciliaci√≥n.
        
        ESTRATEGIA:
        1. Identificar registros PENDIENTES tanto en Mayor como Extracto
        2. Aplicar exactamente la misma l√≥gica de la ETAPA 1 del Paso 4 IBK:
           - Buscar candidatos IBK en extracto (FINANC. DE DOCS con cargo -8 y FCD ABON.CTA)
           - Agrupar por fecha de operaci√≥n
           - Buscar coincidencias con Mayor (DES_TDOP="Bna" + LIBRO="04" + DEBE > 0)
        3. Mapear: FDOC + DEBE (Mayor) vs Fecha + Total Grupo (Extracto)
        
        CRITERIOS EXTRACTO (IGUALES AL PASO 4):
        1. Movimiento = "FINANC. DE DOCS" Y Cargo = "-8"
        2. Descripci√≥n = "FCD ABON.CTA"
        3. Agrupar por Fecha de operaci√≥n del mismo d√≠a
        
        CRITERIOS MAYOR (IGUALES AL PASO 4):
        - DES_TDOP="Bna" + LIBRO="04" + DEBE > 0 + PENDIENTES
        
        ESTADOS RESULTANTES:
        - "P12 - Conciliada" para registros mapeados exitosamente
        - Referencias cruzadas Mayor ‚Üî Extracto
        */
        
        if (!extractoProcesable || !Array.isArray(extractoProcesable)) {
            return { candidatos: 0, conciliados: 0 };
        }
        
        console.log(`\nüîÑ === IBK PASO 12 - REPROCESAMIENTO DEL PASO 4 PARA REGISTROS PENDIENTES ===`);
        console.log(`üìä Total filas Mayor: ${filasFiltradasMayor.length}`);
        console.log(`üìä Total filas Extracto: ${extractoProcesable.length}`);
        console.log(`üìä Criterio: Solo procesar registros con ESTADO = "Pendiente"`);
        console.log(`üìä Estados Mayor ya procesados: ${estadosFilas.size}`);
        console.log(`üìä Estados Extracto ya procesados: ${estadosExtracto.size}`);
        
        let candidatosExtractoIBK = 0;
        let contadorCandidatosMayorBNA = 0;
        let conciliados = 0;
        
        // === FASE 1: BUSCAR CANDIDATOS DEL EXTRACTO IBK CON ESTADO "Pendiente" ===
        const candidatosGrupoIBK = [];
        
        for (let i = 0; i < extractoProcesable.length; i++) {
            const item = extractoProcesable[i];
            const fila = item.fila;
            if (!fila || !Array.isArray(fila)) continue;
            
            // PASO 12: Solo procesar registros con ESTADO = "Pendiente"
            const estadoActual = item.estado || '';
            if (estadoActual !== 'Pendiente') {
                if (i < 5) console.log(`   ‚è≠Ô∏è Extracto[${i}] ignorado - Estado: "${estadoActual}" (no es Pendiente)`);
                continue;
            }
            
            // IBK estructura ORIGINAL: A=vac√≠o, B=Fecha op, C=Fecha proc, D=Nro op, E=Movimiento, F=Descripci√≥n, G=Canal, H=Cargo, I=Abono, J=Saldo
            const fechaOperacion = fila[1] || '';     // B (√≠ndice 1)
            const movimiento = (fila[4] || '').toString();  // E (√≠ndice 4)
            const descripcion = (fila[5] || '').toString(); // F (√≠ndice 5)
            const cargo = (fila[7] || '').toString();       // H (√≠ndice 7)
            const abono = fila[8] || '';              // I (√≠ndice 8)
            
            let esCandidata = false;
            let tipoRegistro = '';
            
            // Criterio 1: FINANC. DE DOCS en MOVIMIENTO Y cargo -8
            if (movimiento.trim() === 'FINANC. DE DOCS' && cargo && cargo.trim() === '-8') {
                esCandidata = true;
                tipoRegistro = 'FINANC_DOCS';
            }
            
            // Criterio 2: FCD ABON.CTA en DESCRIPCI√ìN
            if (descripcion.trim() === 'FCD ABON.CTA') {
                esCandidata = true;
                tipoRegistro = 'FCD_ABON';
            }
            
            if (esCandidata) {
                const cargoNumerico = this.normalizarMonto(cargo || '0');
                const abonoNumerico = this.normalizarMonto(abono || '0');
                const importeFila = cargoNumerico + abonoNumerico;
                
                candidatosGrupoIBK.push({
                    tipo: tipoRegistro,
                    indice: i,
                    fechaOperacion: fechaOperacion,
                    importeFila: importeFila,
                    fila: fila
                });
                candidatosExtractoIBK++;
            }
        }
        
        console.log(`üìã Candidatos IBK encontrados en extracto (TOTAL): ${candidatosExtractoIBK}`);
        
        if (candidatosExtractoIBK === 0) {
            console.log(`‚ö†Ô∏è No hay candidatos IBK en el extracto que cumplan criterios FINANC.DE DOCS o FCD ABON.CTA`);
            return { candidatos: 0, conciliados: 0 };
        }
        
        // === FASE 2: AGRUPAR CANDIDATOS POR FECHA ===
        const gruposPorFechaExtracto = new Map();
        
        candidatosGrupoIBK.forEach(candidato => {
            const fechaNormalizada = this.normalizarFecha(candidato.fechaOperacion);
            if (!gruposPorFechaExtracto.has(fechaNormalizada)) {
                gruposPorFechaExtracto.set(fechaNormalizada, []);
            }
            gruposPorFechaExtracto.get(fechaNormalizada).push(candidato);
        });
        
        console.log(`üìÖ Grupos por fecha en extracto: ${gruposPorFechaExtracto.size}`);
        
        // === FASE 3: CALCULAR TOTALES POR GRUPO DE FECHA ===
        const totalesPorFecha = new Map();
        
        gruposPorFechaExtracto.forEach((grupo, fecha) => {
            const totalImporte = grupo.reduce((sum, candidato) => sum + candidato.importeFila, 0);
            console.log(`üìä Calculando total para fecha ${fecha}:`);
            grupo.forEach(candidato => {
                console.log(`   ${candidato.tipo}: √≠ndice ${candidato.indice}, importe ${candidato.importeFila.toFixed(2)}`);
            });
            console.log(`   üí∞ Total del grupo: ${totalImporte.toFixed(2)}`);
            
            totalesPorFecha.set(fecha, {
                total: totalImporte,
                indices: grupo.map(c => c.indice),
                grupo: grupo
            });
        });
        
        // === FASE 4: BUSCAR CANDIDATOS DEL MAYOR BNA CON ESTADO "Pendiente" ===
        const candidatosMayorBNA = [];
        
        for (let i = 0; i < filasFiltradasMayor.length; i++) {
            const filaMayor = filasFiltradasMayor[i];
            
            // PASO 12: Solo procesar registros con ESTADO = "Pendiente"
            const estadoInfo = estadosFilas.get(i);
            const estadoActual = estadoInfo ? estadoInfo.estado : 'Pendiente';
            if (estadoActual !== 'Pendiente') {
                if (i < 5) console.log(`   ‚è≠Ô∏è Mayor[${i}] ignorado - Estado: "${estadoActual}" (no es Pendiente)`);
                continue;
            }
            
            const destdop = (filaMayor[idxM.destdop] || '').toString();
            const libro = (filaMayor[idxM.libro] || '').toString();
            const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
            const fdoc = filaMayor[idxM.fdoc] || '';
            
            if (destdop === 'Bna' && libro === '04' && debe > 0) {
                candidatosMayorBNA.push({
                    indice: i,
                    fdoc: fdoc,
                    debe: debe,
                    fila: filaMayor
                });
                contadorCandidatosMayorBNA++;
            }
        }
        
        console.log(`üìã Candidatos Mayor BNA encontrados (TOTAL): ${contadorCandidatosMayorBNA}`);
        
        if (contadorCandidatosMayorBNA === 0) {
            console.log(`‚ö†Ô∏è No hay candidatos Mayor BNA que cumplan criterios DES_TDOP=Bna + LIBRO=04 + DEBE>0`);
            return { candidatos: candidatosExtractoIBK, conciliados: 0 };
        }
        
        // === FASE 5: MAPEO FDOC + DEBE vs FECHA + TOTAL ===
        console.log(`\nüîÑ === FASE 5: INICIANDO MAPEO FDOC + DEBE vs FECHA + TOTAL ===`);
        
        totalesPorFecha.forEach((grupoExtracto, fechaExtracto) => {
            console.log(`\nüìÖ Grupo Extracto - Fecha: ${fechaExtracto}, Total: ${grupoExtracto.total.toFixed(2)}, Registros: [${grupoExtracto.indices.join(',')}]`);
            
            candidatosMayorBNA.forEach(candidatoMayor => {
                // PASO 12: Procesar candidatos que est√°n en estado "Pendiente"
                
                const fechaMayorNormalizada = this.normalizarFecha(candidatoMayor.fdoc);
                const tolerancia = 1.0; // Tolerancia m√°s amplia para captar diferencias de redondeo
                
                console.log(`   üèõÔ∏è Candidato Mayor[${candidatoMayor.indice}] - FDOC: ${candidatoMayor.fdoc} ‚Üí ${fechaMayorNormalizada}, DEBE: ${candidatoMayor.debe.toFixed(2)}`);
                
                // Verificar coincidencia de fecha y monto
                const fechasCoinciden = fechaMayorNormalizada === fechaExtracto;
                
                // Tambi√©n verificar fechas con tolerancia de ¬±2 d√≠as h√°biles
                const fechaMayor = new Date(fechaMayorNormalizada);
                const fechaExtractoDate = new Date(fechaExtracto);
                const diferenciaDias = Math.abs((fechaMayor - fechaExtractoDate) / (1000 * 60 * 60 * 24));
                const fechasProximas = diferenciaDias <= 3; // Tolerancia de 3 d√≠as
                
                const montosCoinciden = Math.abs(candidatoMayor.debe - Math.abs(grupoExtracto.total)) <= tolerancia;
                const diferenciaMonto = candidatoMayor.debe - Math.abs(grupoExtracto.total);
                
                console.log(`      üìä Fecha exacta: ${fechasCoinciden}, Fecha pr√≥xima (¬±3d): ${fechasProximas}, Diff d√≠as: ${diferenciaDias.toFixed(1)}`);
                console.log(`      üí∞ Monto coincide: ${montosCoinciden} (diff: ${diferenciaMonto.toFixed(2)}), Tolerancia: ¬±${tolerancia}`);
                
                if ((fechasCoinciden || fechasProximas) && montosCoinciden) {
                    // CONCILIACI√ìN EXITOSA EN PASO 12
                    const comprob = candidatoMayor.fila[idxM.comprob] || '';
                    const libro = candidatoMayor.fila[idxM.libro] || '';
                    
                    // Marcar Mayor como conciliado (sabemos que estaba Pendiente)
                    estadosFilas.set(candidatoMayor.indice, {
                        estado: 'P12 - Conciliada',
                        ref: `IBK-GRUPO-${fechaExtracto}`
                    });
                    conciliados += 1;
                    
                    // Marcar registros del extracto como conciliados (sabemos que estaban Pendiente)
                    grupoExtracto.indices.forEach(idxExtracto => {
                        estadosExtracto.set(idxExtracto, {
                            estado: 'P12 - Conciliada',
                            ref: `${libro}-${comprob}`
                        });
                        conciliados += 1;
                    });
                    
                    console.log(`‚úÖ MAPEO P12 EXITOSO: Mayor[${candidatoMayor.indice}] FDOC=${candidatoMayor.fdoc} DEBE=${candidatoMayor.debe.toFixed(2)} ‚Üî Extracto Grupo[${grupoExtracto.indices.join(',')}] FECHA=${fechaExtracto} TOTAL=${grupoExtracto.total.toFixed(2)}`);
                    console.log(`   üìä Diferencia fecha: ${diferenciaDias.toFixed(1)} d√≠as, Diferencia monto: ${diferenciaMonto.toFixed(2)}`);
                }
            });
        });
        
        console.log(`\nüìä IBK PASO 12 - RESUMEN FINAL:`);
        console.log(`   üìã Candidatos Extracto IBK: ${candidatosExtractoIBK}`);
        console.log(`   üìã Candidatos Mayor BNA: ${contadorCandidatosMayorBNA}`);
        console.log(`   üéØ Total registros conciliados: ${conciliados}`);
        
        // === AN√ÅLISIS DETALLADO DE REGISTROS PENDIENTES ===
        console.log(`\nüîç === AN√ÅLISIS DETALLADO DE REGISTROS PENDIENTES ===`);
        
        // Analizar extracto pendientes
        let pendientesExtracto = 0;
        for (let i = 0; i < extractoProcesable.length; i++) {
            const item = extractoProcesable[i];
            const estadoActual = item.estado || '';
            if (estadoActual === 'Pendiente') {
                pendientesExtracto++;
                if (pendientesExtracto <= 10) { // Solo mostrar primeros 10
                    const fila = item.fila || [];
                    const movimiento = (fila[4] || '').toString();
                    const descripcion = (fila[5] || '').toString();
                    const cargo = this.normalizarMonto(fila[7] || '0');
                    const abono = this.normalizarMonto(fila[8] || '0');
                    console.log(`   üìù Extracto[${i}] PENDIENTE: MOV="${movimiento}" DESC="${descripcion}" CARGO=${cargo} ABONO=${abono}`);
                }
            }
        }
        console.log(`üìä Total registros PENDIENTES en extracto: ${pendientesExtracto}`);
        
        // Analizar mayor pendientes
        let pendientesMayor = 0;
        for (let i = 0; i < filasFiltradasMayor.length; i++) {
            const estadoInfo = estadosFilas.get(i);
            const estadoActual = estadoInfo ? estadoInfo.estado : 'Pendiente';
            if (estadoActual === 'Pendiente') {
                const filaMayor = filasFiltradasMayor[i];
                const destdop = (filaMayor[idxM.destdop] || '').toString();
                const libro = (filaMayor[idxM.libro] || '').toString();
                const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
                if (destdop === 'Bna' && libro === '04' && debe > 0) {
                    pendientesMayor++;
                    if (pendientesMayor <= 10) { // Solo mostrar primeros 10
                        const fdoc = filaMayor[idxM.fdoc] || '';
                        const comprob = filaMayor[idxM.comprob] || '';
                        console.log(`   üèõÔ∏è Mayor[${i}] PENDIENTE BNA: FDOC="${fdoc}" DEBE=${debe} COMPROB="${comprob}"`);
                    }
                }
            }
        }
        console.log(`üìä Total registros PENDIENTES BNA en mayor: ${pendientesMayor}`);
        
        // Mostrar grupos formados
        console.log(`\nüìÖ === GRUPOS FORMADOS POR FECHA ===`);
        totalesPorFecha.forEach((grupoExtracto, fechaExtracto) => {
            console.log(`   üìÖ Fecha: ${fechaExtracto} | Total: ${grupoExtracto.total.toFixed(2)} | Registros: ${grupoExtracto.indices.length} [${grupoExtracto.indices.join(',')}]`);
        });
        
        // Mostrar candidatos mayor encontrados
        console.log(`\nüèõÔ∏è === CANDIDATOS MAYOR BNA ENCONTRADOS ===`);
        candidatosMayorBNA.forEach((candidato, idx) => {
            if (idx < 10) { // Solo mostrar primeros 10
                console.log(`   üèõÔ∏è [${idx}] Indice: ${candidato.indice} | FDOC: ${candidato.fdoc} | DEBE: ${candidato.debe.toFixed(2)}`);
            }
        });
        
        // === AN√ÅLISIS ESPEC√çFICO DEL CASO PROBLEM√ÅTICO ===
        console.log(`\nüéØ === AN√ÅLISIS ESPEC√çFICO DEL CASO PROBLEM√ÅTICO ===`);
        
        // Buscar el registro Mayor con FDOC 45813 y DEBE 53342.53
        let registroMayorProblematico = null;
        for (let i = 0; i < filasFiltradasMayor.length; i++) {
            const filaMayor = filasFiltradasMayor[i];
            const fdoc = filaMayor[idxM.fdoc] || '';
            const debe = this.normalizarMonto(filaMayor[idxM.debe] || '0');
            if (fdoc === '45813' && Math.abs(debe - 53342.53) < 1) {
                const estadoInfo = estadosFilas.get(i);
                const estadoActual = estadoInfo ? estadoInfo.estado : 'Pendiente';
                registroMayorProblematico = { indice: i, fdoc, debe, estado: estadoActual };
                console.log(`üèõÔ∏è ENCONTRADO Mayor problem√°tico[${i}]: FDOC=${fdoc} DEBE=${debe.toFixed(2)} ESTADO=${estadoActual}`);
                break;
            }
        }
        
        // Buscar grupo del 05/06/2025 en extracto
        let grupoExtractoProblematico = null;
        if (totalesPorFecha.has('05/06/2025')) {
            const grupo = totalesPorFecha.get('05/06/2025');
            grupoExtractoProblematico = grupo;
            console.log(`üìù ENCONTRADO Grupo extracto problem√°tico: Fecha=05/06/2025 Total=${grupo.total.toFixed(2)} Registros=[${grupo.indices.join(',')}]`);
            
            // Analizar cada registro del grupo
            grupo.indices.forEach(idx => {
                const item = extractoProcesable[idx];
                const estadoActual = item.estado || '';
                const fila = item.fila || [];
                const movimiento = (fila[4] || '').toString();
                const descripcion = (fila[5] || '').toString();
                const cargo = this.normalizarMonto(fila[7] || '0');
                const abono = this.normalizarMonto(fila[8] || '0');
                console.log(`     üìã Extracto[${idx}]: MOV="${movimiento}" DESC="${descripcion}" CARGO=${cargo} ABONO=${abono} ESTADO=${estadoActual}`);
            });
        }
        
        // Analizar por qu√© no se mape√≥
        if (registroMayorProblematico && grupoExtractoProblematico) {
            console.log(`\nüîç === AN√ÅLISIS DE MAPEO ===`);
            const fechaMayorNormalizada = this.normalizarFecha(registroMayorProblematico.fdoc);
            const fechaExtracto = '05/06/2025';
            const tolerancia = 1.0;
            
            const diferenciaMonto = registroMayorProblematico.debe - Math.abs(grupoExtractoProblematico.total);
            const montosCoinciden = Math.abs(diferenciaMonto) <= tolerancia;
            
            const fechaObj1 = new Date(fechaMayorNormalizada);
            const fechaObj2 = new Date(fechaExtracto);
            const diferenciaDias = Math.abs((fechaObj1.getTime() - fechaObj2.getTime()) / (1000 * 60 * 60 * 24));
            const fechasCoinciden = fechaMayorNormalizada === fechaExtracto;
            const fechasProximas = diferenciaDias <= 3;
            
            console.log(`üèõÔ∏è Mayor: FDOC=${registroMayorProblematico.fdoc} ‚Üí Normalizada=${fechaMayorNormalizada} | DEBE=${registroMayorProblematico.debe.toFixed(2)} | ESTADO=${registroMayorProblematico.estado}`);
            console.log(`üìù Extracto: Fecha=${fechaExtracto} | Total=${grupoExtractoProblematico.total.toFixed(2)}`);
            console.log(`üìä Fechas coinciden: ${fechasCoinciden} | Fechas pr√≥ximas (¬±3d): ${fechasProximas} | Diff d√≠as: ${diferenciaDias.toFixed(1)}`);
            console.log(`üí∞ Montos coinciden: ${montosCoinciden} | Diff monto: ${diferenciaMonto.toFixed(2)} | Tolerancia: ¬±${tolerancia}`);
            console.log(`‚úÖ ¬øDeber√≠a conciliar?: ${(fechasCoinciden || fechasProximas) && montosCoinciden}`);
            
            if (registroMayorProblematico.estado !== 'Pendiente') {
                console.log(`‚ùå PROBLEMA: El registro Mayor NO est√° en estado 'Pendiente', por eso no se procesa en Paso 12`);
            }
            
            // Verificar si alg√∫n registro del grupo extracto no est√° Pendiente
            let todosExtractoPendientes = true;
            grupoExtractoProblematico.indices.forEach(idx => {
                const item = extractoProcesable[idx];
                const estadoActual = item.estado || '';
                if (estadoActual !== 'Pendiente') {
                    todosExtractoPendientes = false;
                    console.log(`‚ùå PROBLEMA: Extracto[${idx}] NO est√° en estado 'Pendiente' (Estado: '${estadoActual}'), por eso no se incluye en grupo`);
                }
            });
            
            if (todosExtractoPendientes) {
                console.log(`‚úÖ Todos los registros del grupo extracto est√°n 'Pendiente'`);
            }
        }
        
        console.log(`\nüîÑ === FIN AN√ÅLISIS PASO 12 IBK ===`);
        
        return {
            candidatos: candidatosExtractoIBK + contadorCandidatosMayorBNA,
            conciliados: conciliados
        };
    }
        }; // cierre del objeto return
    } // cierre de la funci√≥n bancarioConciliador
</script>

</div>
</body>
</html>
